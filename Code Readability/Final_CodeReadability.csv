Code Snippet,Code Readability Score
"@Override
    public void runTest(final Test test, final TestResult result) {
        Thread t = new Thread() {
            @Override
            public void run() {
                try {
                    // inlined due to limitation in VA/Java
                    //ActiveTestSuite.super.runTest(test, result);
                    test.run(result);
                } finally {
                    ActiveTestSuite.this.runFinished();
                }
            }
        };
        t.start();
    }",4.222222222222222
"/**
     * ...as the moon sets over the early morning Merlin, Oregon
     * mountains, our intrepid adventurers type...
     */
    static public Test createTest(Class<?> theClass, String name) {
        Constructor<?> constructor;
        try {
            constructor = getTestConstructor(theClass);
        } catch (NoSuchMethodException e) {
            return warning(""Class "" + theClass.getName() + "" has no public constructor TestCase(String name) or TestCase()"");
        }
        Object test;
        try {
            if (constructor.getParameterTypes().length == 0) {
                test = constructor.newInstance(new Object[0]);
                if (test instanceof TestCase) {
                    ((TestCase) test).setName(name);
                }
            } else {
                test = constructor.newInstance(new Object[]{name});
            }
        } catch (InstantiationException e) {
            return (warning(""Cannot instantiate test case: "" + name + "" ("" + exceptionToString(e) + "")""));
        } catch (InvocationTargetException e) {
            return (warning(""Exception in constructor: "" + name + "" ("" + exceptionToString(e.getTargetException()) + "")""));
        } catch (IllegalAccessException e) {
            return (warning(""Cannot access test case: "" + name + "" ("" + exceptionToString(e) + "")""));
        }
        return (Test) test;
    }",3.555555555555556
"/**
     * Provides serialization support.
     *
     * @param stream  the input stream (<code>null</code> not permitted).
     *
     * @throws IOException  if there is an I/O error.
     * @throws ClassNotFoundException  if there is a classpath problem.
     */
    private void readObject(ObjectInputStream stream)
        throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        this.titlePaint = SerialUtilities.readPaint(stream);
        this.subtitlePaint = SerialUtilities.readPaint(stream);
        this.chartBackgroundPaint = SerialUtilities.readPaint(stream);
        this.legendBackgroundPaint = SerialUtilities.readPaint(stream);
        this.legendItemPaint = SerialUtilities.readPaint(stream);
        this.plotBackgroundPaint = SerialUtilities.readPaint(stream);
        this.plotOutlinePaint = SerialUtilities.readPaint(stream);
        this.labelLinkPaint = SerialUtilities.readPaint(stream);
        this.baselinePaint = SerialUtilities.readPaint(stream);
        this.domainGridlinePaint = SerialUtilities.readPaint(stream);
        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);
        this.crosshairPaint = SerialUtilities.readPaint(stream);
        this.axisLabelPaint = SerialUtilities.readPaint(stream);
        this.tickLabelPaint = SerialUtilities.readPaint(stream);
        this.itemLabelPaint = SerialUtilities.readPaint(stream);
        this.shadowPaint = SerialUtilities.readPaint(stream);
        this.thermometerPaint = SerialUtilities.readPaint(stream);
        this.wallPaint = SerialUtilities.readPaint(stream);
        this.errorIndicatorPaint = SerialUtilities.readPaint(stream);
        this.gridBandPaint = SerialUtilities.readPaint(stream);
        this.gridBandAlternatePaint = SerialUtilities.readPaint(stream);
    }",3.555555555555556
"/**
     * Constructs a panel that displays the specified chart.
     *
     * @param chart  the chart.
     */
    public ChartPanel(JFreeChart chart) {

        this(
            chart,
            DEFAULT_WIDTH,
            DEFAULT_HEIGHT,
            DEFAULT_MINIMUM_DRAW_WIDTH,
            DEFAULT_MINIMUM_DRAW_HEIGHT,
            DEFAULT_MAXIMUM_DRAW_WIDTH,
            DEFAULT_MAXIMUM_DRAW_HEIGHT,
            DEFAULT_BUFFER_USED,
            true,  // properties
            true,  // save
            true,  // print
            true,  // zoom
            true   // tooltips
        );

    }",4.333333333333333
"/**
     * static initializer, register all appropriate notations.
     */
    static void init() {
        NotationProviderFactory2 npf = NotationProviderFactory2.getInstance();
        NotationName name = /*Notation.findNotation(""Java"");*/
            Notation.makeNotation(
                    ""Java"",
                    null,
                    ResourceLoaderWrapper.lookupIconResource(""JavaNotation""));

        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_NAME,
                name, ModelElementNameNotationJava.class);
        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_ATTRIBUTE,
                name, AttributeNotationJava.class);
        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_OPERATION,
                name, OperationNotationJava.class);
        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_ASSOCIATION_END_NAME,
                name, AssociationEndNameNotationJava.class);
        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_ASSOCIATION_NAME,
                name, AssociationNameNotationJava.class);
    }",4.0
"/**
     * {@inheritDoc}
     *
     * Overridden to find the start of a line-end.
     */
    public boolean addChar(char c) {
	if (c == '\n') {
	    hasLf = true;
	    return true;
	}

	if (c == '\r') {
	    hasCr = true;
	    return true;
	}

	return false;
    }",4.555555555555555
"/**
     * Loads the bundle (if not already loaded).
     *
     * @param name The name of the bundle to load.
     */
    private static void loadBundle(String name) {
        if (bundles.containsKey(name)) {
            return;
        }
        String resource = BUNDLES_PATH + ""."" + name;
        ResourceBundle bundle = null;
        try {
            LOG.debug(""Loading "" + resource);
            bundle = ResourceBundle.getBundle(resource, Locale.getDefault());
        } catch (MissingResourceException e1) {
            LOG.debug(""Resource "" + resource
		      + "" not found in the default class loader."");

	    Iterator iter = classLoaders.iterator();
	    while (iter.hasNext()) {
		ClassLoader cl = (ClassLoader) iter.next();
		try {
		    LOG.debug(""Loading "" + resource + "" from "" + cl);
		    bundle =
			ResourceBundle.getBundle(resource,
						 Locale.getDefault(),
						 cl);
		    break;
		} catch (MissingResourceException e2) {
		    LOG.debug(""Resource "" + resource + "" not found in "" + cl);
		}
	    }
        }

        bundles.put(name, bundle);
    }",3.0
"protected synchronized String evalToString(
            Object self,
            String expr,
            String sep)
    	throws ExpansionException {

        _scratchBindings.put(""self"", self);
        java.util.List values = eval(_scratchBindings, expr);
        _strBuf.setLength(0);
        Iterator iter = values.iterator();
        while (iter.hasNext()) {
            Object v = iter.next();
            if (Model.getFacade().isAModelElement(v)) {
                v = Model.getFacade().getName(v);
                if ("""".equals(v)) {
                    v = Translator.localize(""misc.name.anon"");
                }
            }
            if (Model.getFacade().isAExpression(v)) {
                v = Model.getFacade().getBody(v);
                if ("""".equals(v)) {
                    v = ""(unspecified)"";
                }
            }
            if (!"""".equals(v)) {
                _strBuf.append(v);
                if (iter.hasNext()) {
                    _strBuf.append(sep);
                }
            }
        }
        return _strBuf.toString();
    }",3.111111111111111
"/**
     * Notify all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     * @see EventListenerList
     */
    public void fireTreeStructureChanged(
					 Object source,
					 Object[] path,
					 int[] childIndices,
					 Object[] children) {

        // Guaranteed to return a non-null array
        Object[] listeners = listenerList.getListenerList();
        TreeModelEvent e = null;
        // Process the listeners last to first, notifying
        // those that are interested in this event
        for (int i = listeners.length - 2; i >= 0; i -= 2) {
            if (listeners[i] == TreeModelListener.class) {
                // Lazily create the event:
                if (e == null)
                    e =
                        new TreeModelEvent(
					   source,
					   path,
					   childIndices,
					   children);
                ((TreeModelListener) listeners[i + 1]).treeStructureChanged(e);
            }
        }
    }",3.7777777777777777
"private void myDoubleClick(Object src) {
	Object sel = null;
	Diagram d = null;
	if (src == resultsTable) {
	    int row = resultsTable.getSelectionModel().getMinSelectionIndex();
	    if (row < 0) {
                return;
            }
	    sel = results.elementAt(row);
	    d = (Diagram) diagrams.elementAt(row);
	} else if (src == relatedTable) {
	    int row = relatedTable.getSelectionModel().getMinSelectionIndex();
	    if (row < 0) {
                return;
            }
	    numJumpToRelated++;
	    sel = related.elementAt(row);
	}

	if (d != null) {
            LOG.debug(""go "" + sel + "" in "" + d.getName());
            TargetManager.getInstance().setTarget(d);
        }
	TargetManager.getInstance().setTarget(sel);
    }",3.2222222222222223
"public void propertyChange(PropertyChangeEvent evt) {
        // the project changed
        if (evt.getPropertyName()
            .equals(ProjectManager.CURRENT_PROJECT_PROPERTY_NAME)) {
            Project p = (Project) evt.getNewValue();
            if (p != null) {
                titleHandler.buildTitle(p.getName(), null);
                //Designer.TheDesigner.getToDoList().removeAllElements();
                Designer.setCritiquingRoot(p);
                // update all panes
                TargetManager.getInstance().setTarget(p.getInitialTarget());
            }
        }
    }",4.0
"public void testFailure() {
        String expected = expected(new String[]{"".F"", ""Time: 0"", ""Failures here"", """", ""FAILURES!!!"", ""Tests run: 1,  Failures: 1,  Errors: 0"", """"});
        ResultPrinter printer = new TestResultPrinter(new PrintStream(output)) {
            @Override
            public void printFailures(TestResult result) {
                getWriter().println(""Failures here"");
            }
        };
        runner.setPrinter(printer);
        TestSuite suite = new TestSuite();
        suite.addTest(new TestCase() {
            @Override
            public void runTest() {
                throw new AssertionFailedError();
            }
        });
        runner.doRun(suite);
        assertEquals(expected, output.toString());
    }",3.333333333333333
"private Object createTestUsingFieldInjection() throws Exception {
            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();
            if (annotatedFieldsByParameter.size() != fParameters.length) {
                throw new Exception(""Wrong number of parameters and @Parameter fields."" +
                        "" @Parameter fields counted: "" + annotatedFieldsByParameter.size() + "", available parameters: "" + fParameters.length + ""."");
            }
            Object testClassInstance = getTestClass().getJavaClass().newInstance();
            for (FrameworkField each : annotatedFieldsByParameter) {
                Field field = each.getField();
                Parameter annotation = field.getAnnotation(Parameter.class);
                int index = annotation.value();
                try {
                    field.set(testClassInstance, fParameters[index]);
                } catch (IllegalArgumentException iare) {
                    throw new Exception(getTestClass().getName() + "": Trying to set "" + field.getName() +
                            "" with the value "" + fParameters[index] +
                            "" that is not the right type ("" + fParameters[index].getClass().getSimpleName() + "" instead of "" +
                            field.getType().getSimpleName() + "")."", iare);
                }
            }
            return testClassInstance;
        }",3.555555555555556
"@Override
        protected void validateFields(List<Throwable> errors) {
            super.validateFields(errors);
            if (fieldsAreAnnotated()) {
                List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();
                int[] usedIndices = new int[annotatedFieldsByParameter.size()];
                for (FrameworkField each : annotatedFieldsByParameter) {
                    int index = each.getField().getAnnotation(Parameter.class).value();
                    if (index < 0 || index > annotatedFieldsByParameter.size() - 1) {
                        errors.add(
                                new Exception(""Invalid @Parameter value: "" + index + "". @Parameter fields counted: "" +
                                        annotatedFieldsByParameter.size() + "". Please use an index between 0 and "" +
                                        (annotatedFieldsByParameter.size() - 1) + ""."")
                        );
                    } else {
                        usedIndices[index]++;
                    }
                }
                for (int index = 0; index < usedIndices.length; index++) {
                    int numberOfUse = usedIndices[index];
                    if (numberOfUse == 0) {
                        errors.add(new Exception(""@Parameter("" + index + "") is never used.""));
                    } else if (numberOfUse > 1) {
                        errors.add(new Exception(""@Parameter("" + index + "") is used more than once ("" + numberOfUse + "").""));
                    }
                }
            }
        }",3.555555555555556
"String[] parseOptions(String[] args) {
        for (int i = 0; i != args.length; ++i) {
            String arg = args[i];

            try {
                if (arg.equals(""--"")) {
                    return copyArray(args, i + 1, args.length);
                } else if (arg.startsWith(""--"")) {
                    if (arg.startsWith(""--filter="") || arg.equals(""--filter"")) {
                        String filterSpec;
                        if (arg.equals(""--filter"")) {
                            ++i;

                            if (i < args.length) {
                                filterSpec = args[i];
                            } else {
                                parserErrors.add(new CommandLineParserError(arg + "" value not specified""));

                                break;
                            }
                        } else {
                            filterSpec = arg.substring(arg.indexOf('=') + 1);
                        }

                        filter = filter.intersect(FilterFactories.createFilterFromFilterSpec(
                                createSuiteDescription(arg), filterSpec));
                    } else {
                        parserErrors.add(new CommandLineParserError(""JUnit knows nothing about the "" + arg + "" option""));
                    }
                } else {
                    return copyArray(args, i, args.length);
                }
            } catch (FilterFactory.FilterNotCreatedException e) {
                parserErrors.add(e);
            }
        }

        return new String[]{};
    }",2.6666666666666665
"private static Set<String> buildHintsSet() {
		HashSet<String> hints = new HashSet<String>();
		hints.add( HINT_TIMEOUT );
		hints.add( SPEC_HINT_TIMEOUT );
		hints.add( HINT_COMMENT );
		hints.add( HINT_FETCH_SIZE );
		hints.add( HINT_CACHE_REGION );
		hints.add( HINT_CACHEABLE );
		hints.add( HINT_READONLY );
		hints.add( HINT_CACHE_MODE );
		hints.add( HINT_FLUSH_MODE );
		hints.add( HINT_NATIVE_LOCKMODE );
		hints.add( HINT_FETCHGRAPH );
		hints.add( HINT_LOADGRAPH );
		return java.util.Collections.unmodifiableSet( hints );
	}",4.444444444444445
"@Test
	public void testHiLoAlgorithm() {
		session = (SessionImpl) sessionFactory.openSession();
		((Session)session).beginTransaction();

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// initially sequence should be uninitialized
		assertEquals( 0L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// historically the hilo generators skipped the initial block of values;
		// 		so the first generated id value is maxlo + 1, here be 4
		Long generatedValue = (Long) generator.generate( session, null );
		assertEquals( 1L, generatedValue.longValue() );
		// which should also perform the first read on the sequence which should set it to its ""start with"" value (1)
		assertEquals( 1L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		generatedValue = (Long) generator.generate( session, null );
		assertEquals( 2L, generatedValue.longValue() );
		assertEquals( 2L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		generatedValue = (Long) generator.generate( session, null );
		assertEquals( 3L, generatedValue.longValue() );
		assertEquals( 3L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		generatedValue = (Long) generator.generate( session, null );
		assertEquals( 4L, generatedValue.longValue() );
		assertEquals( 4L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		generatedValue = (Long) generator.generate( session, null );
		assertEquals( 5L, generatedValue.longValue() );
		assertEquals( 5L, extractSequenceValue( (session) ) );

		((Session)session).getTransaction().commit();
		((Session)session).close();
	}",3.6666666666666665
"/**
	 * Constructs a PostgresPlusDialect
	 */
	public PostgresPlusDialect() {
		super();

		registerFunction( ""ltrim"", new StandardSQLFunction( ""ltrim"" ) );
		registerFunction( ""rtrim"", new StandardSQLFunction( ""rtrim"" ) );
		registerFunction( ""soundex"", new StandardSQLFunction( ""soundex"" ) );
		registerFunction( ""sysdate"", new NoArgSQLFunction( ""sysdate"", StandardBasicTypes.DATE, false ) );
		registerFunction( ""rowid"", new NoArgSQLFunction( ""rowid"", StandardBasicTypes.LONG, false ) );
		registerFunction( ""rownum"", new NoArgSQLFunction( ""rownum"", StandardBasicTypes.LONG, false ) );
		registerFunction( ""instr"", new StandardSQLFunction( ""instr"", StandardBasicTypes.INTEGER ) );
		registerFunction( ""lpad"", new StandardSQLFunction( ""lpad"", StandardBasicTypes.STRING ) );
		registerFunction( ""replace"", new StandardSQLFunction( ""replace"", StandardBasicTypes.STRING ) );
		registerFunction( ""rpad"", new StandardSQLFunction( ""rpad"", StandardBasicTypes.STRING ) );
		registerFunction( ""translate"", new StandardSQLFunction( ""translate"", StandardBasicTypes.STRING ) );
		registerFunction( ""substring"", new StandardSQLFunction( ""substr"", StandardBasicTypes.STRING ) );
		registerFunction( ""coalesce"", new NvlFunction() );
		registerFunction( ""atan2"", new StandardSQLFunction( ""atan2"", StandardBasicTypes.FLOAT ) );
		registerFunction( ""mod"", new StandardSQLFunction( ""mod"", StandardBasicTypes.INTEGER ) );
		registerFunction( ""nvl"", new StandardSQLFunction( ""nvl"" ) );
		registerFunction( ""nvl2"", new StandardSQLFunction( ""nvl2"" ) );
		registerFunction( ""power"", new StandardSQLFunction( ""power"", StandardBasicTypes.FLOAT ) );
		registerFunction( ""add_months"", new StandardSQLFunction( ""add_months"", StandardBasicTypes.DATE ) );
		registerFunction( ""months_between"", new StandardSQLFunction( ""months_between"", StandardBasicTypes.FLOAT ) );
		registerFunction( ""next_day"", new StandardSQLFunction( ""next_day"", StandardBasicTypes.DATE ) );
	}",4.0
"/**
	 * Constructs a Oracle8iDialect
	 */
	public Oracle8iDialect() {
		super();
		registerCharacterTypeMappings();
		registerNumericTypeMappings();
		registerDateTimeTypeMappings();
		registerLargeObjectTypeMappings();
		registerReverseHibernateTypeMappings();
		registerFunctions();
		registerDefaultProperties();
	}",4.0
"/**
	 * Constructs a InterbaseDialect
	 */
	public InterbaseDialect() {
		super();
		registerColumnType( Types.BIT, ""smallint"" );
		registerColumnType( Types.BIGINT, ""numeric(18,0)"" );
		registerColumnType( Types.SMALLINT, ""smallint"" );
		registerColumnType( Types.TINYINT, ""smallint"" );
		registerColumnType( Types.INTEGER, ""integer"" );
		registerColumnType( Types.CHAR, ""char(1)"" );
		registerColumnType( Types.VARCHAR, ""varchar($l)"" );
		registerColumnType( Types.FLOAT, ""float"" );
		registerColumnType( Types.DOUBLE, ""double precision"" );
		registerColumnType( Types.DATE, ""date"" );
		registerColumnType( Types.TIME, ""time"" );
		registerColumnType( Types.TIMESTAMP, ""timestamp"" );
		registerColumnType( Types.VARBINARY, ""blob"" );
		registerColumnType( Types.NUMERIC, ""numeric($p,$s)"" );
		registerColumnType( Types.BLOB, ""blob"" );
		registerColumnType( Types.CLOB, ""blob sub_type 1"" );
		registerColumnType( Types.BOOLEAN, ""smallint"" );
		
		registerFunction( ""concat"", new VarArgsSQLFunction( StandardBasicTypes.STRING, ""("",""||"","")"" ) );
		registerFunction( ""current_date"", new NoArgSQLFunction( ""current_date"", StandardBasicTypes.DATE, false ) );

		getDefaultProperties().setProperty( Environment.STATEMENT_BATCH_SIZE, NO_BATCH );
	}",3.888888888888889
"/**
	 * Constructs a SybaseASE157Dialect
	 */
	public SybaseASE157Dialect() {
		super();

		registerFunction( ""create_locator"", new SQLFunctionTemplate( StandardBasicTypes.BINARY, ""create_locator(?1, ?2)"" ) );
		registerFunction( ""locator_literal"", new SQLFunctionTemplate( StandardBasicTypes.BINARY, ""locator_literal(?1, ?2)"" ) );
		registerFunction( ""locator_valid"", new SQLFunctionTemplate( StandardBasicTypes.BOOLEAN, ""locator_valid(?1)"" ) );
		registerFunction( ""return_lob"", new SQLFunctionTemplate( StandardBasicTypes.BINARY, ""return_lob(?1, ?2)"" ) );
		registerFunction( ""setdata"", new SQLFunctionTemplate( StandardBasicTypes.BOOLEAN, ""setdata(?1, ?2, ?3)"" ) );
		registerFunction( ""charindex"", new SQLFunctionTemplate( StandardBasicTypes.INTEGER, ""charindex(?1, ?2, ?3)"" ) );
	}",4.0
"public String extractConstraintName(SQLException sqle) {
			try {
				final int sqlState = Integer.valueOf( JdbcExceptionHelper.extractSqlState( sqle ) );
				switch (sqlState) {
					// CHECK VIOLATION
					case 23514: return extractUsingTemplate( ""violates check constraint \"""",""\"""", sqle.getMessage() );
					// UNIQUE VIOLATION
					case 23505: return extractUsingTemplate( ""violates unique constraint \"""",""\"""", sqle.getMessage() );
					// FOREIGN KEY VIOLATION
					case 23503: return extractUsingTemplate( ""violates foreign key constraint \"""",""\"""", sqle.getMessage() );
					// NOT NULL VIOLATION
					case 23502: return extractUsingTemplate( ""null value in column \"""",""\"" violates not-null constraint"", sqle.getMessage() );
					// TODO: RESTRICT VIOLATION
					case 23001: return null;
					// ALL OTHER
					default: return null;
				}
			}
			catch (NumberFormatException nfe) {
				return null;
			}
		}",4.555555555555555
"@Test
	@TestForIssue(jiraKey = ""HHH-8007"")
	public void testGetLimitStringSelectingMultipleColumnsFromSeveralTables() {
		final String query = ""select t1.*, t2.* from tab1 t1, tab2 t2 where t1.ref = t2.ref order by t1.id desc"";

		assertEquals(
				""WITH query AS (SELECT inner_query.*, ROW_NUMBER() OVER (ORDER BY CURRENT_TIMESTAMP) as __hibernate_row_nr__ FROM ( "" +
						""select TOP(?) t1.*, t2.* from tab1 t1, tab2 t2 where t1.ref = t2.ref order by t1.id desc ) inner_query ) "" +
						""SELECT * FROM query WHERE __hibernate_row_nr__ >= ? AND __hibernate_row_nr__ < ?"",
				dialect.buildLimitHandler( query, toRowSelection( 1, 3 ) ).getProcessedSql()
		);
	}",3.2222222222222223
"@Test
	public void testInsertLimitWithForUpdateAndWithClauses() {
		final int limit = 50;
		final int offset = 200;
		final String input = ""select c11 as col1, c12 as col2, c13 as col13 from t1 where flight_id between 'AA1111' and 'AA1112' for update of c11,c13 with rr"";
		final String expected = ""select c11 as col1, c12 as col2, c13 as col13 from t1 where flight_id between 'AA1111' and 'AA1112' offset "" + offset
				+ "" rows fetch next "" + limit + "" rows only for update of c11,c13 with rr"";

		final String actual = new LocalDerbyDialect().getLimitString( input, offset, limit );
		assertEquals( expected, actual );
	}",3.6666666666666665
"/**
	 * Constructs a FrontBaseDialect
	 */
	public FrontBaseDialect() {
		super();

		registerColumnType( Types.BIT, ""bit"" );
		registerColumnType( Types.BIGINT, ""longint"" );
		registerColumnType( Types.SMALLINT, ""smallint"" );
		registerColumnType( Types.TINYINT, ""tinyint"" );
		registerColumnType( Types.INTEGER, ""integer"" );
		registerColumnType( Types.CHAR, ""char(1)"" );
		registerColumnType( Types.VARCHAR, ""varchar($l)"" );
		registerColumnType( Types.FLOAT, ""float"" );
		registerColumnType( Types.DOUBLE, ""double precision"" );
		registerColumnType( Types.DATE, ""date"" );
		registerColumnType( Types.TIME, ""time"" );
		registerColumnType( Types.TIMESTAMP, ""timestamp"" );
		registerColumnType( Types.VARBINARY, ""bit varying($l)"" );
		registerColumnType( Types.NUMERIC, ""numeric($p,$s)"" );
		registerColumnType( Types.BLOB, ""blob"" );
		registerColumnType( Types.CLOB, ""clob"" );
	}",4.222222222222222
"@Test
	public void testSqlTrimFunction() {
		String fragment = ""trim( col )"";
		String template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim("" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( both from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(both from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( leading from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(leading from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( TRAILING from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(TRAILING from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( 'b' from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim('b' from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( both 'b' from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(both 'b' from "" + Template.TEMPLATE + "".col)"", template );
	}",3.2222222222222223
"private void considerExplicitFieldAndPropertyAccess() {
		for ( XProperty property : fieldAccessMap.values() ) {
			Access access = property.getAnnotation( Access.class );
			if ( access == null ) {
				continue;
			}

			// see ""2.3.2 Explicit Access Type"" of JPA 2 spec
			// the access type for this property is explicitly set to AccessType.FIELD, hence we have to
			// use field access for this property even if the default access type for the class is AccessType.PROPERTY
			AccessType accessType = AccessType.getAccessStrategy( access.value() );
            if (accessType == AccessType.FIELD) {
				propertyAccessMap.put(property.getName(), property);
			}
            else {
				LOG.debug( ""Placing @Access(AccessType.FIELD) on a field does not have any effect."" );
			}
		}

		for ( XProperty property : propertyAccessMap.values() ) {
			Access access = property.getAnnotation( Access.class );
			if ( access == null ) {
				continue;
			}

			AccessType accessType = AccessType.getAccessStrategy( access.value() );

			// see ""2.3.2 Explicit Access Type"" of JPA 2 spec
			// the access type for this property is explicitly set to AccessType.PROPERTY, hence we have to
			// return use method access even if the default class access type is AccessType.FIELD
            if (accessType == AccessType.PROPERTY) {
				fieldAccessMap.put(property.getName(), property);
			}
            else {
				LOG.debug( ""Placing @Access(AccessType.PROPERTY) on a field does not have any effect."" );
			}
		}
	}",3.7777777777777777
"private static Ejb3DiscriminatorColumn processDiscriminatorProperties(XClass clazzToProcess, Mappings mappings, InheritanceState inheritanceState, EntityBinder entityBinder) {
		Ejb3DiscriminatorColumn discriminatorColumn = null;
		javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(
				javax.persistence.DiscriminatorColumn.class
		);
		DiscriminatorType discriminatorType = discAnn != null ?
				discAnn.discriminatorType() :
				DiscriminatorType.STRING;

		org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(
				org.hibernate.annotations.DiscriminatorFormula.class
		);
		if ( !inheritanceState.hasParents() ) {
			discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(
					discriminatorType, discAnn, discFormulaAnn, mappings
			);
		}
		if ( discAnn != null && inheritanceState.hasParents() ) {
			LOG.invalidDiscriminatorAnnotation( clazzToProcess.getName() );
		}

		String discrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?
				clazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :
				null;
		entityBinder.setDiscriminatorValue( discrimValue );

		DiscriminatorOptions discriminatorOptions = clazzToProcess.getAnnotation( DiscriminatorOptions.class );
		if ( discriminatorOptions != null) {
			entityBinder.setForceDiscriminator( discriminatorOptions.force() );
			entityBinder.setInsertableDiscriminator( discriminatorOptions.insert() );
		}

		return discriminatorColumn;
	}",2.333333333333333
"private static boolean isEntityClassType(XClass clazzToProcess, AnnotatedClassType classType) {
		if ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities
				|| AnnotatedClassType.NONE.equals( classType ) //to be ignored
				|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration
				) {
			if ( AnnotatedClassType.NONE.equals( classType )
					&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {
				LOG.missingEntityAnnotation( clazzToProcess.getName() );
			}
			return false;
		}

		if ( !classType.equals( AnnotatedClassType.ENTITY ) ) {
			throw new AnnotationException(
					""Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: "" + clazzToProcess
							.getName()
			);
		}

		return true;
	}",3.6666666666666665
"public void redefineColumnName(String columnName, String propertyName, boolean applyNamingStrategy) {
		if ( applyNamingStrategy ) {
			if ( StringHelper.isEmpty( columnName ) ) {
				if ( propertyName != null ) {
					mappingColumn.setName(
							mappings.getObjectNameNormalizer().normalizeIdentifierQuoting(
									mappings.getNamingStrategy().propertyToColumnName( propertyName )
							)
					);
				}
				//Do nothing otherwise
			}
			else {
				columnName = mappings.getObjectNameNormalizer().normalizeIdentifierQuoting( columnName );
				columnName = mappings.getNamingStrategy().columnName( columnName );
				columnName = mappings.getObjectNameNormalizer().normalizeIdentifierQuoting( columnName );
				mappingColumn.setName( columnName );
			}
		}
		else {
			if ( StringHelper.isNotEmpty( columnName ) ) {
				mappingColumn.setName( mappings.getObjectNameNormalizer().normalizeIdentifierQuoting( columnName ) );
			}
		}
	}",3.4444444444444446
"private static void parseFilter(Element filterElement, Filterable filterable, Mappings model) {
		final String name = filterElement.attributeValue( ""name"" );
		String condition = filterElement.getTextTrim();
		if ( StringHelper.isEmpty(condition) ) {
			condition = filterElement.attributeValue( ""condition"" );
		}
		//TODO: bad implementation, cos it depends upon ordering of mapping doc
		//      fixing this requires that Collection/PersistentClass gain access
		//      to the Mappings reference from Configuration (or the filterDefinitions
		//      map directly) sometime during Configuration.build
		//      (after all the types/filter-defs are known and before building
		//      persisters).
		if ( StringHelper.isEmpty(condition) ) {
			condition = model.getFilterDefinition(name).getDefaultFilterCondition();
		}
		if ( condition==null) {
			throw new MappingException(""no filter condition found for filter: "" + name);
		}
		Iterator aliasesIterator = filterElement.elementIterator(""aliases"");
		java.util.Map<String, String> aliasTables = new HashMap<String, String>();
		while (aliasesIterator.hasNext()){
			Element alias = (Element) aliasesIterator.next();
			aliasTables.put(alias.attributeValue(""alias""), alias.attributeValue(""table""));
		}
		LOG.debugf( ""Applying filter [%s] as [%s]"", name, condition );
		String autoAliasInjectionText = filterElement.attributeValue(""autoAliasInjection"");
		boolean autoAliasInjection = StringHelper.isEmpty(autoAliasInjectionText) ? true : Boolean.parseBoolean(autoAliasInjectionText);
		filterable.addFilter(name, condition, autoAliasInjection, aliasTables, null);
	}",3.2222222222222223
"/**
     * Retrieves a PropertyAccessor instance based on the given property definition and
     * entity mode.
     *
     * @param property The property for which to retrieve an accessor.
     * @param mode The mode for the resulting entity.
     * @return An appropriate accessor.
     * @throws MappingException
     */
	public static PropertyAccessor getPropertyAccessor(AttributeBinding property, EntityMode mode) throws MappingException {
		//TODO: this is temporary in that the end result will probably not take a Property reference per-se.
	    if ( null == mode || EntityMode.POJO.equals( mode ) ) {
		    return getPojoPropertyAccessor( property.getPropertyAccessorName() );
	    }
	    else if ( EntityMode.MAP.equals( mode ) ) {
		    return getDynamicMapPropertyAccessor();
	    }
	    else {
		    throw new MappingException( ""Unknown entity mode ["" + mode + ""]"" );
	    }
	}",4.333333333333333
"/**
	 * Execute given <tt>PreparedStatement</tt>, advance to the first result and return SQL <tt>ResultSet</tt>.
	 */
	protected final ResultSet getResultSet(
			final PreparedStatement st,
			final RowSelection selection,
			final LimitHandler limitHandler,
			final boolean autodiscovertypes,
			final SessionImplementor session)
	throws SQLException, HibernateException {

		try {
			ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( st );
			rs = wrapResultSetIfEnabled( rs , session );

			if ( !limitHandler.supportsLimitOffset() || !LimitHelper.useLimit( limitHandler, selection ) ) {
				advance( rs, selection );
			}

			if ( autodiscovertypes ) {
				autoDiscoverTypes( rs );
			}
			return rs;
		}
		catch ( SQLException sqle ) {
			session.getTransactionCoordinator().getJdbcCoordinator().release( st );
			throw sqle;
		}
	}",4.0
"/**
	 * Generate a select list of columns containing all properties of the entity classes
	 */
	protected final String selectString(List associations)
	throws MappingException {

		if ( associations.size()==0 ) {
			return """";
		}
		else {
			StringBuilder buf = new StringBuilder( associations.size() * 100 );
			int entityAliasCount=0;
			int collectionAliasCount=0;
			for ( int i=0; i<associations.size(); i++ ) {
				OuterJoinableAssociation join = (OuterJoinableAssociation) associations.get(i);
				OuterJoinableAssociation next = (i == associations.size() - 1)
				        ? null
				        : ( OuterJoinableAssociation ) associations.get( i + 1 );
				final Joinable joinable = join.getJoinable();
				final String entitySuffix = ( suffixes == null || entityAliasCount >= suffixes.length )
				        ? null
				        : suffixes[entityAliasCount];
				final String collectionSuffix = ( collectionSuffixes == null || collectionAliasCount >= collectionSuffixes.length )
				        ? null
				        : collectionSuffixes[collectionAliasCount];
				final String selectFragment = joinable.selectFragment(
						next == null ? null : next.getJoinable(),
						next == null ? null : next.getRHSAlias(),
						join.getRHSAlias(),
						entitySuffix,
				        collectionSuffix,
						join.getJoinType()==JoinType.LEFT_OUTER_JOIN
				);
				if (selectFragment.trim().length() > 0) {
					buf.append("", "").append(selectFragment);
				}
				if ( joinable.consumesEntityAlias() ) entityAliasCount++;
				if ( joinable.consumesCollectionAlias() && join.getJoinType()==JoinType.LEFT_OUTER_JOIN ) collectionAliasCount++;
			}
			return buf.toString();
		}
	}",2.555555555555556
"@Test
	public void testProperties() throws Exception {
		final Properties props = new Properties();

		props.put(""rpt.1.hibernate.dialect"", ""org.hibernate.dialect.DerbyDialect"");
		props.put(""rpt.2.hibernate.connection.driver_class"", ""org.apache.derby.jdbc.ClientDriver"");
		props.put(""rpt.3.hibernate.connection.url"", ""jdbc:derby://localhost:1527/db/reports.db"");
		props.put(""rpt.4.hibernate.connection.username"", ""sa"");
		props.put(""rpt.5.hibernate.connection.password_enc"", ""76f271db3661fd50082e68d4b953fbee"");
		props.put(""rpt.6.hibernate.connection.password_enc"", ""76f271db3661fd50082e68d4b953fbee"");
		props.put(""hibernate.connection.create"", ""true"");

		final Properties outputProps = ConnectionProviderInitiator.getConnectionProperties( props );
		Assert.assertEquals( 1, outputProps.size() );
		Assert.assertEquals( ""true"", outputProps.get( ""create"" ) );
	}",4.222222222222222
"public boolean equals(Table table) {
		if (null == table) {
			return false;
		}
		if (this == table) {
			return true;
		}

		return isQuoted() ? name.equals(table.getName()) : name.equalsIgnoreCase(table.getName())
			&& ((schema == null && table.getSchema() != null) ? false : (schema == null) ? true : isSchemaQuoted() ? schema.equals(table.getSchema()) : schema.equalsIgnoreCase(table.getSchema()))
			&& ((catalog == null && table.getCatalog() != null) ? false : (catalog == null) ? true : isCatalogQuoted() ? catalog.equals(table.getCatalog()) : catalog.equalsIgnoreCase(table.getCatalog()));
	}",2.2222222222222223
"public int getSqlTypeCode(Mapping mapping) throws MappingException {
        org.hibernate.type.Type type = getValue().getType();
        try {
            int sqlTypeCode = type.sqlTypes( mapping )[getTypeIndex()];
            if ( getSqlTypeCode() != null && getSqlTypeCode() != sqlTypeCode ) {
                throw new MappingException( ""SQLType code's does not match. mapped as "" + sqlTypeCode + "" but is "" + getSqlTypeCode() );
            }
            return sqlTypeCode;
        }
        catch ( Exception e ) {
            throw new MappingException(
                    ""Could not determine type for column "" +
                            name +
                            "" of type "" +
                            type.getClass().getName() +
                            "": "" +
                            e.getClass().getName(),
                    e
            );
        }
    }",3.7777777777777777
"/**
     * Provides serialization support.
     *
     * @param stream  the output stream.
     *
     * @throws IOException  if there is an I/O error.
     */
    private void writeObject(ObjectOutputStream stream) throws IOException {
        stream.defaultWriteObject();

        SerialUtilities.writeShape(this.legendItemShape, stream);
        SerialUtilities.writePaint(this.seriesPaint, stream);
        SerialUtilities.writePaint(this.baseSeriesPaint, stream);
        SerialUtilities.writePaint(this.seriesOutlinePaint, stream);
        SerialUtilities.writePaint(this.baseSeriesOutlinePaint, stream);
        SerialUtilities.writeStroke(this.seriesOutlineStroke, stream);
        SerialUtilities.writeStroke(this.baseSeriesOutlineStroke, stream);
        SerialUtilities.writePaint(this.labelPaint, stream);
        SerialUtilities.writePaint(this.axisLinePaint, stream);
        SerialUtilities.writeStroke(this.axisLineStroke, stream);
    }",4.222222222222222
"/**
     * Tests another object for equality with this object.
     *
     * @param obj  the object to test (<code>null</code> permitted).
     *
     * @return A boolean.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof PinNeedle)) {
            return false;
        }
        if (!super.equals(obj)) {
            return false;
        }
        return true;
    }",4.777777777777778
"/**
     * Tests this dataset for equality with an arbitrary object.
     *
     * @param obj  the object (<code>null</code> permitted).
     *
     * @return A boolean.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof CategoryDataset)) {
            return false;
        }
        CategoryDataset that = (CategoryDataset) obj;
        if (!getRowKeys().equals(that.getRowKeys())) {
            return false;
        }
        if (!getColumnKeys().equals(that.getColumnKeys())) {
            return false;
        }
        int rowCount = getRowCount();
        int colCount = getColumnCount();
        for (int r = 0; r < rowCount; r++) {
            for (int c = 0; c < colCount; c++) {
                Number v1 = getValue(r, c);
                Number v2 = that.getValue(r, c);
                if (v1 == null) {
                    if (v2 != null) {
                        return false;
                    }
                }
                else if (!v1.equals(v2)) {
                    return false;
                }
            }
        }
        return true;
    }",4.222222222222222
"/**
     * Returns the minimum and maximum values for the dataset's range
     * (y-values), assuming that the series in one category are stacked.
     *
     * @param dataset  the dataset (<code>null</code> not permitted).
     * @param base  the base value for the bars.
     *
     * @return The range (<code>null</code> if the dataset contains no values).
     */
    public static Range findStackedRangeBounds(CategoryDataset dataset,
            double base) {
        ParamChecks.nullNotPermitted(dataset, ""dataset"");
        Range result = null;
        double minimum = Double.POSITIVE_INFINITY;
        double maximum = Double.NEGATIVE_INFINITY;
        int categoryCount = dataset.getColumnCount();
        for (int item = 0; item < categoryCount; item++) {
            double positive = base;
            double negative = base;
            int seriesCount = dataset.getRowCount();
            for (int series = 0; series < seriesCount; series++) {
                Number number = dataset.getValue(series, item);
                if (number != null) {
                    double value = number.doubleValue();
                    if (value > 0.0) {
                        positive = positive + value;
                    }
                    if (value < 0.0) {
                        negative = negative + value;
                        // '+', remember value is negative
                    }
                }
            }
            minimum = Math.min(minimum, negative);
            maximum = Math.max(maximum, positive);
        }
        if (minimum <= maximum) {
            result = new Range(minimum, maximum);
        }
        return result;

    }",4.111111111111111
"/**
     * Tests the equality of this object against an arbitrary Object.
     * <P>
     * This method will return true ONLY if the object is a Second object
     * representing the same second as this instance.
     *
     * @param obj  the object to compare (<code>null</code> permitted).
     *
     * @return <code>true</code> if second and minute of this and the object
     *         are the same.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof Second)) {
            return false;
        }
        Second that = (Second) obj;
        if (this.second != that.second) {
            return false;
        }
        if (this.minute != that.minute) {
            return false;
        }
        if (this.hour != that.hour) {
            return false;
        }
        if (!this.day.equals(that.day)) {
            return false;
        }
        return true;
    }",4.666666666666667
"private void handleFireEvent(ArgoEvent event, ArgoEventListener listener) {
        if (event.getEventType() == ArgoEventTypes.ANY_EVENT) {
            if (listener instanceof ArgoModuleEventListener) {
                handleFireModuleEvent((ArgoModuleEvent) event,
				      (ArgoModuleEventListener) listener);
            }
            if (listener instanceof ArgoNotationEventListener) {
                handleFireNotationEvent((ArgoNotationEvent) event,
					(ArgoNotationEventListener) listener);
            }
        } else {
            if (event.getEventType() >= ArgoEventTypes.ANY_MODULE_EVENT
                && event.getEventType() < ArgoEventTypes.LAST_MODULE_EVENT) {
                if (listener instanceof ArgoModuleEventListener) {
                    handleFireModuleEvent((ArgoModuleEvent) event,
					  (ArgoModuleEventListener) listener);
                }
            }
            if (event.getEventType() >= ArgoEventTypes.ANY_NOTATION_EVENT
                && event.getEventType() < ArgoEventTypes.LAST_NOTATION_EVENT) {
                if (listener instanceof ArgoNotationEventListener) {
                    handleFireNotationEvent((ArgoNotationEvent) event,
					(ArgoNotationEventListener) listener);
                }
            }
            if (event.getEventType() >= ArgoEventTypes.ANY_GENERATOR_EVENT
                && event.getEventType() < ArgoEventTypes.LAST_GENERATOR_EVENT) {
                if (listener instanceof ArgoGeneratorEventListener) {
                    handleFireGeneratorEvent((ArgoGeneratorEvent) event,
                            (ArgoGeneratorEventListener) listener);
                }
            }
        }
    }",2.888888888888889
"/**
     * Find an element in the list.
     *
     * This is a little more complex than the simple lookup since it might be
     * that we are indexing with a class and the list contains interfaces.
     *
     * Since the hashtable lookup is a lot faster than the linear search we
     * add the result of the linear search to the hashtable so that the next
     * time we need not do it.
     *
     * @return Checklist or null if noone exist.
     * @param cls the class to lookup.
     */
    private static Checklist lookupChecklist(Class cls) {
        if (lists.contains(cls)) {
            return (Checklist) lists.get(cls);
	}

        // Now lets search
        Enumeration enumeration = lists.keys();

        while (enumeration.hasMoreElements()) {
            Object clazz = enumeration.nextElement();

            Class[] intfs = cls.getInterfaces();
            for (int i = 0; i < intfs.length; i++) {
                if (intfs[i].equals(clazz)) {
                    // We found it!
                    Checklist chlist = (Checklist) lists.get(clazz);

                    // Enter the class to speed up the next search.
                    lists.put(cls, chlist);
                    return chlist;
                }
            }
        }

        return null;
    }",4.0
"/**
     * @return a list of all the types
     */
    public static Vector getTypes() {
        if (types == null) {
            types = new Vector();
            types.addElement(new KnowledgeTypeNode(Critic.KT_DESIGNERS));
            types.addElement(new KnowledgeTypeNode(Critic.KT_CORRECTNESS));
            types.addElement(new KnowledgeTypeNode(Critic.KT_COMPLETENESS));
            types.addElement(new KnowledgeTypeNode(Critic.KT_CONSISTENCY));
            types.addElement(new KnowledgeTypeNode(Critic.KT_SYNTAX));
            types.addElement(new KnowledgeTypeNode(Critic.KT_SEMANTICS));
            types.addElement(new KnowledgeTypeNode(Critic.KT_OPTIMIZATION));
            types.addElement(new KnowledgeTypeNode(Critic.KT_PRESENTATION));
            types.addElement(new KnowledgeTypeNode(Critic.KT_ORGANIZATIONAL));
            types.addElement(new KnowledgeTypeNode(Critic.KT_EXPERIENCIAL));
            types.addElement(new KnowledgeTypeNode(Critic.KT_TOOL));
        }
        return types;
    }",4.333333333333333
"public void toDoItemsRemoved(ToDoListEvent tde) {
	LOG.debug(""toDoItemRemoved"");
        Vector items = tde.getToDoItems();
        int nItems = items.size();
        
	ToDoList list = Designer.theDesigner().getToDoList(); //source?
	Object[] path = new Object[2];
	path[0] = Designer.theDesigner().getToDoList();


	Enumeration elems = list.getPosters().elements();
 	while (elems.hasMoreElements()) {
	    Poster p = (Poster) elems.nextElement();
            boolean anyInPoster = false;
            for (int i = 0; i < nItems; i++) {
                ToDoItem item = (ToDoItem) items.elementAt(i);
                Poster post = item.getPoster();
                if (post == p) { 
                    anyInPoster = true;
                    break;
                }
            }
            if (!anyInPoster) { 
                continue;
            }
	    path[1] = p;
	    fireTreeStructureChanged(path);
	}
    }",3.333333333333333
"public void updateListener(PropertyChangeListener listener, 
            Object modelElement,
            PropertyChangeEvent pce) {
        Object obj = pce.getSource();
        if ((obj == modelElement) 
                && ""stereotype"".equals(pce.getPropertyName())) {
            if (pce instanceof AddAssociationEvent 
                    && Model.getFacade().isAStereotype(pce.getNewValue())) {
                // new stereotype
                addElementListener(
                        listener, 
                        pce.getNewValue(), 
                        new String[] {""name"", ""remove""});
            }
            if (pce instanceof RemoveAssociationEvent 
                    && Model.getFacade().isAStereotype(pce.getOldValue())) {
                // removed stereotype
                removeElementListener(
                        listener, 
                        pce.getOldValue());
            }
        }
    }",3.6666666666666665
"/**
     * @param filename the filename to read from
     */
    public void read(String filename) {
        try {
            FileReader f = new FileReader(filename);
            BufferedReader fr = new BufferedReader(f);

            String line = """";
            String content = """";
            boolean inSection = false;
            while (line != null) {
                line = fr.readLine();
                if (line != null) {
                    if (inSection) {
                        String sectionId = getSectId(line);
                        if (sectionId != null) {
                            inSection = false;
                            mAry.put(sectionId, content);
                            content = """";
                        } else {
                            content += line + LINE_SEPARATOR;
                        }
                    } else {
                        String sectionId = getSectId(line);
                        if (sectionId != null) {
                            inSection = true;
                        }
                    }
                }
            }
            fr.close();
        } catch (IOException e) {
            LOG.error(""Error: "" + e.toString());
        }
    }",4.111111111111111
"private boolean saveGraphicsToFile(File theFile, CmdSaveGraphics cmd,
            boolean overwrite) throws IOException {
        if ( theFile.exists() && !overwrite ) {
            int response =
		JOptionPane.showConfirmDialog(ArgoFrame.getInstance(),
                    Translator.messageFormat(""optionpane.confirm-overwrite"",
                            new Object[] {theFile}),
                    Translator.localize(""optionpane.confirm-overwrite-title""),
                    JOptionPane.YES_NO_OPTION);
            if (response == JOptionPane.NO_OPTION) return false;
        }
        FileOutputStream fo = null;
        try {
            fo = new FileOutputStream( theFile );
            cmd.setStream(fo);
            cmd.setScale(Configuration.getInteger(
                    SaveGraphicsManager.KEY_GRAPHICS_RESOLUTION, 1));
            cmd.doIt();
        } finally {
            if (fo != null) {
                fo.close();
            }
        }
        return true;
    }",2.7777777777777777
"public void targetAdded(TargetEvent e) {
            if (!updatingSelection) {
                updatingSelection = true;
                Object[] targets = e.getAddedTargets();

                int rows = getRowCount();
                for (int i = 0; i < targets.length; i++) {
                    Object target = targets[i];
                    if (target instanceof Fig) {
                        target = ((Fig) target).getOwner();
                    }
                    for (int j = 0; j < rows; j++) {
                        Object rowItem =
                            ((DefaultMutableTreeNode)
                                    getPathForRow(j).getLastPathComponent())
                            .getUserObject();
                        if (rowItem == target) {
                            updatingSelectionViaTreeSelection = true;
                            addSelectionRow(j);
                            updatingSelectionViaTreeSelection = false;
                        }
                    }
                }

                if (getSelectionCount() > 0) {
                    scrollRowToVisible(getSelectionRows()[0]);
                }
                updatingSelection = false;
            }
            // setTargets(e.getNewTargets());
        }",3.111111111111111
"/**
     * Saves the given actions in the configuration file
     * 
     * @param newActions
     *            the actions array
     */
    public static void saveShortcuts(Action[] newActions) {
        for (int i = 0; i < newActions.length; i++) {
            Action oldAction = (Action) shortcutHash
                    .get(newActions[i].getKey());
            if (newActions[i].getCurrentShortcut() == null
                    && newActions[i].getDefaultShortcut() != null) {
                // if a default action was voided then we have to save it
                Configuration.setString(Configuration.makeKey(oldAction
                        .getKey()), """");
            } else if (newActions[i].getCurrentShortcut() != null
                    && !newActions[i].getCurrentShortcut().equals(
                            newActions[i].getDefaultShortcut())) {
                // if a not-default current shortcut was added, then we have to
                // save it
                Configuration.setString(Configuration.makeKey(oldAction
                        .getKey()), KeyEventUtils.formatKeyStroke(newActions[i]
                        .getCurrentShortcut()));
            } else {
                // if the actual is not going to be saved, then try to remove it
                // (as it could have been cancelled)
                Configuration.removeKey(Configuration.makeKey(oldAction
                        .getKey()));
            }
        }
    }",3.4444444444444446
"protected void scanAnnotatedMembers(Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations, Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations) {
        for (Class<?> eachClass : getSuperClasses(fClass)) {
            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {
                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);
            }
            // ensuring fields are sorted to make sure that entries are inserted
            // and read from fieldForAnnotations in a deterministic order
            for (Field eachField : getSortedDeclaredFields(eachClass)) {
                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);
            }
        }
    }",4.0
"/**
     * Verifies that listeners added with addFirstListener() while tests are run concurrently are
     * notified about test failures.
     */
    @Test
    public void reportConcurrentFailuresAfterAddFirstListener() throws Exception {
        new AbstractConcurrentFailuresTest() {
            @Override
            protected void addListener(ExaminedListener listener) {
                fNotifier.addFirstListener(listener);
            }
        }.test();
    }",4.222222222222222
"private static Description makeDescription(Test test) {
        if (test instanceof TestCase) {
            TestCase tc = (TestCase) test;
            return Description.createTestDescription(tc.getClass(), tc.getName(),
                    getAnnotations(tc));
        } else if (test instanceof TestSuite) {
            TestSuite ts = (TestSuite) test;
            String name = ts.getName() == null ? createSuiteDescription(ts) : ts.getName();
            Description description = Description.createSuiteDescription(name);
            int n = ts.testCount();
            for (int i = 0; i < n; i++) {
                Description made = makeDescription(ts.testAt(i));
                description.addChild(made);
            }
            return description;
        } else if (test instanceof Describable) {
            Describable adapter = (Describable) test;
            return adapter.getDescription();
        } else if (test instanceof TestDecorator) {
            TestDecorator decorator = (TestDecorator) test;
            return makeDescription(decorator.getTest());
        } else {
            // This is the best we can do in this case
            return Description.createSuiteDescription(test.getClass());
        }
    }",4.111111111111111
"private EntityManager internalCreateEntityManager(SynchronizationType synchronizationType, Map map) {
		validateNotClosed();

		//TODO support discardOnClose, persistencecontexttype?, interceptor,
		return new EntityManagerImpl(
				this,
				PersistenceContextType.EXTENDED,
				synchronizationType,
				transactionType,
				discardOnClose,
				sessionInterceptorClass,
				map
		);
	}",4.222222222222222
"@Test
	public void testBasicHiLoOptimizerUsage() {
		int increment = 10;
		Long next;

		// test historic sequence behavior, where the initial values start at 1...
		SourceMock sequence = new SourceMock( 1 );
		Optimizer optimizer = buildHiloOptimizer( -1, increment );
		for ( int i = 1; i <= increment; i++ ) {
			next = ( Long ) optimizer.generate( sequence );
			assertEquals( i, next.intValue() );
		}
		assertEquals( 1, sequence.getTimesCalled() ); // once to initialze state
		assertEquals( 1, sequence.getCurrentValue() );
		// force a ""clock over""
		next = ( Long ) optimizer.generate( sequence );
		assertEquals( 11, next.intValue() );
		assertEquals( 2, sequence.getTimesCalled() );
		assertEquals( 2, sequence.getCurrentValue() );

		// test historic table behavior, where the initial values started at 0 (we now force 1 to be the first used id value)
		sequence = new SourceMock( 0 );
		optimizer = buildHiloOptimizer( -1, increment );
		for ( int i = 1; i <= increment; i++ ) {
			next = ( Long ) optimizer.generate( sequence );
			assertEquals( i, next.intValue() );
		}
		assertEquals( 2, sequence.getTimesCalled() ); // here have have an extra call to get to 1 initially
		assertEquals( 1, sequence.getCurrentValue() );
		// force a ""clock over""
		next = ( Long ) optimizer.generate( sequence );
		assertEquals( 11, next.intValue() );
		assertEquals( 3, sequence.getTimesCalled() );
		assertEquals( 2, sequence.getCurrentValue() );
	}",3.333333333333333
"/**
	 * Test default optimizer selection for sequence backed generators
	 * based on the configured increment size; both in the case of the
	 * dialect supporting pooled sequences (pooled) and not (hilo)
	 */
	@Test
	public void testDefaultOptimizerBasedOnIncrementBackedBySequence() {
		Properties props = buildGeneratorPropertiesBase();
		props.setProperty( SequenceStyleGenerator.INCREMENT_PARAM, ""10"" );

		// for dialects which do not support pooled sequences, we default to pooled+table
		Dialect dialect = new SequenceDialect();
		SequenceStyleGenerator generator = new SequenceStyleGenerator();
		generator.configure( StandardBasicTypes.LONG, props, dialect );
		assertClassAssignability( TableStructure.class, generator.getDatabaseStructure().getClass() );
		assertClassAssignability( PooledOptimizer.class, generator.getOptimizer().getClass() );
		assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );

		// for dialects which do support pooled sequences, we default to pooled+sequence
		dialect = new PooledSequenceDialect();
		generator = new SequenceStyleGenerator();
		generator.configure( StandardBasicTypes.LONG, props, dialect );
		assertClassAssignability( SequenceStructure.class, generator.getDatabaseStructure().getClass() );
		assertClassAssignability( PooledOptimizer.class, generator.getOptimizer().getClass() );
		assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );
	}",3.555555555555556
"public static void main(String[] args) {
		CustomVersionOneStrategy strategy = new CustomVersionOneStrategy();

		for ( int i = 0; i < 1000; i++ ) {
			System.out.println( ""Generation # "" + i + "" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );
			byte[] loBits = new byte[8];

			long sysTime = System.currentTimeMillis();
			short hiTime = (short) ( System.currentTimeMillis() >>> 32 );
			int loTime = (int) sysTime;
			System.arraycopy( BytesHelper.fromShort( hiTime ), 0, loBits, 0, 2 );
			System.arraycopy( BytesHelper.fromInt( loTime ), 0, loBits, 2, 4 );
			System.arraycopy( Helper.getCountBytes(), 0, loBits, 6, 2 );

			System.out.println( ""    before bit setting ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );
			System.out.println( ""       loBits[0] : "" + BytesHelper.toBinaryString( loBits[0] ) );
			System.out.println( ""             lsb : "" + BytesHelper.toBinaryString( BytesHelper.asLong( loBits ) ) );
			System.out.println( ""    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );

			loBits[0] &= 0x3f;
			loBits[0] |= ((byte)2 << (byte)6);

			System.out.println( ""    after bit setting ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );
			System.out.println( ""       loBits[0] : "" + BytesHelper.toBinaryString( loBits[0] ) );
			long leastSignificantBits = BytesHelper.asLong( loBits );
			System.out.println( ""             lsb : "" + BytesHelper.toBinaryString( leastSignificantBits ) );
			System.out.println( ""    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );


			UUID uuid = new UUID( strategy.mostSignificantBits, leastSignificantBits );
			System.out.println( ""  uuid : "" + uuid.toString() );
			System.out.println( ""  variant : "" + uuid.variant() );
			System.out.println( ""  version : "" + uuid.version() );
			if ( uuid.variant() != 2 ) {
				throw new RuntimeException( ""bad variant"" );
			}
			System.out.println( ""~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );
		}
	}",3.555555555555556
"public void doTestWithTupleSubsetResultTransformerNullAliases(TupleSubsetResultTransformer transformer) throws Exception {
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { true, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { true, true, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { false, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { true, false } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { false, true, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {true, false, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {true, true, false } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {false, false, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {false, true, false } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {false, false, true } ) ) );
	}",3.7777777777777777
"public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;

        Person person = (Person) o;

        if (id != person.id) return false;
        if (name != null ? !name.equals(person.name) : person.name != null) return false;
        if (surname != null ? !surname.equals(person.surname) : person.surname != null) return false;

        return true;
    }",3.888888888888889
"private void readAndSetAddress(Scanner scanner, Person p) {
        Address old = p.getAddress();

        String input = scanner.nextLine();
        if (""NULL"".equals(input)) {
            p.setAddress(null);
            if (old != null) {
                old.getPersons().remove(p);
            }
        } else if ("""".equals(input)) {
        } else {
            try {
                Integer id = Integer.valueOf(input);

                Address a = entityManager.find(Address.class, id);

                if (a == null) {
                    System.err.println(""Unknown address id, setting to NULL."");
                    p.setAddress(null);
                    if (old != null) {
                        old.getPersons().remove(p);
                    }
                } else {
                    p.setAddress(a);

                    a.getPersons().add(p);

                    if (old != null) {
                        old.getPersons().remove(p);
                    }
                }
            } catch (NumberFormatException e) {
                System.err.println(""Invalid address id, setting to NULL."");
                p.setAddress(null);
                if (old != null) {
                    old.getPersons().remove(p);
                }
            }
        }
    }",3.888888888888889
"/**
	 * add statistics report of a DB query
	 *
	 * @param rows rows count returned
	 * @param time time taken
	 */
	void executed(long rows, long time) {
		// read lock is enough, concurrent updates are supported by the underlying type AtomicLong
		// this only guards executed(long, long) to be called, when another thread is executing getExecutionAvgTime()
		readLock.lock();
		try {
			// Less chances for a context switch
			for (long old = executionMinTime.get(); (time < old) && !executionMinTime.compareAndSet(old, time); old = executionMinTime.get());
			for (long old = executionMaxTime.get(); (time > old) && !executionMaxTime.compareAndSet(old, time); old = executionMaxTime.get());
			executionCount.getAndIncrement();
			executionRowCount.addAndGet(rows);
			totalExecutionTime.addAndGet(time);
		} finally {
			readLock.unlock();
		}
	}",3.333333333333333
"public String toString() {
		return new StringBuilder()
				.append(""QueryStatistics"")
				.append(""[cacheHitCount="").append(this.cacheHitCount)
				.append("",cacheMissCount="").append(this.cacheMissCount)
				.append("",cachePutCount="").append(this.cachePutCount)
				.append("",executionCount="").append(this.executionCount)
				.append("",executionRowCount="").append(this.executionRowCount)
				.append("",executionAvgTime="").append(this.getExecutionAvgTime())
				.append("",executionMaxTime="").append(this.executionMaxTime)
				.append("",executionMinTime="").append(this.executionMinTime)
				.append(']')
				.toString();
	}",4.0
"public String toString() {
		StringBuilder buf = new StringBuilder()
				.append(""SecondLevelCacheStatistics"")
				.append(""[hitCount="").append(this.hitCount)
				.append("",missCount="").append(this.missCount)
				.append("",putCount="").append(this.putCount);
		//not sure if this would ever be null but wanted to be careful
		if (region != null) {
			buf.append("",elementCountInMemory="").append(this.getElementCountInMemory())
					.append("",elementCountOnDisk="").append(this.getElementCountOnDisk())
					.append("",sizeInMemory="").append(this.getSizeInMemory());
		}
		buf.append(']');
		return buf.toString();
	}",3.888888888888889
"Object processEntity(Object value, EntityType entityType) throws HibernateException {

		if (value!=null) {
			getSession().getPersistenceContext().reassociateIfUninitializedProxy(value);
			// if it is an initialized proxy, let cascade
			// handle it later on
		}

		return null;
	}",4.555555555555555
"/**
	 * 1. Recreate the collection key -> collection map
	 * 2. rebuild the collection entries
	 * 3. call Interceptor.postFlush()
	 */
	protected void postFlush(SessionImplementor session) throws HibernateException {

		LOG.trace( ""Post flush"" );

		final PersistenceContext persistenceContext = session.getPersistenceContext();
		persistenceContext.getCollectionsByKey().clear();
		
		// the database has changed now, so the subselect results need to be invalidated
		// the batch fetching queues should also be cleared - especially the collection batch fetching one
		persistenceContext.getBatchFetchQueue().clear();

		for ( Map.Entry<PersistentCollection, CollectionEntry> me : IdentityMap.concurrentEntries( persistenceContext.getCollectionEntries() ) ) {
			CollectionEntry collectionEntry = me.getValue();
			PersistentCollection persistentCollection = me.getKey();
			collectionEntry.postFlush(persistentCollection);
			if ( collectionEntry.getLoadedPersister() == null ) {
				//if the collection is dereferenced, remove from the session cache
				//iter.remove(); //does not work, since the entrySet is not backed by the set
				persistenceContext.getCollectionEntries()
						.remove(persistentCollection);
			}
			else {
				//otherwise recreate the mapping between the collection and its key
				CollectionKey collectionKey = new CollectionKey(
						collectionEntry.getLoadedPersister(),
						collectionEntry.getLoadedKey()
				);
				persistenceContext.getCollectionsByKey().put(collectionKey, persistentCollection);
			}
		}

	}",3.4444444444444446
"/**
		 * Build a ParameterMemento from the given parameter registration
		 *
		 * @param registration The parameter registration from a ProcedureCall
		 *
		 * @return The memento
		 */
		public static ParameterMemento fromRegistration(ParameterRegistrationImplementor registration) {
			return new ParameterMemento(
					registration.getPosition(),
					registration.getName(),
					registration.getMode(),
					registration.getType(),
					registration.getHibernateType()
			);
		}",4.666666666666667
"@Test
	public void testQueryCollectionOfValues() throws Exception {
		Session s = openSession();
		s.beginTransaction();
		Baz baz = new Baz();
		baz.setDefaults();
		s.save(baz);
		Glarch g = new Glarch();
		Serializable gid = s.save(g);

		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) /*&& !(dialect instanceof MckoiDialect)*/ && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof PointbaseDialect) && !(getDialect() instanceof TimesTenDialect) ) {
			s.createFilter( baz.getFooArray(), ""where size(this.bytes) > 0"" ).list();
			s.createFilter( baz.getFooArray(), ""where 0 in elements(this.bytes)"" ).list();
		}
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.beginTransaction();
		s.createQuery( ""from Baz baz join baz.fooSet foo join foo.foo.foo foo2 where foo2.string = 'foo'"" ).list();
		s.createQuery( ""from Baz baz join baz.fooArray foo join foo.foo.foo foo2 where foo2.string = 'foo'"" ).list();
		s.createQuery( ""from Baz baz join baz.stringDateMap date where index(date) = 'foo'"" ).list();
		s.createQuery( ""from Baz baz join baz.topGlarchez g where index(g) = 'A'"" ).list();
		s.createQuery( ""select index(g) from Baz baz join baz.topGlarchez g"" ).list();

		assertTrue( s.createQuery( ""from Baz baz left join baz.stringSet"" ).list().size()==3 );
		baz = (Baz) s.createQuery( ""from Baz baz join baz.stringSet str where str='foo'"" ).list().get(0);
		assertTrue( !Hibernate.isInitialized( baz.getStringSet() ) );
		baz = (Baz) s.createQuery( ""from Baz baz left join fetch baz.stringSet"" ).list().get(0);
		assertTrue( Hibernate.isInitialized( baz.getStringSet() ) );
		assertTrue( s.createQuery( ""from Baz baz join baz.stringSet string where string='foo'"" ).list().size()==1 );
		assertTrue( s.createQuery( ""from Baz baz inner join baz.components comp where comp.name='foo'"" ).list().size()==1 );
		//List bss = s.find(""select baz, ss from Baz baz inner join baz.stringSet ss"");
		s.createQuery( ""from Glarch g inner join g.fooComponents comp where comp.fee is not null"" ).list();
		s.createQuery( ""from Glarch g inner join g.fooComponents comp join comp.fee fee where fee.count > 0"" ).list();
		s.createQuery( ""from Glarch g inner join g.fooComponents comp where comp.fee.count is not null"" ).list();

		s.delete(baz);
		s.delete( s.get(Glarch.class, gid) );
		s.getTransaction().commit();
		s.close();
	}",2.888888888888889
"@SkipForDialect(value = AbstractHANADialect.class, comment = ""HANA currently requires specifying table name by 'FOR UPDATE of t1.c1' if there are more than one tables/views/subqueries in the FROM clause"")
	@Test
	public void testRefresh() throws Exception {
		final Session s = openSession();
		s.beginTransaction();
		Foo foo = new Foo();
		s.save( foo );
		s.flush();
		s.doWork(
				new AbstractWork() {
					@Override
					public void execute(Connection connection) throws SQLException {
						final String sql = ""update "" + getDialect().openQuote() + ""foos"" + getDialect().closeQuote() + "" set long_ = -3"";
						Statement st = connection.createStatement();
						st.executeUpdate( sql );
					}
				}
		);
		s.refresh(foo);
		assertEquals( Long.valueOf( -3l ), foo.getLong() );
		assertEquals( LockMode.READ, s.getCurrentLockMode( foo ) );
		s.refresh(foo, LockMode.UPGRADE);
		if ( getDialect().supportsOuterJoinForUpdate() ) {
			assertEquals( LockMode.UPGRADE, s.getCurrentLockMode( foo ) );
		}
		s.delete(foo);
		s.getTransaction().commit();
		s.close();
	}",3.0
"public boolean equals(Object o) {
		if (this == o) return true;
		if (!(o instanceof OuterKey)) return false;

		final OuterKey cidDetailID = (OuterKey) o;

		if (detailId != null ? !detailId.equals(cidDetailID.detailId) : cidDetailID.detailId != null) return false;
		if (master != null ? !master.equals(cidDetailID.master) : cidDetailID.master != null) return false;

		return true;
	}",3.2222222222222223
"@Test
	@SkipForDialect( { HSQLDialect.class, PostgreSQL81Dialect.class, PostgreSQLDialect.class } )
	public void testEscapedJDBC() throws HibernateException, SQLException {
		Session session = openSession();
		session.beginTransaction();
		for ( Object entity : session.createQuery( ""from A"" ).list() ) {
			session.delete( entity );
		}
		A savedA = new A();
		savedA.setName(""Max"");
		session.save(savedA);

		B savedB = new B();
		session.save(savedB);
		session.flush();

		int count = session.createQuery(""from A"").list().size();
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();

		Query query;
		if( getDialect() instanceof TimesTenDialect) {
            // TimesTen does not permit general expressions (like UPPER) in the second part of a LIKE expression,
            // so we execute a similar test 
            query = session.createSQLQuery(""select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA where {fn ucase(name)} like 'MAX'"" )
					.addEntity( ""a"", A.class );
        }
		else {
            query = session.createSQLQuery( ""select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA where {fn ucase(name)} like {fn ucase('max')}"" )
					.addEntity( ""a"", A.class );
        }
		List list = query.list();

		assertNotNull(list);
		assertEquals(1, list.size());
		session.getTransaction().commit();
		session.close();
	}",3.555555555555556
"@Test
	@TestForIssue( jiraKey = ""HHH-21"" )
    public void testCompositeIdId() throws HibernateException, SQLException {
        Session s = openSession();
		s.beginTransaction();
        CompositeIdId id = new CompositeIdId();
        id.setName(""Max"");
        id.setSystem(""c64"");
        id.setId(""games"");
        s.save(id);
		s.getTransaction().commit();
        s.close();

        s = openSession();
		s.beginTransaction();
        // having a composite id with one property named id works since the map used by sqlloader to map names to properties handles it.
		String sql = ""select system as {c.system}, id as {c.id}, name as {c.name}, foo as {c.composite.foo}, bar as {c.composite.bar} from CompositeIdId where system=? and id=?"";
		SQLQuery query = s.createSQLQuery( sql ).addEntity( ""c"", CompositeIdId.class );
        query.setString(0, ""c64"");
        query.setString(1, ""games"");

        CompositeIdId id2 = (CompositeIdId) query.uniqueResult();
        check(id, id2);

		s.getTransaction().commit();
        s.close();

        s = openSession();
		s.beginTransaction();
        CompositeIdId useForGet = new CompositeIdId();
        useForGet.setSystem(""c64"");
        useForGet.setId(""games"");
        // this doesn't work since the verification does not take column span into respect!
        CompositeIdId getted = (CompositeIdId) s.get(CompositeIdId.class, useForGet);
        check(id,getted);
		s.getTransaction().commit();
        s.close();
    }",3.2222222222222223
"@Override
    public void runTest(final Test test, final TestResult result) {
        Thread t = new Thread() {
            @Override
            public void run() {
                try {
                    // inlined due to limitation in VA/Java
                    //ActiveTestSuite.super.runTest(test, result);
                    test.run(result);
                } finally {
                    ActiveTestSuite.this.runFinished();
                }
            }
        };
        t.start();
    }
",4.555555555555555
"public boolean equalsFoo(Foo other) {
		if ( _bytes!=other._bytes ) {
			if ( _bytes==null || other._bytes==null ) return false;
			if ( _bytes.length!=other._bytes.length ) return false;
			for ( int i=0; i< _bytes.length; i++) {
				if ( _bytes[i] != other._bytes[i] ) return false;
			}
		}

		return ( this._bool == other._bool )
		&& ( ( this._boolean == other._boolean ) || ( this._boolean.equals(other._boolean) ) )
		&& ( ( this._byte == other._byte ) || ( this._byte.equals(other._byte) ) )
		//&& ( ( this._date == other._date ) || ( this._date.getDate() == other._date.getDate() && this._date.getMonth() == other._date.getMonth() && this._date.getYear() == other._date.getYear() ) )
		&& ( ( this._double == other._double ) || ( this._double.equals(other._double) ) )
		&& ( ( this._float == other._float ) || ( this._float.equals(other._float) ) )
		&& ( this._int == other._int )
		&& ( ( this._integer == other._integer ) || ( this._integer.equals(other._integer) ) )
		&& ( ( this._long == other._long ) || ( this._long.equals(other._long) ) )
		&& ( this._null == other._null )
		&& ( ( this._short == other._short ) || ( this._short.equals(other._short) ) )
		&& ( ( this._string == other._string) || ( this._string.equals(other._string) ) )
		//&& ( ( this._timestamp==other._timestamp) || ( this._timestamp.getDate() == other._timestamp.getDate() && this._timestamp.getYear() == other._timestamp.getYear() && this._timestamp.getMonth() == other._timestamp.getMonth() ) )
		&& ( this._zero == other._zero )
		&& ( ( this._foo == other._foo ) || ( this._foo.getKey().equals( other._foo.getKey() ) ) )
		&& ( ( this.blob == other.blob ) || ( this.blob.equals(other.blob) ) )
		&& ( this.yesno == other.yesno )
		&& ( ( this.binary == other.binary ) || java.util.Arrays.equals(this.binary, other.binary) )
		&& ( this.key.equals(other.key) )
		&& ( this.theLocale.equals(other.theLocale) )
		&& ( ( this.custom == other.custom ) || ( this.custom[0].equals(other.custom[0]) && this.custom[1].equals(other.custom[1]) ) );

	}",1.8888888888888888
"@Test
	public void testSerializationFailsOnAfterStatementAggressiveReleaseWithOpenResources() throws Throwable {
		prepare();
		Session s = getSessionUnderTest();

		Silly silly = new Silly( ""silly"" );
		s.save( silly );

		// this should cause the CM to obtain a connection, and then release it
		s.flush();

		// both scroll() and iterate() cause batching to hold on
		// to resources, which should make aggressive-release not release
		// the connection (and thus cause serialization to fail)
		ScrollableResults sr = s.createQuery( ""from Silly"" ).scroll();

		try {
			SerializationHelper.serialize( s );
			fail( ""Serialization allowed on connected session; or aggressive release released connection with open resources"" );
		}
		catch( IllegalStateException e ) {
			// expected behavior
		}

		// getting the first row only because SybaseASE15Dialect throws NullPointerException
		// if data is not read before closing the ResultSet
		sr.next();

		// Closing the ScrollableResults does currently force batching to
		// aggressively release the connection
		sr.close();
		SerializationHelper.serialize( s );

		s.delete( silly );
		s.flush();

		release( s );
		done();
	}",3.888888888888889
"@Override
	protected void prepareTest() throws Exception {
	    Session s = openSession();
	    Transaction t = s.beginTransaction();
	    Child child_1_1 = new Child( ""achild1-1"");
	    Child child_1_2 = new Child( ""ychild1-2"");
	    Child child_1_3 = new Child( ""dchild1-3"");
	    Child child_2_1 = new Child( ""bchild2-1"");
	    Child child_2_2 = new Child( ""cchild2-2"");
	    Child child_2_3 = new Child( ""zchild2-3"");
	
	    s.save( child_1_1 );
	    s.save( child_2_1 );
	    s.save( child_1_2 );
	    s.save( child_2_2 );
	    s.save( child_1_3 );
	    s.save( child_2_3 );
	
	    s.flush();
	
	    Parent p1 = new Parent( ""parent1"" );
	    p1.addChild( child_1_1 );
	    p1.addChild( child_1_2 );
	    p1.addChild( child_1_3 );
	    s.save( p1 );
	
	    Parent p2 = new Parent( ""parent2"" );
	    p2.addChild( child_2_1 );
	    p2.addChild( child_2_2 );
	    p2.addChild( child_2_3 );
	    s.save( p2 );
	
	    t.commit();
	    s.close();
	}",4.444444444444445
"@Test
	@TestForIssue( jiraKey = ""HHH-2045"" )
	@RequiresDialect( H2Dialect.class )
	public void testEmptyInList() {
		Session session = openSession();
		session.beginTransaction();
		Human human = new Human();
		human.setName( new Name( ""Lukasz"", null, ""Antoniak"" ) );
		human.setNickName( ""NONE"" );
		session.save( human );
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();
		List results = session.createQuery( ""from Human h where h.nickName in ()"" ).list();
		assertEquals( 0, results.size() );
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();
		session.delete( human );
		session.getTransaction().commit();
		session.close();
	}",4.444444444444445
"@Test
	@TestForIssue( jiraKey = ""HHH-2257"" )
	public void testImplicitJoinsInDifferentClauses() {
		// both the classic and ast translators output the same syntactically valid sql
		// for all of these cases; the issue is that shallow (iterate) and
		// non-shallow (list/scroll) queries return different results because the
		// shallow skips the inner join which ""weeds out"" results from the non-shallow queries.
		// The results were initially different depending upon the clause(s) in which the
		// implicit join occurred
		Session s = openSession();
		s.beginTransaction();
		SimpleEntityWithAssociation owner = new SimpleEntityWithAssociation( ""owner"" );
		SimpleAssociatedEntity e1 = new SimpleAssociatedEntity( ""thing one"", owner );
		SimpleAssociatedEntity e2 = new SimpleAssociatedEntity( ""thing two"" );
		s.save( e1 );
		s.save( e2 );
		s.save( owner );
		s.getTransaction().commit();
		s.close();

		checkCounts( ""select e.owner from SimpleAssociatedEntity e"", 1, ""implicit-join in select clause"" );
		checkCounts( ""select e.id, e.owner from SimpleAssociatedEntity e"", 1, ""implicit-join in select clause"" );

		// resolved to a ""id short cut"" when part of the order by clause -> no inner join = no weeding out...
		checkCounts( ""from SimpleAssociatedEntity e order by e.owner"", 2, ""implicit-join in order-by clause"" );
		// resolved to a ""id short cut"" when part of the group by clause -> no inner join = no weeding out...
		checkCounts( ""select e.owner.id, count(*) from SimpleAssociatedEntity e group by e.owner"", 2, ""implicit-join in select and group-by clauses"" );

	 	s = openSession();
		s.beginTransaction();
		s.delete( e1 );
		s.delete( e2 );
		s.delete( owner );
		s.getTransaction().commit();
		s.close();
	}",3.7777777777777777
"@Test
	@TestForIssue( jiraKey = ""HHH-1631"" )
	public void testSubclassOrSuperclassPropertyReferenceInJoinedSubclass() {
		// this is a long standing bug in Hibernate; see HHH-1631 for details and history
		//
		// (1) pregnant is defined as a property of the class (Mammal) itself
		// (2) description is defined as a property of the superclass (Animal)
		// (3) name is defined as a property of a particular subclass (Human)

		new SyntaxChecker( ""from Zoo z join z.mammals as m where m.name.first = 'John'"" ).checkIterate();

		new SyntaxChecker( ""from Zoo z join z.mammals as m where m.pregnant = false"" ).checkAll();
		new SyntaxChecker( ""select m.pregnant from Zoo z join z.mammals as m where m.pregnant = false"" ).checkAll();

		new SyntaxChecker( ""from Zoo z join z.mammals as m where m.description = 'tabby'"" ).checkAll();
		new SyntaxChecker( ""select m.description from Zoo z join z.mammals as m where m.description = 'tabby'"" ).checkAll();

		new SyntaxChecker( ""from Zoo z join z.mammals as m where m.name.first = 'John'"" ).checkAll();
		new SyntaxChecker( ""select m.name from Zoo z join z.mammals as m where m.name.first = 'John'"" ).checkAll();

		new SyntaxChecker( ""select m.pregnant from Zoo z join z.mammals as m"" ).checkAll();
		new SyntaxChecker( ""select m.description from Zoo z join z.mammals as m"" ).checkAll();
		new SyntaxChecker( ""select m.name from Zoo z join z.mammals as m"" ).checkAll();

		new SyntaxChecker( ""from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'"" ).checkAll();
		new SyntaxChecker( ""select da.father from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'"" ).checkAll();
		new SyntaxChecker( ""select da.father from DomesticAnimal da where da.owner.nickName = 'Gavin'"" ).checkAll();
	}",4.333333333333333
"@SuppressWarnings( {""unchecked""})
	@Test
	public void testAnyMappingReference() {
		Session s = openSession();
		s.beginTransaction();

		PropertyValue redValue = new StringPropertyValue( ""red"" );
		PropertyValue loneliestNumberValue = new IntegerPropertyValue( 1 );

		Long id;
		PropertySet ps = new PropertySet( ""my properties"" );
		ps.setSomeSpecificProperty( redValue );
		ps.getGeneralProperties().put( ""the loneliest number"", loneliestNumberValue );
		ps.getGeneralProperties().put( ""i like"", new StringPropertyValue( ""pina coladas"" ) );
		ps.getGeneralProperties().put( ""i also like"", new StringPropertyValue( ""getting caught in the rain"" ) );
		s.save( ps );

		s.getTransaction().commit();
		id = ps.getId();
		s.clear();
		s.beginTransaction();

		// TODO : setEntity() currently will not work here, but that would be *very* nice
		// does not work because the corresponding EntityType is then used as the ""bind type"" rather
		// than the ""discovered"" AnyType...
		s.createQuery( ""from PropertySet p where p.someSpecificProperty = :ssp"" ).setParameter( ""ssp"", redValue ).list();

		s.createQuery( ""from PropertySet p where p.someSpecificProperty.id is not null"" ).list();

		s.createQuery( ""from PropertySet p join p.generalProperties gp where gp.id is not null"" ).list();

		s.delete( s.load( PropertySet.class, id ) );

		s.getTransaction().commit();
		s.close();
	}",3.6666666666666665
"@Test
	public void testFetchInSubqueryFails() {
		Session s = openSession();
		try {
			s.createQuery( ""from Animal a where a.mother in (select m from Animal a1 inner join a1.mother as m join fetch m.mother)"" ).list();
			fail( ""fetch join allowed in subquery"" );
		}
		catch( QueryException expected ) {
			// expected behavior
		}
		s.close();
	}",4.333333333333333
"@Test
	@TestForIssue( jiraKey = ""HHH-429"" )
	@SuppressWarnings( {""unchecked""})
	public void testSuperclassPropertyReferenceAfterCollectionIndexedAccess() {
		// note: simply performing syntax checking in the db
		Session s = openSession();
		s.beginTransaction();
		Mammal tiger = new Mammal();
		tiger.setDescription( ""Tiger"" );
		s.persist( tiger );
		Mammal mother = new Mammal();
		mother.setDescription( ""Tiger's mother"" );
		mother.setBodyWeight( 4.0f );
		mother.addOffspring( tiger );
		s.persist( mother );
		Zoo zoo = new Zoo();
		zoo.setName( ""Austin Zoo"" );
		zoo.setMammals( new HashMap() );
		zoo.getMammals().put( ""tiger"", tiger );
		s.persist( zoo );
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.beginTransaction();
		List results = s.createQuery( ""from Zoo zoo where zoo.mammals['tiger'].mother.bodyWeight > 3.0f"" ).list();
		assertEquals( 1, results.size() );
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.beginTransaction();
		s.delete( tiger );
		s.delete( mother );
		s.delete( zoo );
		s.getTransaction().commit();
		s.close();
	}",3.7777777777777777
"@Test
	@SuppressWarnings( {""UnusedAssignment"", ""UnusedDeclaration""})
	public void testSelectExpressions() {
		createTestBaseData();
		Session session = openSession();
		Transaction txn = session.beginTransaction();
		Human h = new Human();
		h.setName( new Name( ""Gavin"", 'A', ""King"" ) );
		h.setNickName(""Oney"");
		h.setBodyWeight( 1.0f );
		session.persist( h );
		List results = session.createQuery(""select 'found', lower(h.name.first) from Human h where lower(h.name.first) = 'gavin'"").list();
		results = session.createQuery(""select 'found', lower(h.name.first) from Human h where concat(h.name.first, ' ', h.name.initial, ' ', h.name.last) = 'Gavin A King'"").list();
		results = session.createQuery(""select 'found', lower(h.name.first) from Human h where h.name.first||' '||h.name.initial||' '||h.name.last = 'Gavin A King'"").list();
		results = session.createQuery(""select a.bodyWeight + m.bodyWeight from Animal a join a.mother m"").list();
		results = session.createQuery(""select 2.0 * (a.bodyWeight + m.bodyWeight) from Animal a join a.mother m"").list();
		results = session.createQuery(""select sum(a.bodyWeight + m.bodyWeight) from Animal a join a.mother m"").list();
		results = session.createQuery(""select sum(a.mother.bodyWeight * 2.0) from Animal a"").list();
		results = session.createQuery(""select concat(h.name.first, ' ', h.name.initial, ' ', h.name.last) from Human h"").list();
		results = session.createQuery(""select h.name.first||' '||h.name.initial||' '||h.name.last from Human h"").list();
		results = session.createQuery(""select nickName from Human"").list();
		results = session.createQuery(""select lower(nickName) from Human"").list();
		results = session.createQuery(""select abs(bodyWeight*-1) from Human"").list();
		results = session.createQuery(""select upper(h.name.first||' ('||h.nickName||')') from Human h"").list();
		results = session.createQuery(""select abs(a.bodyWeight-:param) from Animal a"").setParameter(""param"", new Float(2.0)).list();
		results = session.createQuery(""select abs(:param - a.bodyWeight) from Animal a"").setParameter(""param"", new Float(2.0)).list();
		results = session.createQuery(""select lower(upper('foo')) from Animal"").list();
		results = session.createQuery(""select lower(upper('foo') || upper('bar')) from Animal"").list();
		results = session.createQuery(""select sum(abs(bodyWeight - 1.0) * abs(length('ffobar')-3)) from Animal"").list();
		session.delete(h);
		txn.commit();
		session.close();
		destroyTestBaseData();
	}",3.4444444444444446
"/**
	 * Build a normal attribute.
	 *
	 * @param ownerType The descriptor of the attribute owner (aka declarer).
	 * @param property The Hibernate property descriptor for the attribute
	 * @param <X> The type of the owner
	 * @param <Y> The attribute type
	 *
	 * @return The built attribute descriptor or null if the attribute is not part of the JPA 2 model (eg backrefs)
	 */
	@SuppressWarnings({""unchecked""})
	public <X, Y> AttributeImplementor<X, Y> buildAttribute(AbstractManagedType<X> ownerType, Property property) {
		if ( property.isSynthetic() ) {
			// hide synthetic/virtual properties (fabricated by Hibernate) from the JPA metamodel.
			LOG.tracef( ""Skipping synthetic property %s(%s)"", ownerType.getTypeName(), property.getName() );
			return null;
		}
		LOG.trace( ""Building attribute ["" + ownerType.getTypeName() + ""."" + property.getName() + ""]"" );
		final AttributeContext<X> attributeContext = wrap( ownerType, property );
		final AttributeMetadata<X, Y> attributeMetadata =
				determineAttributeMetadata( attributeContext, normalMemberResolver );
		if ( attributeMetadata == null ) {
			return null;
		}
		if ( attributeMetadata.isPlural() ) {
			return buildPluralAttribute( (PluralAttributeMetadata) attributeMetadata );
		}
		final SingularAttributeMetadata<X, Y> singularAttributeMetadata = (SingularAttributeMetadata<X, Y>) attributeMetadata;
		final Type<Y> metaModelType = getMetaModelType( singularAttributeMetadata.getValueContext() );
		return new SingularAttributeImpl<X, Y>(
				attributeMetadata.getName(),
				attributeMetadata.getJavaType(),
				ownerType,
				attributeMetadata.getMember(),
				false,
				false,
				property.isOptional(),
				metaModelType,
				attributeMetadata.getPersistentAttributeType()
		);
	}
",2.888888888888889
"@Test public void testOtherSyntax() throws Exception {
		parse( ""select bar from org.hibernate.test.Bar bar order by ((bar.x - :valueX)*(bar.x - :valueX))"" );
		parse( ""from bar in class org.hibernate.test.Bar, foo in elements(bar.baz.fooSet)"" );
		parse( ""from one in class org.hibernate.test.One, many in elements(one.manies) where one.id = 1 and many.id = 1"" );
		parse( ""from org.hibernate.test.Inner _inner join _inner.middles middle"" );
		parse( ""FROM m IN CLASS org.hibernate.test.Master WHERE NOT EXISTS ( FROM d IN elements(m.details) WHERE NOT d.i=5 )"" );
		parse( ""FROM m IN CLASS org.hibernate.test.Master WHERE NOT 5 IN ( SELECT d.i FROM d IN elements(m.details) )"" );
		parse( ""SELECT m FROM m IN CLASS org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5"" );
		parse( ""SELECT m FROM m IN CLASS org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5"" );
		parse( ""SELECT m.id FROM m IN CLASS org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5"" );
		// I'm not sure about these... [jsd]
//        parse(""select bar.string, foo.string from bar in class org.hibernate.test.Bar inner join bar.baz as baz inner join elements(baz.fooSet) as foo where baz.name = 'name'"");
//        parse(""select bar.string, foo.string from bar in class org.hibernate.test.Bar, bar.baz as baz, elements(baz.fooSet) as foo where baz.name = 'name'"");
//        parse(""select count(*) where this.amount>-1 and this.name is null"");
//        parse(""from sm in class org.hibernate.test.SubMulti where exists sm.children.elements"");
	}",3.888888888888889
"@Test public void testPathologicalKeywordAsIdentifier() throws Exception {
		// Super evil badness... a legitimate keyword!
		parse( ""from Order order"" );
		//parse( ""from Order order join order.group"" );
		parse( ""from X x order by x.group.by.from"" );
		parse( ""from Order x order by x.order.group.by.from"" );
		parse( ""select order.id from Order order"" );
		parse( ""select order from Order order"" );
		parse( ""from Order order where order.group.by.from is not null"" );
		parse( ""from Order order order by order.group.by.from"" );
		// Okay, now this is getting silly.
		parse( ""from Group as group group by group.by.from"" );
	}",4.0
"@Test public void testHHH1780() throws Exception {
        // verifies the tree contains a NOT->EXISTS subtree
        class Verifier {
            public boolean verify(AST root) {
                Stack<AST> queue = new Stack<AST>();
                queue.push( root );
                while ( !queue.isEmpty() ) {
                    AST parent = queue.pop();
                    AST child = parent.getFirstChild();
                    while ( child != null ) {
                        if ( parent.getType() == HqlTokenTypes.NOT &&
                                child.getType() == HqlTokenTypes.EXISTS ) {
                            return true;
                        }
                        queue.push( child );
                        child = child.getNextSibling();
                    }
                }
                return false;
            }
        }

        // test inversion of AND
        AST ast = doParse(
                ""from Person p where not ( p.name is null and exists(select a.id from Address a where a.id=p.id))"",
                false
        );

        assertTrue( new Verifier().verify( ast ) );

        // test inversion of OR
        ast = doParse(
                ""from Person p where not ( p.name is null or exists(select a.id from Address a where a.id=p.id))"",
                false
        );

        assertTrue( new Verifier().verify( ast ) );
    }",3.2222222222222223
"@Test
	public void testDateTimeArithmeticReturnTypesAndParameterGuessing() {
		QueryTranslatorImpl translator = createNewQueryTranslator( ""select o.orderDate - o.orderDate from Order o"" );
		assertEquals( ""incorrect return type count"", 1, translator.getReturnTypes().length );
		assertEquals( ""incorrect return type"", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
		translator = createNewQueryTranslator( ""select o.orderDate + 2 from Order o"" );
		assertEquals( ""incorrect return type count"", 1, translator.getReturnTypes().length );
		assertEquals( ""incorrect return type"", CalendarDateType.INSTANCE, translator.getReturnTypes()[0] );
		translator = createNewQueryTranslator( ""select o.orderDate -2 from Order o"" );
		assertEquals( ""incorrect return type count"", 1, translator.getReturnTypes().length );
		assertEquals( ""incorrect return type"", CalendarDateType.INSTANCE, translator.getReturnTypes()[0] );

		translator = createNewQueryTranslator( ""from Order o where o.orderDate > ?"" );
		assertEquals( ""incorrect expected param type"", CalendarDateType.INSTANCE, translator.getParameterTranslations().getOrdinalParameterExpectedType( 1 ) );

		translator = createNewQueryTranslator( ""select o.orderDate + ? from Order o"" );
		assertEquals( ""incorrect return type count"", 1, translator.getReturnTypes().length );
		assertEquals( ""incorrect return type"", CalendarDateType.INSTANCE, translator.getReturnTypes()[0] );
		assertEquals( ""incorrect expected param type"", DoubleType.INSTANCE, translator.getParameterTranslations().getOrdinalParameterExpectedType( 1 ) );

	}",3.6666666666666665
"@Test
	public void testExpressionWithParamInFunction() {
		assertTranslation(""from Animal a where abs(a.bodyWeight-:param) < 2.0"");
		assertTranslation(""from Animal a where abs(:param - a.bodyWeight) < 2.0"");
		assertTranslation(""from Animal where abs(:x - :y) < 2.0"");
		assertTranslation(""from Animal where lower(upper(:foo)) like 'f%'"");
		if ( ! ( getDialect() instanceof SybaseDialect ) &&  ! ( getDialect() instanceof Sybase11Dialect ) &&  ! ( getDialect() instanceof SybaseASE15Dialect ) && ! ( getDialect() instanceof SQLServerDialect ) ) {
			// Transact-SQL dialects (except SybaseAnywhereDialect) map the length function -> len; 
			// classic translator does not consider that *when nested*;
			// SybaseAnywhereDialect supports the length function

			assertTranslation(""from Animal a where abs(abs(a.bodyWeight - 1.0 + :param) * abs(length('ffobar')-3)) = 3.0"");
		}
		if ( !( getDialect() instanceof MySQLDialect ) && ! ( getDialect() instanceof SybaseDialect ) && ! ( getDialect() instanceof Sybase11Dialect ) && !( getDialect() instanceof SybaseASE15Dialect ) && ! ( getDialect() instanceof SybaseAnywhereDialect ) && ! ( getDialect() instanceof SQLServerDialect ) ) {
			assertTranslation(""from Animal where lower(upper('foo') || upper(:bar)) like 'f%'"");
		}
		if ( getDialect() instanceof PostgreSQLDialect || getDialect() instanceof PostgreSQL81Dialect ) {
			return;
		}
		if ( getDialect() instanceof AbstractHANADialect ) {
			// HANA returns
			// ...al0_7_.mammal where [abs(cast(1 as float(19))-cast(? as float(19)))=1.0]
			return;
		}
		assertTranslation(""from Animal where abs(cast(1 as float) - cast(:param as float)) = 1.0"");
	}",2.888888888888889
"@Test
    public void testHHH6635() throws Exception {
        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
        Set<ObjectName> set = mBeanServer.queryNames( null, null );
        boolean mbeanfound = false;
        for ( ObjectName obj : set ) {
            if ( obj.getKeyPropertyListString().indexOf( ""PooledDataSource"" ) > 0 ) {
                mbeanfound = true;

                // see according c3p0 settings in META-INF/persistence.xml

                int actual_minPoolSize = (Integer) mBeanServer.getAttribute( obj, ""minPoolSize"" );
                assertEquals( 50, actual_minPoolSize );

                int actual_initialPoolSize = (Integer) mBeanServer.getAttribute( obj, ""initialPoolSize"" );
                assertEquals( 50, actual_initialPoolSize );

                int actual_maxPoolSize = (Integer) mBeanServer.getAttribute( obj, ""maxPoolSize"" );
                assertEquals( 800, actual_maxPoolSize );

                int actual_maxStatements = (Integer) mBeanServer.getAttribute( obj, ""maxStatements"" );
                assertEquals( 50, actual_maxStatements );

                int actual_maxIdleTime = (Integer) mBeanServer.getAttribute( obj, ""maxIdleTime"" );
                assertEquals( 300, actual_maxIdleTime );

                int actual_idleConnectionTestPeriod = (Integer) mBeanServer.getAttribute(
                        obj,
                        ""idleConnectionTestPeriod""
                );
                assertEquals( 3000, actual_idleConnectionTestPeriod );
                break;
            }
        }

        assertTrue( ""PooledDataSource BMean not found, please verify version of c3p0"", mbeanfound );
    }",3.6666666666666665
"@Test
	public void testFilterApplicationOnHqlQueryWithImplicitSubqueryContainingPositionalParameter() {
		TestData testData = new TestData();
		testData.prepare();

		Session session = openSession();
		session.beginTransaction();

		final String queryString = ""from Order o where ? in ( select sp.name from Salesperson sp )"";

		// first a control-group query
		List result = session.createQuery( queryString ).setParameter( 0, ""steve"" ).list();
		assertEquals( 2, result.size() );

		// now lets enable filters on Order...
		session.enableFilter( ""fulfilledOrders"" ).setParameter( ""asOfDate"", testData.lastMonth.getTime() );
		result = session.createQuery( queryString ).setParameter( 0, ""steve"" ).list();
		assertEquals( 1, result.size() );

		// now, lets additionally enable filter on Salesperson.  First a valid one...
		session.enableFilter( ""regionlist"" ).setParameterList( ""regions"", new String[] { ""APAC"" } );
		result = session.createQuery( queryString ).setParameter( 0, ""steve"" ).list();
		assertEquals( 1, result.size() );

		// ... then a silly one...
		session.enableFilter( ""regionlist"" ).setParameterList( ""regions"", new String[] { ""gamma quadrant"" } );
		result = session.createQuery( queryString ).setParameter( 0, ""steve"" ).list();
		assertEquals( 0, result.size() );

		session.getTransaction().commit();
		session.close();

		testData.release();
	}",4.222222222222222
"@SuppressWarnings( {""unchecked""})
	@Test
	public void testDistinctSelectWithJoin() {
		feedDatabase();

		Session s = openSession();

		List<Entry> entries = s.createQuery(""select distinct e from Entry e join e.tags t where t.surrogate != null order by e.name"").setFirstResult(10).setMaxResults(5).list();

		// System.out.println(entries);
		Entry firstEntry = entries.remove(0);
		assertFalse(""The list of entries should not contain dublicated Entry objects as we've done a distinct select"", entries.contains(firstEntry));

		s.close();
	}",4.555555555555555
"@Test
	@SkipForDialect(
			value = { MySQLMyISAMDialect.class, AbstractHANADialect.class },
			comment = ""MySQL (MyISAM) / Hana do not support FK violation checking""
	)
	public void testIntegrityViolation() throws Exception {
		final Session session = openSession();
		session.beginTransaction();

		session.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						// Attempt to insert some bad values into the T_MEMBERSHIP table that should
						// result in a constraint violation
						PreparedStatement ps = null;
						try {
							ps = ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( ""INSERT INTO T_MEMBERSHIP (user_id, group_id) VALUES (?, ?)"" );
							ps.setLong(1, 52134241);    // Non-existent user_id
							ps.setLong(2, 5342);        // Non-existent group_id
							((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().executeUpdate( ps );

							fail(""INSERT should have failed"");
						}
						catch (ConstraintViolationException ignore) {
							// expected outcome
						}
						finally {
							releaseStatement( session, ps );
						}
					}
				}
		);

		session.getTransaction().rollback();
		session.close();
	}",3.6666666666666665
"@Test
	public void testBadGrammar() throws Exception {
		final Session session = openSession();
		session.beginTransaction();

		session.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						// prepare/execute a query against a non-existent table
						PreparedStatement ps = null;
						try {
							ps = ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( ""SELECT user_id, user_name FROM tbl_no_there"" );
							((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );

							fail(""SQL compilation should have failed"");
						}
						catch (SQLGrammarException ignored) {
							// expected outcome
						}
						finally {
							releaseStatement( session, ps );
						}
					}
				}
		);

		session.getTransaction().rollback();
		session.close();
	}",3.2222222222222223
"private void releaseStatement(Session session, PreparedStatement ps) {
		if ( ps != null ) {
			try {
				( (SessionImplementor) session ).getTransactionCoordinator().getJdbcCoordinator().release( ps );
			}
			catch ( Throwable ignore ) {
				// ignore...
			}
		}
	}",3.888888888888889
"@Test
	public void testEntityWithLazyAssnList() throws Exception {
		CriteriaExecutor criteriaExecutor = new CriteriaExecutor() {
			protected Criteria getCriteria(Session s) {
				// should use RootEntityTransformer by default
				return s.createCriteria( Student.class )
						.addOrder( Order.asc( ""studentNumber"" ) );
			}
		};
		HqlExecutor hqlExecutor = new HqlExecutor() {
			public Query getQuery(Session s) {
				return s.createQuery( ""from Student order by studentNumber"" );
			}
		};
		ResultChecker checker = new ResultChecker() {
			public void check(Object results) {
				List resultList = ( List ) results;
				assertEquals( 2, resultList.size() );
				assertEquals( yogiExpected, resultList.get( 0 ) );
				assertEquals( shermanExpected, resultList.get( 1 ) );
				assertNotNull( ((Student) resultList.get( 0 )).getEnrolments() );
				assertNotNull( ( ( Student ) resultList.get( 0 ) ).getPreferredCourse() );
				assertNotNull( ( ( Student ) resultList.get( 1 ) ).getEnrolments() );
				assertNull( ( ( Student ) resultList.get( 1 ) ).getPreferredCourse() );
				assertFalse( Hibernate.isInitialized( ( ( Student ) resultList.get( 0 ) ).getEnrolments() ) );
				assertFalse( Hibernate.isInitialized( ( ( Student ) resultList.get( 0 ) ).getPreferredCourse() ) );
				assertFalse( Hibernate.isInitialized( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
				assertNull( ( ( Student ) resultList.get( 1 ) ).getPreferredCourse() );
			}
		};
		runTest( hqlExecutor, criteriaExecutor, checker, false );
	}",3.111111111111111
"@Test
	public void testJoinWithFetchJoinListCriteria() throws Exception {
		CriteriaExecutor criteriaExecutor = new CriteriaExecutor() {
			protected Criteria getCriteria(Session s) {
				return s.createCriteria( Student.class, ""s"" )
						.createAlias( ""s.preferredCourse"", ""pc"", Criteria.LEFT_JOIN  )
						.setFetchMode( ""enrolments"", FetchMode.JOIN )
						.addOrder( Order.asc( ""s.studentNumber"") );
			}
		};
		ResultChecker checker = new ResultChecker() {
			public void check(Object results) {
				List resultList = ( List ) results;
				assertEquals( 2, resultList.size() );
				assertEquals( yogiExpected, resultList.get( 0 ) );
				// The following fails for criteria due to HHH-3524
				//assertEquals( yogiExpected.getPreferredCourse(), ( ( Student ) resultList.get( 0 ) ).getPreferredCourse() );
				assertEquals( yogiExpected.getPreferredCourse().getCourseCode(),
						( ( Student ) resultList.get( 0 ) ).getPreferredCourse().getCourseCode() );
				assertEquals( shermanExpected, resultList.get( 1 ) );
				assertNull( ( ( Student ) resultList.get( 1 ) ).getPreferredCourse() );
				if ( areDynamicNonLazyAssociationsChecked() ) {
					assertTrue( Hibernate.isInitialized( ( ( Student ) resultList.get( 0 ) ).getEnrolments() ) );
					assertEquals( yogiExpected.getEnrolments(), ( ( Student ) resultList.get( 0 ) ).getEnrolments() );
					assertTrue( Hibernate.isInitialized( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
					assertEquals( shermanExpected.getEnrolments(), ( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
				}
			}
		};
		runTest( null, criteriaExecutor, checker, false );
	}",2.7777777777777777
"@Test
	public void testEntityWithAliasedJoinFetchedLazyOneToManySingleElementListHql() throws Exception {
		HqlExecutor hqlExecutor = new HqlExecutor() {
			public Query getQuery(Session s) {
				return s.createQuery( ""from Student s left join fetch s.enrolments e order by s.studentNumber"" );
			}
		};

		ResultChecker checker = new ResultChecker() {
			public void check(Object results) {
				List resultList = ( List ) results;
				assertEquals( 2, resultList.size() );
				assertEquals( yogiExpected, resultList.get( 0 ) );
				assertEquals(
						yogiExpected.getPreferredCourse().getCourseCode(),
						( ( Student ) resultList.get( 0 ) ).getPreferredCourse().getCourseCode()
				);
				assertEquals( shermanExpected, resultList.get( 1 ) );
				assertNull( ( ( Student ) resultList.get( 1 ) ).getPreferredCourse() );
				if ( areDynamicNonLazyAssociationsChecked() ) {
					assertTrue( Hibernate.isInitialized( ( ( Student ) resultList.get( 0 ) ).getEnrolments() ) );
					assertEquals( yogiExpected.getEnrolments(), ( ( Student ) resultList.get( 0 ) ).getEnrolments() );
					assertTrue( Hibernate.isInitialized( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
					assertEquals( shermanExpected.getEnrolments(), ( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
				}
			}
		};

		runTest( hqlExecutor, null, checker, false);
	}",3.0
"@Test
	public void testMultiSelectNewMapUsingAliasesWithFetchJoinList() throws Exception {
		CriteriaExecutor criteriaExecutor = new CriteriaExecutor() {
			protected Criteria getCriteria(Session s) {
				return s.createCriteria( Student.class, ""s"" )
						.createAlias( ""s.preferredCourse"", ""pc"", Criteria.LEFT_JOIN  )
						.setFetchMode( ""enrolments"", FetchMode.JOIN )
						.addOrder( Order.asc( ""s.studentNumber"" ))
						.setResultTransformer( Transformers.ALIAS_TO_ENTITY_MAP );
			}
		};
		HqlExecutor hqlSelectNewMapExecutor = new HqlExecutor() {
			public Query getQuery(Session s) {
				return s.createQuery( ""select new map(s as s, pc as pc) from Student s left join s.preferredCourse pc left join fetch s.enrolments order by s.studentNumber"" );
			}
		};
		ResultChecker checker = new ResultChecker() {
			public void check(Object results) {
				List resultList = ( List ) results;
				assertEquals( 2, resultList.size() );
				Map yogiMap = ( Map ) resultList.get( 0 );
				assertEquals( yogiExpected, yogiMap.get( ""s"" ) );
				assertEquals( yogiExpected.getPreferredCourse(), yogiMap.get( ""pc"" ) );
				Map shermanMap = ( Map ) resultList.get( 1 );
				assertEquals( shermanExpected, shermanMap.get( ""s"" ) );
				assertNull( shermanMap.get( ""pc"" ) );
				if ( areDynamicNonLazyAssociationsChecked() ) {
					assertTrue( Hibernate.isInitialized( ( ( Student ) yogiMap.get( ""s"" ) ).getEnrolments() ) );
					assertEquals( yogiExpected.getEnrolments(), ( ( Student ) yogiMap.get( ""s"" ) ).getEnrolments() );
					assertTrue( Hibernate.isInitialized( ( ( Student ) shermanMap.get( ""s"" ) ).getEnrolments() ) );
					assertEquals( shermanExpected.getEnrolments(), ( ( ( Student ) shermanMap.get( ""s"" ) ).getEnrolments() ) );
				}
			}
		};
		runTest( hqlSelectNewMapExecutor, criteriaExecutor, checker, false );
	}",3.2222222222222223
"public void afterSessionFactoryBuilt() {
		super.afterSessionFactoryBuilt();
		final Session session = sessionFactory().openSession();
		session.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						Statement st = ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().createStatement();
						try {
							((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().execute( st, ""drop table Point"");
						}
						catch (Exception ignored) {
						}
						((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().execute( st, ""create table Point (\""x\"" number(19,2) not null, \""y\"" number(19,2) not null, description varchar2(255) )"");
						((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().release( st );
					}
				}
		);
		session.close();
	}",3.6666666666666665
"@Test
	public void testNoLoss() {
		assertNoLoss( ""insert into Address (city, state, zip, \""from\"") values (?, ?, ?, 'insert value')"" );
		assertNoLoss( ""delete from Address where id = ? and version = ?"" );
		assertNoLoss( ""update Address set city = ?, state=?, zip=?, version = ? where id = ? and version = ?"" );
		assertNoLoss( ""update Address set city = ?, state=?, zip=?, version = ? where id in (select aid from Person)"" );
		assertNoLoss(
				""select p.name, a.zipCode, count(*) from Person p left outer join Employee e on e.id = p.id and p.type = 'E' and (e.effective>? or e.effective<?) join Address a on a.pid = p.id where upper(p.name) like 'G%' and p.age > 100 and (p.sex = 'M' or p.sex = 'F') and coalesce( trim(a.street), a.city, (a.zip) ) is not null order by p.name asc, a.zipCode asc""
		);
		assertNoLoss(
				""select ( (m.age - p.age) * 12 ), trim(upper(p.name)) from Person p, Person m where p.mother = m.id and ( p.age = (select max(p0.age) from Person p0 where (p0.mother=m.id)) and p.name like ? )""
		);
		assertNoLoss(
				""select * from Address a join Person p on a.pid = p.id, Person m join Address b on b.pid = m.id where p.mother = m.id and p.name like ?""
		);
		assertNoLoss(
				""select case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end from Person p where ( case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end ) like ?""
		);
		assertNoLoss(
				""/* Here we' go! */ select case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end from Person p where ( case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end ) like ?""
		);
	}",3.333333333333333
"/**
	 * Throws {@link org.hibernate.PropertyValueException} if there are any unresolved
	 * entity insert actions that depend on non-nullable associations with
	 * a transient entity. This method should be called on completion of
	 * an operation (after all cascades are completed) that saves an entity.
	 *
	 * @throws org.hibernate.PropertyValueException if there are any unresolved entity
	 * insert actions; {@link org.hibernate.PropertyValueException#getEntityName()}
	 * and {@link org.hibernate.PropertyValueException#getPropertyName()} will
	 * return the entity name and property value for the first unresolved
	 * entity insert action.
	 */
	public void checkNoUnresolvedActionsAfterOperation() throws PropertyValueException {
		if ( isEmpty() ) {
			LOG.trace( ""No entity insert actions have non-nullable, transient entity dependencies."" );
		}
		else {
			final AbstractEntityInsertAction firstDependentAction =
					dependenciesByAction.keySet().iterator().next();

			logCannotResolveNonNullableTransientDependencies( firstDependentAction.getSession() );

			final NonNullableTransientDependencies nonNullableTransientDependencies =
					dependenciesByAction.get( firstDependentAction );
			final Object firstTransientDependency =
					nonNullableTransientDependencies.getNonNullableTransientEntities().iterator().next();
			final String firstPropertyPath =
					nonNullableTransientDependencies.getNonNullableTransientPropertyPaths( firstTransientDependency ).iterator().next();

			throw new TransientPropertyValueException(
					""Not-null property references a transient value - transient instance must be saved before current operation"",
					firstDependentAction.getSession().guessEntityName( firstTransientDependency ),
					firstDependentAction.getEntityName(),
					firstPropertyPath
			);
		}
	}",3.333333333333333
"/**
	 * Handle sending notifications needed for natural-id after saving
	 *
	 * @param generatedId The generated entity identifier
	 */
	public void handleNaturalIdPostSaveNotifications(Serializable generatedId) {
		if ( isEarlyInsert() ) {
			// with early insert, we still need to add a local (transactional) natural id cross-reference
			getSession().getPersistenceContext().getNaturalIdHelper().manageLocalNaturalIdCrossReference(
					getPersister(),
					generatedId,
					state,
					null,
					CachedNaturalIdValueSource.INSERT
			);
		}
		// after save, we need to manage the shared cache entries
		getSession().getPersistenceContext().getNaturalIdHelper().manageSharedNaturalIdCrossReference(
				getPersister(),
				getId(),
				state,
				null,
				CachedNaturalIdValueSource.INSERT
		);
	}",3.888888888888889
"private boolean initializeLazyProperty(
			final String fieldName,
			final Object entity,
			final SessionImplementor session,
			final Object[] snapshot,
			final int j,
			final Object propValue) {
		setPropertyValue( entity, lazyPropertyNumbers[j], propValue );
		if ( snapshot != null ) {
			// object have been loaded with setReadOnly(true); HHH-2236
			snapshot[ lazyPropertyNumbers[j] ] = lazyPropertyTypes[j].deepCopy( propValue, factory );
		}
		return fieldName.equals( lazyPropertyNames[j] );
	}",3.888888888888889
"private void initOrdinaryPropertyPaths(Mapping mapping) throws MappingException {
		for ( int i = 0; i < getSubclassPropertyNameClosure().length; i++ ) {
			propertyMapping.initPropertyPaths( getSubclassPropertyNameClosure()[i],
					getSubclassPropertyTypeClosure()[i],
					getSubclassPropertyColumnNameClosure()[i],
					getSubclassPropertyColumnReaderClosure()[i],
					getSubclassPropertyColumnReaderTemplateClosure()[i],
					getSubclassPropertyFormulaTemplateClosure()[i],
					mapping );
		}
	}",3.888888888888889
"/**
	 * Delete an object
	 */
	public void delete(Serializable id, Object version, Object object, SessionImplementor session)
			throws HibernateException {
		final int span = getTableSpan();
		boolean isImpliedOptimisticLocking = !entityMetamodel.isVersioned() && isAllOrDirtyOptLocking();
		Object[] loadedState = null;
		if ( isImpliedOptimisticLocking ) {
			// need to treat this as if it where optimistic-lock=""all"" (dirty does *not* make sense);
			// first we need to locate the ""loaded"" state
			//
			// Note, it potentially could be a proxy, so doAfterTransactionCompletion the location the safe way...
			final EntityKey key = session.generateEntityKey( id, this );
			Object entity = session.getPersistenceContext().getEntity( key );
			if ( entity != null ) {
				EntityEntry entry = session.getPersistenceContext().getEntry( entity );
				loadedState = entry.getLoadedState();
			}
		}

		final String[] deleteStrings;
		if ( isImpliedOptimisticLocking && loadedState != null ) {
			// we need to utilize dynamic delete statements
			deleteStrings = generateSQLDeletStrings( loadedState );
		}
		else {
			// otherwise, utilize the static delete statements
			deleteStrings = getSQLDeleteStrings();
		}

		for ( int j = span - 1; j >= 0; j-- ) {
			delete( id, version, j, object, deleteStrings[j], session, loadedState );
		}

	}",3.555555555555556
"private UniqueEntityLoader getAppropriateLoader(LockOptions lockOptions, SessionImplementor session) {
		if ( queryLoader != null ) {
			// if the user specified a custom query loader we need to that
			// regardless of any other consideration
			return queryLoader;
		}
		else if ( isAffectedByEnabledFilters( session ) ) {
			// because filters affect the rows returned (because they add
			// restrictions) these need to be next in precedence
			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
		}
		else if ( session.getLoadQueryInfluencers().getInternalFetchProfile() != null && LockMode.UPGRADE.greaterThan( lockOptions.getLockMode() ) ) {
			// Next, we consider whether an 'internal' fetch profile has been set.
			// This indicates a special fetch profile Hibernate needs applied
			// (for its merge loading process e.g.).
			return ( UniqueEntityLoader ) getLoaders().get( session.getLoadQueryInfluencers().getInternalFetchProfile() );
		}
		else if ( isAffectedByEnabledFetchProfiles( session ) ) {
			// If the session has associated influencers we need to adjust the
			// SQL query used for loading based on those influencers
			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
		}
		else if ( isAffectedByEntityGraph( session ) ) {
			return createEntityLoader( lockOptions, session.getLoadQueryInfluencers() );
		}
		else if ( lockOptions.getTimeOut() != LockOptions.WAIT_FOREVER ) {
			return createEntityLoader( lockOptions, session.getLoadQueryInfluencers() );
		}
		else {
			return ( UniqueEntityLoader ) getLoaders().get( lockOptions.getLockMode() );
		}
	}",3.888888888888889
"public String[] toColumns(String alias, String propertyName) throws QueryException {
		if ( propertyName.equals(CollectionPropertyNames.COLLECTION_ELEMENTS) ) {
			return memberPersister.getElementColumnNames(alias);
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_INDICES) ) {
			if ( !memberPersister.hasIndex() ) throw new QueryException(""unindexed collection in indices()"");
			return memberPersister.getIndexColumnNames(alias);
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_SIZE) ) {
			String[] cols = memberPersister.getKeyColumnNames();
			return new String[] { ""count("" + alias + '.' + cols[0] + ')' };
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_MAX_INDEX) ) {
			if ( !memberPersister.hasIndex() ) throw new QueryException(""unindexed collection in maxIndex()"");
			String[] cols = memberPersister.getIndexColumnNames(alias);
			if ( cols.length!=1 ) throw new QueryException(""composite collection index in maxIndex()"");
			return new String[] { ""max("" + cols[0] + ')' };
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_MIN_INDEX) ) {
			if ( !memberPersister.hasIndex() ) throw new QueryException(""unindexed collection in minIndex()"");
			String[] cols = memberPersister.getIndexColumnNames(alias);
			if ( cols.length!=1 ) throw new QueryException(""composite collection index in minIndex()"");
			return new String[] { ""min("" + cols[0] + ')' };
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_MAX_ELEMENT) ) {
			String[] cols = memberPersister.getElementColumnNames(alias);
			if ( cols.length!=1 ) throw new QueryException(""composite collection element in maxElement()"");
			return new String[] { ""max("" + cols[0] + ')' };
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_MIN_ELEMENT) ) {
			String[] cols = memberPersister.getElementColumnNames(alias);
			if ( cols.length!=1 ) throw new QueryException(""composite collection element in minElement()"");
			return new String[] { ""min("" + cols[0] + ')' };
		}
		else {
			//return memberPersister.toColumns(alias, propertyName);
			throw new QueryException(""illegal syntax near collection: "" + propertyName);
		}
	}",3.333333333333333
"private void bindIndex(final Mappings mappings) {
		if ( !indexColumn.isImplicit() ) {
			PropertyHolder valueHolder = PropertyHolderBuilder.buildPropertyHolder(
					this.collection,
					StringHelper.qualify( this.collection.getRole(), ""key"" ),
					null,
					null, propertyHolder, mappings
			);
			List list = (List) this.collection;
			if ( !list.isOneToMany() ) indexColumn.forceNotNull();
			indexColumn.setPropertyHolder( valueHolder );
			SimpleValueBinder value = new SimpleValueBinder();
			value.setColumns( new Ejb3Column[] { indexColumn } );
			value.setExplicitType( ""integer"" );
			value.setMappings( mappings );
			SimpleValue indexValue = value.make();
			indexColumn.linkWithValue( indexValue );
			list.setIndex( indexValue );
			list.setBaseIndex( indexColumn.getBase() );
			if ( list.isOneToMany() && !list.getKey().isNullable() && !list.isInverse() ) {
				String entityName = ( (OneToMany) list.getElement() ).getReferencedEntityName();
				PersistentClass referenced = mappings.getClass( entityName );
				IndexBackref ib = new IndexBackref();
				ib.setName( '_' + propertyName + ""IndexBackref"" );
				ib.setUpdateable( false );
				ib.setSelectable( false );
				ib.setCollectionRole( list.getRole() );
				ib.setEntityName( list.getOwner().getEntityName() );
				ib.setValue( list.getIndex() );
				referenced.addProperty( ib );
			}
		}
		else {
			Collection coll = this.collection;
			throw new AnnotationException(
					""List/array has to be annotated with an @OrderColumn (or @IndexColumn): ""
							+ coll.getRole()
			);
		}
	}",3.0
"/**
	 * Perform {@link org.hibernate.action.spi.Executable#execute()} on each element of the list
	 * 
	 * @param list The list of Executable elements to be performed
	 *
	 * @throws HibernateException
	 */
	private <E extends Executable & Comparable<?> & Serializable> void executeActions(ExecutableList<E> list) throws HibernateException {
		// todo : consider ways to improve the double iteration of Executables here:
		//		1) we explicitly iterate list here to perform Executable#execute()
		//		2) ExecutableList#getQuerySpaces also iterates the Executables to collect query spaces.
		try {
			for ( E e : list ) {
				try {
					e.execute();
				}
				finally {
					beforeTransactionProcesses.register( e.getBeforeTransactionCompletionProcess() );
					afterTransactionProcesses.register( e.getAfterTransactionCompletionProcess() );
				}
			}
		}
		finally {
			if ( session.getFactory().getSettings().isQueryCacheEnabled() ) {
				// Strictly speaking, only a subset of the list may have been processed if a RuntimeException occurs.
				// We still invalidate all spaces. I don't see this as a big deal - after all, RuntimeExceptions are
				// unexpected.
				Set<Serializable> propertySpaces = list.getQuerySpaces();
				invalidateSpaces( propertySpaces.toArray( new Serializable[propertySpaces.size()] ) );
			}
		}

		list.clear();
		session.getTransactionCoordinator().getJdbcCoordinator().executeBatch();
	}",3.555555555555556
"@SuppressWarnings( {""SimplifiableIfStatement""})
	private boolean isUnequivocallyNonDirty(Object entity) {

		if(entity instanceof SelfDirtinessTracker)
			return ((SelfDirtinessTracker) entity).$$_hibernate_hasDirtyAttributes();

		final CustomEntityDirtinessStrategy customEntityDirtinessStrategy =
				persistenceContext.getSession().getFactory().getCustomEntityDirtinessStrategy();
		if ( customEntityDirtinessStrategy.canDirtyCheck( entity, getPersister(), (Session) persistenceContext.getSession() ) ) {
			return ! customEntityDirtinessStrategy.isDirty( entity, getPersister(), (Session) persistenceContext.getSession() );
		}

		if ( getPersister().hasMutableProperties() ) {
			return false;
		}

		if ( getPersister().getInstrumentationMetadata().isInstrumented() ) {
			// the entity must be instrumented (otherwise we cant check dirty flag) and the dirty flag is false
			return ! getPersister().getInstrumentationMetadata().extractInterceptor( entity ).isDirty();
		}

		return false;
	}",3.0
"public static String expandBatchIdPlaceholder(
			String sql,
			Serializable[] ids,
			String alias,
			String[] keyColumnNames,
			Dialect dialect) {
		if ( keyColumnNames.length == 1 ) {
			// non-composite
			return StringHelper.replace( sql, BATCH_ID_PLACEHOLDER, repeat( ""?"", ids.length, "","" ) );
		}
		else {
			// composite
			if ( dialect.supportsRowValueConstructorSyntaxInInList() ) {
				final String tuple = ""("" + StringHelper.repeat( ""?"", keyColumnNames.length, "","" );
				return StringHelper.replace( sql, BATCH_ID_PLACEHOLDER, repeat( tuple, ids.length, "","" ) );
			}
			else {
				final String keyCheck = joinWithQualifier( keyColumnNames, alias, "" and "" );
				return replace( sql, BATCH_ID_PLACEHOLDER, repeat( keyCheck, ids.length, "" or "" ) );
			}
		}
	}",3.888888888888889
"/**
	 * Interpret a long as its binary form
	 *
	 * @param longValue The long to interpret to binary
	 *
	 * @return The binary
	 */
	public static byte[] fromLong(long longValue) {
		byte[] bytes = new byte[8];
		bytes[0] = (byte) ( longValue >> 56 );
		bytes[1] = (byte) ( ( longValue << 8 ) >> 56 );
		bytes[2] = (byte) ( ( longValue << 16 ) >> 56 );
		bytes[3] = (byte) ( ( longValue << 24 ) >> 56 );
		bytes[4] = (byte) ( ( longValue << 32 ) >> 56 );
		bytes[5] = (byte) ( ( longValue << 40 ) >> 56 );
		bytes[6] = (byte) ( ( longValue << 48 ) >> 56 );
		bytes[7] = (byte) ( ( longValue << 56 ) >> 56 );
		return bytes;
	}",4.111111111111111
"/**
     * Tests this instance for equality with an arbitrary object.
     *
     * @param obj  the object (<code>null</code> permitted).
     *
     * @return A boolean.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof OHLC)) {
            return false;
        }
        OHLC that = (OHLC) obj;
        if (this.open != that.open) {
            return false;
        }
        if (this.close != that.close) {
            return false;
        }
        if (this.high != that.high) {
            return false;
        }
        if (this.low != that.low) {
            return false;
        }
        return true;
    }",4.666666666666667
"public final void caseSList() throws RecognitionException, TokenStreamException {
		
		
		{
		_loop119:
		do {
			if ((_tokenSet_6.member(LA(1)))) {
				statement();
			}
			else {
				break _loop119;
			}
			
		} while (true);
		}
	}",3.333333333333333
"public void write(BufferedReader reader,
                      BufferedWriter writer,
                      Stack parseStateStack) throws IOException {
        ParseState parseState = (ParseState) parseStateStack.peek();
        Object mInterface = /*(MInterface)*/ parseState.newClassifier(name);

	if (mInterface != null) {
	    parseStateStack.push(new ParseState(mInterface));
	    StringBuffer sbText =
		GeneratorJava.getInstance().generateClassifierStart(mInterface);
	    if (sbText != null) {
		writer.write (sbText.toString());
	    }
            // dispose code piece in reader
            ffCodePiece(reader, null);
        } else {
            // not in model, so write the original code
            ffCodePiece(reader, writer);
        }
    }",3.555555555555556
"protected final void mHEX_DIGIT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype; Token _token=null; int _begin=text.length();
		_ttype = HEX_DIGIT;
		int _saveIndex;
		
		{
		switch ( LA(1)) {
		case '0':  case '1':  case '2':  case '3':
		case '4':  case '5':  case '6':  case '7':
		case '8':  case '9':
		{
			matchRange('0','9');
			break;
		}
		case 'A':  case 'B':  case 'C':  case 'D':
		case 'E':  case 'F':
		{
			matchRange('A','F');
			break;
		}
		case 'a':  case 'b':  case 'c':  case 'd':
		case 'e':  case 'f':
		{
			matchRange('a','f');
			break;
		}
		default:
		{
			throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
		}
		}
		}
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}",3.555555555555556
"/**
     * The constructor.
     */
    public TabChecklist() {
	super(""tab.checklist"");

	tableModel = new TableModelChecklist(this);
	table.setModel(tableModel);

	Font labelFont = LookAndFeelMgr.getInstance().getStandardFont();
	table.setFont(labelFont);

	table.setIntercellSpacing(new Dimension(0, 1));
	table.setShowVerticalLines(false);
	table.getSelectionModel().addListSelectionListener(this);
	table.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);

	TableColumn checkCol = table.getColumnModel().getColumn(0);
	TableColumn descCol = table.getColumnModel().getColumn(1);
	checkCol.setMinWidth(20);
	checkCol.setMaxWidth(30);
	checkCol.setWidth(30);
	descCol.setPreferredWidth(900);
	table.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
	table.sizeColumnsToFit(-1);

	JScrollPane sp = new JScrollPane(table);

	setLayout(new BorderLayout());
	add(new JLabel(Translator.localize(""tab.checklist.warning"")),
	    BorderLayout.NORTH);
	add(sp, BorderLayout.CENTER);
	
	addComponentListener(this);
    }",3.888888888888889
"public void vetoableChange(PropertyChangeEvent pce) {
        if (""ownedElement"".equals(pce.getPropertyName())) {
            Vector oldOwned = (Vector) pce.getOldValue();
            Object eo = pce.getNewValue();
            Object me = Model.getFacade().getModelElement(eo);
            if (oldOwned.contains(eo)) {
                LOG.debug(""model removed "" + me);
                if (Model.getFacade().isANode(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isANodeInstance(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAComponent(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAComponentInstance(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAClass(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAInterface(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAObject(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAAssociation(me)) {
                    removeEdge(me);
                }
                if (Model.getFacade().isADependency(me)) {
                    removeEdge(me);
                }
                if (Model.getFacade().isALink(me)) {
                    removeEdge(me);
                }
            } else {
                LOG.debug(""model added "" + me);
            }
        }
    }",4.111111111111111
"public List getInEdges(Object port) {
	Vector res = new Vector(); //wasteful!
	if (Model.getFacade().isAClassifierRole(port)) {
	    Object cr = port;
	    Collection ends = Model.getFacade().getAssociationEnds(cr);
	    if (ends == null) {
                return res; // empty Vector
            }
	    Iterator iter = ends.iterator();
	    while (iter.hasNext()) {
		Object aer = iter.next();
		res.addElement(Model.getFacade().getAssociation(aer));
	    }
	}
	return res;
    }
",3.888888888888889
"/**
     * Displays visual indications of pending ToDoItems.
     * Please note that the list of advices (ToDoList) is not the same
     * as the list of element known by the FigNode (_figs). Therefore,
     * it is necessary to check if the graphic item exists before drawing
     * on it. See ClAttributeCompartment for an example.
     * @param g the graphics device
     * @see org.argouml.uml.cognitive.critics.ClAttributeCompartment
     */
    public void paintClarifiers(Graphics g) {
        int iconX = getX();
        int iconY = getY() - 10;
        ToDoList list = Designer.theDesigner().getToDoList();
        Vector items = list.elementsForOffender(getOwner());
        int size = items.size();
        for (int i = 0; i < size; i++) {
            ToDoItem item = (ToDoItem) items.elementAt(i);
            Icon icon = item.getClarifier();
            if (icon instanceof Clarifier) {
                ((Clarifier) icon).setFig(this);
                ((Clarifier) icon).setToDoItem(item);
            }
            if (icon != null) {
                icon.paintIcon(null, g, iconX, iconY);
                iconX += icon.getIconWidth();
            }
        }
        items = list.elementsForOffender(this);
        size = items.size();
        for (int i = 0; i < size; i++) {
            ToDoItem item = (ToDoItem) items.elementAt(i);
            Icon icon = item.getClarifier();
            if (icon instanceof Clarifier) {
                ((Clarifier) icon).setFig(this);
                ((Clarifier) icon).setToDoItem(item);
            }
            if (icon != null) {
                icon.paintIcon(null, g, iconX, iconY);
                iconX += icon.getIconWidth();
            }
        }
    }",3.333333333333333
"public void mouseMoved(MouseEvent me) {
	//- RedrawManager.lock();
	translateMouseEvent(me);
	Globals.curEditor(this);
	setUnderMouse(me);
        Fig currentFig = getCurrentFig();
	if (currentFig != null && Globals.getShowFigTips()) {
	    String tip = currentFig.getTipString(me);
	    if (tip != null && (getJComponent() != null)) {
	        JComponent c = getJComponent();
	        if (c.getToolTipText() == null
		    || !(c.getToolTipText().equals(tip))) {
	            c.setToolTipText(tip);
	        }
            }
	} else if (getJComponent() != null
		   && getJComponent().getToolTipText() != null) {
            getJComponent().setToolTipText(null); //was """"
	}

	_selectionManager.mouseMoved(me);
	_modeManager.mouseMoved(me);
	//- RedrawManager.unlock();
	//- _redrawer.repairDamage();
    }",3.2222222222222223
"public Set getDependencies(Object parent) {
        if (Model.getFacade().isAClass(parent)) {
	    Set set = new HashSet();
	    set.add(parent);
	    set.addAll(Model.getFacade().getAttributes(parent));
	    set.addAll(Model.getFacade().getOperations(parent));
	    set.addAll(Model.getFacade().getAssociationEnds(parent));
	    set.addAll(Model.getFacade().getSupplierDependencies(parent));
	    set.addAll(Model.getFacade().getClientDependencies(parent));
	    set.addAll(Model.getFacade().getGeneralizations(parent));
	    set.addAll(Model.getFacade().getSpecializations(parent));
	    return set;
	}

	return null;
    }",4.666666666666667
"@Test
    public void listenersAreCalledCorrectlyInTheFaceOfFailures()
            throws Exception {
        JUnitCore core = new JUnitCore();
        final List<Failure> failures = new ArrayList<Failure>();
        core.addListener(new RunListener() {
            @Override
            public void testRunFinished(Result result) throws Exception {
                failures.addAll(result.getFailures());
            }
        });
        fMax.run(Request.aClass(TwoTests.class), core);
        assertEquals(1, failures.size());
    }",3.2222222222222223
"private Exception createTimeoutException(Thread thread) {
        StackTraceElement[] stackTrace = thread.getStackTrace();
        final Thread stuckThread = fLookForStuckThread ? getStuckThread(thread) : null;
        Exception currThreadException = new Exception(String.format(
                ""test timed out after %d %s"", fTimeout, fTimeUnit.name().toLowerCase()));
        if (stackTrace != null) {
            currThreadException.setStackTrace(stackTrace);
            thread.interrupt();
        }
        if (stuckThread != null) {
            Exception stuckThreadException = 
                new Exception (""Appears to be stuck in thread "" +
                               stuckThread.getName());
            stuckThreadException.setStackTrace(getStackTrace(stuckThread));
            return new MultipleFailureException    
                (Arrays.<Throwable>asList(currThreadException, stuckThreadException));
        } else {
            return currThreadException;
        }
    }",2.888888888888889
"/**
	 * Build the metamodel using the information from the collection of Hibernate
	 * {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
	 *
	 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
	 * @param mappedSuperclasses All known MappedSuperclasses
	 * @param sessionFactory The Hibernate session factory.
     * @param ignoreUnsupported ignore unsupported/unknown annotations (like @Any)
	 *
	 * @return The built metamodel
	 */
	public static MetamodelImpl buildMetamodel(
			Iterator<PersistentClass> persistentClasses,
			Set<MappedSuperclass> mappedSuperclasses,
			SessionFactoryImplementor sessionFactory,
            boolean ignoreUnsupported) {
		MetadataContext context = new MetadataContext( sessionFactory, mappedSuperclasses, ignoreUnsupported );
		while ( persistentClasses.hasNext() ) {
			PersistentClass pc = persistentClasses.next();
			locateOrBuildEntityType( pc, context );
		}
		handleUnusedMappedSuperclasses( context );
		context.wrapUp();
		return new MetamodelImpl( context.getEntityTypeMap(), context.getEmbeddableTypeMap(), context.getMappedSuperclassTypeMap(), context.getEntityTypesByEntityName() );
	}",3.111111111111111
"@Test
	public void testExplicitJoining() throws Exception {
		assertFalse( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );

		SessionImplementor session = (SessionImplementor) sessionFactory().withOptions().autoJoinTransactions( false ).openSession();
		TransactionImplementor transaction = (TransactionImplementor) ( (Session) session ).getTransaction();

		assertFalse( session.getTransactionCoordinator().isSynchronizationRegistered() );
		assertFalse( transaction.isParticipating() );

		session.getFlushMode();  // causes a call to TransactionCoordinator#pulse

		assertFalse( session.getTransactionCoordinator().isSynchronizationRegistered() );
		assertFalse( transaction.isParticipating() );

		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();

		assertTrue( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );
		assertTrue( transaction.isActive() );
		assertFalse( transaction.isParticipating() );
		assertFalse( session.getTransactionCoordinator().isSynchronizationRegistered() );

		session.getFlushMode();

		assertTrue( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );
		assertTrue( transaction.isActive() );
		assertFalse( session.getTransactionCoordinator().isSynchronizationRegistered() );
		assertFalse( transaction.isParticipating() );

		transaction.markForJoin();
		transaction.join();
		session.getFlushMode();

		assertTrue( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );
		assertTrue( transaction.isActive() );
		assertTrue( session.getTransactionCoordinator().isSynchronizationRegistered() );
		assertTrue( transaction.isParticipating() );

		( (Session) session ).close();

		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
	}",2.7777777777777777
"@Test
	public void testImplicitJoining() throws Exception {
		assertFalse( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );

		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
		assertTrue( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );

		SessionImplementor session = (SessionImplementor) sessionFactory().withOptions().autoJoinTransactions( false ).openSession();

		session.getFlushMode();
	}",3.333333333333333
"public void testOneToOnePropertyRefGeneratedIds() {
		try {
			Session s = openSession();
			s.beginTransaction();
			Child c2 = new Child( ""c2"" );
			ChildInfo info = new ChildInfo( ""blah blah blah"" );
			c2.setInfo( info );
			info.setOwner( c2 );
			s.persist( c2 );
			try {
				s.getTransaction().commit();
				fail( ""expecting TransientObjectException on flush"" );
			}
			catch( TransientObjectException e ) {
				// expected result
				log.trace( ""handled expected exception : "" + e );
				s.getTransaction().rollback();
			}
			finally {
				s.close();
			}
		}
		finally {
			cleanupData();
		}
	}",4.111111111111111
"@Test
   public void testBuildEntityCollectionRegionOverridesOnly() {
      AdvancedCache cache;
      Properties p = new Properties();
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.strategy"", ""LIRS"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.wake_up_interval"", ""3000"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.max_entries"", ""30000"");
      p.setProperty(""hibernate.cache.infinispan.collection.eviction.strategy"", ""LRU"");
      p.setProperty(""hibernate.cache.infinispan.collection.eviction.wake_up_interval"", ""3500"");
      p.setProperty(""hibernate.cache.infinispan.collection.eviction.max_entries"", ""35000"");
      InfinispanRegionFactory factory = createRegionFactory(p);
      try {
         factory.getCacheManager();
         EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion(""com.acme.Address"", p, null);
         assertNull(factory.getTypeOverrides().get(""com.acme.Address""));
         cache = region.getCache();
         Configuration cacheCfg = cache.getCacheConfiguration();
         assertEquals(EvictionStrategy.LIRS, cacheCfg.eviction().strategy());
         assertEquals(3000, cacheCfg.expiration().wakeUpInterval());
         assertEquals(30000, cacheCfg.eviction().maxEntries());
         // Max idle value comes from base XML configuration
         assertEquals(100000, cacheCfg.expiration().maxIdle());

         CollectionRegionImpl collectionRegion = (CollectionRegionImpl)
               factory.buildCollectionRegion(""com.acme.Person.addresses"", p, null);
         assertNull(factory.getTypeOverrides().get(""com.acme.Person.addresses""));
         cache = collectionRegion.getCache();
         cacheCfg = cache.getCacheConfiguration();
         assertEquals(EvictionStrategy.LRU, cacheCfg.eviction().strategy());
         assertEquals(3500, cacheCfg.expiration().wakeUpInterval());
         assertEquals(35000, cacheCfg.eviction().maxEntries());
         assertEquals(100000, cacheCfg.expiration().maxIdle());
      } finally {
         factory.stop();
      }
   }",3.2222222222222223
"@Test
   public void testBuildEntityRegionPersonPlusEntityOverridesWithoutCfg() {
      final String person = ""com.acme.Person"";
      Properties p = new Properties();
      // Third option, no cache defined for entity and overrides for generic entity data type and entity itself.
      p.setProperty(""hibernate.cache.infinispan.com.acme.Person.eviction.strategy"", ""LRU"");
      p.setProperty(""hibernate.cache.infinispan.com.acme.Person.expiration.lifespan"", ""60000"");
      p.setProperty(""hibernate.cache.infinispan.com.acme.Person.expiration.max_idle"", ""30000"");
      p.setProperty(""hibernate.cache.infinispan.entity.cfg"", ""myentity-cache"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.strategy"", ""FIFO"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.wake_up_interval"", ""3000"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.max_entries"", ""10000"");
      InfinispanRegionFactory factory = createRegionFactory(p);
      try {
         factory.getCacheManager();
         assertNotNull(factory.getTypeOverrides().get(person));
         assertFalse(factory.getDefinedConfigurations().contains(person));
         EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion(person, p, null);
         assertNotNull(factory.getTypeOverrides().get(person));
         assertTrue(factory.getDefinedConfigurations().contains(person));
         AdvancedCache cache = region.getCache();
         Configuration cacheCfg = cache.getCacheConfiguration();
         assertEquals(EvictionStrategy.LRU, cacheCfg.eviction().strategy());
         assertEquals(3000, cacheCfg.expiration().wakeUpInterval());
         assertEquals(10000, cacheCfg.eviction().maxEntries());
         assertEquals(60000, cacheCfg.expiration().lifespan());
         assertEquals(30000, cacheCfg.expiration().maxIdle());
      } finally {
         factory.stop();
      }
   }",3.333333333333333
"private InfinispanRegionFactory createRegionFactory(final EmbeddedCacheManager manager, Properties p) {
      final InfinispanRegionFactory factory = new SingleNodeTestCase.TestInfinispanRegionFactory() {

         @Override
         protected org.infinispan.transaction.lookup.TransactionManagerLookup createTransactionManagerLookup(Settings settings, Properties properties) {
            return new HibernateTransactionManagerLookup(null, null) {
               @Override
               public TransactionManager getTransactionManager() throws Exception {
                  AbstractJtaPlatform jta = new JBossStandAloneJtaPlatform();
                  jta.injectServices(ServiceRegistryBuilder.buildServiceRegistry());
                  return jta.getTransactionManager();
               }
            };
         }

         @Override
         protected EmbeddedCacheManager createCacheManager(Properties properties) throws CacheException {
            if (manager != null)
               return manager;
            else
               return super.createCacheManager(properties);
         }

      };

      factory.start(null, p);
      return factory;
   }",2.888888888888889
"@Test
	public void testAcceptsUnresolvedPropertyTypesIfATargetEntityIsExplicitlySet() {
		Session s = openSession();
		Transaction tx = s.beginTransaction();
		Gene item = new Gene();
		s.persist( item );
		s.flush();
		tx.rollback();
		s.close();
	}",4.555555555555555
"@Test
	@TestForIssue( jiraKey = ""HHH-4685"" )
	public void testOneToManyEmbeddableBiDirectionalDotNotationInMappedBy() throws Exception {
		// Section 11.1.26
		// The ManyToOne annotation may be used within an embeddable class to specify a relationship from the embeddable
		// class to an entity class. If the relationship is bidirectional, the non-owning OneToMany entity side must use the
		// mappedBy element of the OneToMany annotation to specify the relationship field or property of the embeddable field
		// or property on the owning side of the relationship. The dot (""."") notation syntax must be used in the mappedBy
		// element to indicate the relationship attribute within the embedded attribute. The value of each identifier used
		// with the dot notation is the name of the respective embedded field or property.
		Session s;
		s = openSession();
		s.getTransaction().begin();
		Employee e = new Employee();
		JobInfo job = new JobInfo();
		job.setJobDescription( ""Sushi Chef"" );
		ProgramManager pm = new ProgramManager();
		Collection<Employee> employees = new ArrayList<Employee>();
		employees.add(e);
		pm.setManages( employees );
		job.setPm(pm);
		e.setJobInfo( job );
		s.persist( e );
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.getTransaction().begin();
		e = (Employee) s.get( e.getClass(), e.getId() );
		assertEquals( ""same job in both directions"", 
			e.getJobInfo().getJobDescription(),
			e.getJobInfo().getPm().getManages().iterator().next().getJobInfo().getJobDescription()  );
		s.getTransaction().commit();
		s.close();
	}",3.7777777777777777
"@Test
	public void testAssociationRelatedAnnotations() throws Exception {
		XMLContext context = buildContext( ""org/hibernate/test/annotations/reflection/orm.xml"" );

		Field field = Administration.class.getDeclaredField( ""defaultBusTrip"" );
		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( field, context );
		assertNotNull( reader.getAnnotation( OneToOne.class ) );
		assertNull( reader.getAnnotation( JoinColumns.class ) );
		assertNotNull( reader.getAnnotation( PrimaryKeyJoinColumns.class ) );
		assertEquals( ""pk"", reader.getAnnotation( PrimaryKeyJoinColumns.class ).value()[0].name() );
		assertEquals( 5, reader.getAnnotation( OneToOne.class ).cascade().length );
		assertEquals( FetchType.LAZY, reader.getAnnotation( OneToOne.class ).fetch() );
		assertEquals( ""test"", reader.getAnnotation( OneToOne.class ).mappedBy() );

		context = buildContext(
				""org/hibernate/test/annotations/reflection/metadata-complete.xml""
		);
		field = BusTrip.class.getDeclaredField( ""players"" );
		reader = new JPAOverriddenAnnotationReader( field, context );
		assertNotNull( reader.getAnnotation( OneToMany.class ) );
		assertNotNull( reader.getAnnotation( JoinColumns.class ) );
		assertEquals( 2, reader.getAnnotation( JoinColumns.class ).value().length );
		assertEquals( ""driver"", reader.getAnnotation( JoinColumns.class ).value()[0].name() );
		assertNotNull( reader.getAnnotation( MapKey.class ) );
		assertEquals( ""name"", reader.getAnnotation( MapKey.class ).name() );

		field = BusTrip.class.getDeclaredField( ""roads"" );
		reader = new JPAOverriddenAnnotationReader( field, context );
		assertNotNull( reader.getAnnotation( ManyToMany.class ) );
		assertNotNull( reader.getAnnotation( JoinTable.class ) );
		assertEquals( ""bus_road"", reader.getAnnotation( JoinTable.class ).name() );
		assertEquals( 2, reader.getAnnotation( JoinTable.class ).joinColumns().length );
		assertEquals( 1, reader.getAnnotation( JoinTable.class ).inverseJoinColumns().length );
		assertEquals( 2, reader.getAnnotation( JoinTable.class ).uniqueConstraints()[0].columnNames().length );
		assertNotNull( reader.getAnnotation( OrderBy.class ) );
		assertEquals( ""maxSpeed"", reader.getAnnotation( OrderBy.class ).value() );
	}",2.6666666666666665
"@Test
	@TestForIssue(jiraKey = ""HHH-4699"")
	@SkipForDialect(value = { Oracle8iDialect.class, AbstractHANADialect.class }, jiraKey = ""HHH-8516"",
			comment = ""HHH-4699 was specifically for using a CHAR, but Oracle/HANA do not handle the 2nd query correctly without VARCHAR. "")
	public void testTrimmedEnumChar() throws SQLException {
		// use native SQL to insert, forcing whitespace to occur
		final Session s = openSession();
        final Connection connection = ((SessionImplementor)s).connection();
        final Statement statement = connection.createStatement();
        statement.execute(""insert into EntityEnum (id, trimmed) values(1, '"" + Trimmed.A.name() + ""')"");
        statement.execute(""insert into EntityEnum (id, trimmed) values(2, '"" + Trimmed.B.name() + ""')"");

        s.getTransaction().begin();

        // ensure EnumType can do #fromName with the trimming
        List<EntityEnum> resultList = s.createQuery(""select e from EntityEnum e"").list();
        assertEquals( resultList.size(), 2 );
        assertEquals( resultList.get(0).getTrimmed(), Trimmed.A );
        assertEquals( resultList.get(1).getTrimmed(), Trimmed.B );

        // ensure querying works
        final Query query = s.createQuery(""select e from EntityEnum e where e.trimmed=?"");
        query.setParameter( 0, Trimmed.A );
        resultList = query.list();
        assertEquals( resultList.size(), 1 );
        assertEquals( resultList.get(0).getTrimmed(), Trimmed.A );

		statement.execute( ""delete from EntityEnum"" );

        s.getTransaction().commit();
        s.close();
	}",3.6666666666666665
"@Test
	public void testWithEJB3NamingStrategy() throws Exception {
		SessionFactory  sf = null;
		try {
			AnnotationConfiguration config = new AnnotationConfiguration();
			config.setNamingStrategy(EJB3NamingStrategy.INSTANCE);
			config.addAnnotatedClass(A.class);
			config.addAnnotatedClass(AddressEntry.class);
			sf = config.buildSessionFactory( serviceRegistry );
			Mappings mappings = config.createMappings();
			boolean foundIt = false;

			for ( Iterator iter = mappings.iterateTables(); iter.hasNext();  ) {
				Table table = (Table) iter.next();
                log.info(""testWithEJB3NamingStrategy table = "" + table.getName());
				if ( table.getName().equalsIgnoreCase(""A_ADDRESS"")) {
					foundIt = true;
				}
				// make sure we use A_ADDRESS instead of AEC_address
				assertFalse(""got table name mapped to: AEC_address (should be A_ADDRESS) which violates JPA-2 spec section 11.1.8 ([OWNING_ENTITY_NAME]_[COLLECTION_ATTRIBUTE_NAME])"",table.getName().equalsIgnoreCase(""AEC_address""));
			}
			assertTrue(""table not mapped to A_ADDRESS which violates JPA-2 spec section 11.1.8"",foundIt);
		}
		catch( Exception e ) {
			StringWriter writer = new StringWriter();
			e.printStackTrace(new PrintWriter(writer));
            log.debug(writer.toString());
			fail(e.getMessage());
		} finally {
			if( sf != null ){
				sf.close();
			}
		}
	}",3.0
"@Test
	@SkipForDialects( {
			@SkipForDialect( value = { HSQLDialect.class }, comment = ""The used join conditions does not work in HSQLDB. See HHH-4497."" ), 
			@SkipForDialect( value = { SQLServer2005Dialect.class } ),
			@SkipForDialect( value = { Oracle8iDialect.class }, comment = ""Oracle/DB2 do not support 'substring' function"" ),
			@SkipForDialect( value = { DB2Dialect.class }, comment = ""Oracle/DB2 do not support 'substring' function"" ) } )
	public void testManyToOneFromNonPkToNonPk() throws Exception {
		// also tests usage of the stand-alone @JoinFormula annotation (i.e. not wrapped within @JoinColumnsOrFormulas)
		Session s = openSession();
		Transaction tx = s.beginTransaction();

        Product kit = new Product();
        kit.id = 1;
        kit.productIdnf = ""KIT"";
        kit.description = ""Kit"";
        s.persist(kit);

        Product kitkat = new Product();
        kitkat.id = 2;
        kitkat.productIdnf = ""KIT_KAT"";
        kitkat.description = ""Chocolate"";
        s.persist(kitkat);

        s.flush();
        s.clear();

        kit = (Product) s.get(Product.class, 1);
        kitkat = (Product) s.get(Product.class, 2);
        System.out.println(kitkat.description);
        assertNotNull(kitkat);
        assertEquals(kit, kitkat.getProductFamily());
        assertEquals(kit.productIdnf, kitkat.getProductFamily().productIdnf);
        assertEquals(""KIT_KAT"", kitkat.productIdnf.trim());
        assertEquals(""Chocolate"", kitkat.description.trim());

        tx.rollback();
		s.close();
    }",3.7777777777777777
"public CollectionListeners( SessionFactory sf) {
		preCollectionRecreateListener = new PreCollectionRecreateListener( this );
		initializeCollectionListener = new InitializeCollectionListener( this );
		preCollectionRemoveListener = new PreCollectionRemoveListener( this );
		preCollectionUpdateListener = new PreCollectionUpdateListener( this );
		postCollectionRecreateListener = new PostCollectionRecreateListener( this );
		postCollectionRemoveListener = new PostCollectionRemoveListener( this );
		postCollectionUpdateListener = new PostCollectionUpdateListener( this );

		EventListenerRegistry registry = ( (SessionFactoryImplementor) sf ).getServiceRegistry().getService( EventListenerRegistry.class );
		registry.setListeners( EventType.INIT_COLLECTION, initializeCollectionListener );

		registry.setListeners( EventType.PRE_COLLECTION_RECREATE, preCollectionRecreateListener );
		registry.setListeners( EventType.POST_COLLECTION_RECREATE, postCollectionRecreateListener );

		registry.setListeners( EventType.PRE_COLLECTION_REMOVE, preCollectionRemoveListener );
		registry.setListeners( EventType.POST_COLLECTION_REMOVE, postCollectionRemoveListener );

		registry.setListeners( EventType.PRE_COLLECTION_UPDATE, preCollectionUpdateListener );
		registry.setListeners( EventType.POST_COLLECTION_UPDATE, postCollectionUpdateListener );
	}",4.111111111111111
"@Test
	public void testUpdateParentOneChildDiffCollectionDiffChild() {
		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
		ParentWithCollection parent = createParentWithOneChild( ""parent"", ""child"" );
		Child oldChild = ( Child ) parent.getChildren().iterator().next();
		listeners.clear();
		assertEquals( 1, parent.getChildren().size() );
		Session s = openSession();
		Transaction tx = s.beginTransaction();
		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
		if ( oldChild instanceof Entity ) {
			oldChild = ( Child ) s.get( oldChild.getClass(), ( ( Entity ) oldChild).getId() );
		}
		Collection oldCollection = parent.getChildren();
		parent.newChildren( createCollection() );
		Child newChild = parent.addChild( ""new1"" );
		tx.commit();
		s.close();
		int index = 0;
		if ( ( (PersistentCollection) oldCollection ).wasInitialized() ) {
			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, oldCollection, index++ );
		}
		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
			ChildWithBidirectionalManyToMany oldChildWithManyToMany = ( ChildWithBidirectionalManyToMany ) oldChild;
			if ( ( ( PersistentCollection ) oldChildWithManyToMany.getParents() ).wasInitialized() ) {
				checkResult( listeners, listeners.getInitializeCollectionListener(), oldChildWithManyToMany, index++ );
			}
		}
		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
			checkResult( listeners, listeners.getPreCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
			checkResult( listeners, listeners.getPostCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
		}
		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
		checkNumberOfResults( listeners, index );
	}",2.4444444444444446
"public int hashCode() {
        final int PRIME = 31;
        int result = 1;
        if ( name != null ) {
            result += name.hashCode();
        }
        result *= PRIME;
        if ( num != null ) {
            result += num.hashCode();
        }
        return result;
    }",4.333333333333333
"@Test
	public void testCascadeBasedBuild() {
		EntityPersister ep = (EntityPersister) sessionFactory().getClassMetadata(Message.class);
		CascadeStyleLoadPlanBuildingAssociationVisitationStrategy strategy = new CascadeStyleLoadPlanBuildingAssociationVisitationStrategy(
				CascadingActions.MERGE,
				sessionFactory(),
				LoadQueryInfluencers.NONE,
				LockMode.NONE
		);
		LoadPlan plan = MetamodelDrivenLoadPlanBuilder.buildRootEntityLoadPlan( strategy, ep );
		assertFalse( plan.hasAnyScalarReturns() );
		assertEquals( 1, plan.getReturns().size() );
		Return rtn = plan.getReturns().get( 0 );
		EntityReturn entityReturn = ExtraAssertions.assertTyping( EntityReturn.class, rtn );
		assertNotNull( entityReturn.getFetches() );
		assertEquals( 1, entityReturn.getFetches().length );
		Fetch fetch = entityReturn.getFetches()[0];
		EntityFetch entityFetch = ExtraAssertions.assertTyping( EntityFetch.class, fetch );
		assertNotNull( entityFetch.getFetches() );
		assertEquals( 0, entityFetch.getFetches().length );

		LoadPlanTreePrinter.INSTANCE.logTree( plan, new AliasResolutionContextImpl( sessionFactory() ) );
	}",3.111111111111111
"public LoadPlan buildLoadPlan(
			SessionFactoryImplementor sf,
			OuterJoinLoadable persister,
			LoadQueryInfluencers influencers,
			LockMode lockMode) {
		FetchStyleLoadPlanBuildingAssociationVisitationStrategy strategy = new FetchStyleLoadPlanBuildingAssociationVisitationStrategy(
				sf,
				influencers,
				lockMode
				);
		return MetamodelDrivenLoadPlanBuilder.buildRootEntityLoadPlan( strategy, persister );
	}",3.333333333333333
"private void compare(JoinWalker walker, LoadQueryDetails details) {
		System.out.println( ""------ SQL -----------------------------------------------------------------"" );
		System.out.println( ""WALKER    : "" + walker.getSQLString() );
		System.out.println( ""LOAD-PLAN : "" + details.getSqlStatement() );
		System.out.println( ""----------------------------------------------------------------------------"" );
		System.out.println( );
		System.out.println( ""------ SUFFIXES ------------------------------------------------------------"" );
		System.out.println( ""WALKER    : "" + StringHelper.join( "", "",  walker.getSuffixes() ) + "" : ""
									+ StringHelper.join( "", "", walker.getCollectionSuffixes() ) );
		System.out.println( ""----------------------------------------------------------------------------"" );
		System.out.println( );
	}",4.888888888888889
"@Test
	public void testExceptionHandling() {
		Session session = openSession();
		SessionImplementor sessionImpl = (SessionImplementor) session;
		boolean caught = false;
		try {
			PreparedStatement ps = sessionImpl.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer()
					.prepareStatement( ""select count(*) from NON_EXISTENT"" );
			sessionImpl.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().execute( ps );
		}
		catch ( JDBCException ok ) {
			caught = true;
		}
		finally {
			session.close();
		}

		assertTrue( ""The connection did not throw a JDBCException as expected"", caught );
	}",3.888888888888889
"private void doBasicPluralAttributeBinding(PluralAttributeSource source, AbstractPluralAttributeBinding binding) {
		binding.setFetchTiming( source.getFetchTiming() );
		binding.setFetchStyle( source.getFetchStyle() );
		binding.setCascadeStyles( source.getCascadeStyles() );

		binding.setCaching( source.getCaching() );

		binding.getHibernateTypeDescriptor().setJavaTypeName(
				source.getPluralAttributeNature().reportedJavaType().getName()
		);
		binding.getHibernateTypeDescriptor().setExplicitTypeName( source.getTypeInformation().getName() );
		binding.getHibernateTypeDescriptor().getTypeParameters().putAll( source.getTypeInformation().getParameters() );

		if ( StringHelper.isNotEmpty( source.getCustomPersisterClassName() ) ) {
			binding.setCollectionPersisterClass(
					currentBindingContext.<CollectionPersister>locateClassByName( source.getCustomPersisterClassName() )
			);
		}

		if ( source.getCustomPersisterClassName() != null ) {
			binding.setCollectionPersisterClass(
					metadata.<CollectionPersister>locateClassByName( source.getCustomPersisterClassName() )
			);
		}

		binding.setCustomLoaderName( source.getCustomLoaderName() );
		binding.setCustomSqlInsert( source.getCustomSqlInsert() );
		binding.setCustomSqlUpdate( source.getCustomSqlUpdate() );
		binding.setCustomSqlDelete( source.getCustomSqlDelete() );
		binding.setCustomSqlDeleteAll( source.getCustomSqlDeleteAll() );

		binding.setMetaAttributeContext(
				buildMetaAttributeContext(
						source.metaAttributes(),
						binding.getContainer().getMetaAttributeContext()
				)
		);

		doBasicAttributeBinding( source, binding );
	}",2.7777777777777777
"private void pushHibernateTypeInformationDownIfNeeded(
			HibernateTypeDescriptor hibernateTypeDescriptor,
			Value value,
			Type resolvedHibernateType) {
		if ( resolvedHibernateType == null ) {
			return;
		}
		if ( hibernateTypeDescriptor.getResolvedTypeMapping() == null ) {
			hibernateTypeDescriptor.setResolvedTypeMapping( resolvedHibernateType );
		}

		// java type information ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		if ( hibernateTypeDescriptor.getJavaTypeName() == null ) {
			hibernateTypeDescriptor.setJavaTypeName( resolvedHibernateType.getReturnedClass().getName() );
		}

	   // todo : this can be made a lot smarter, but for now this will suffice.  currently we only handle single value bindings

	   if ( SimpleValue.class.isInstance( value ) ) {
		   SimpleValue simpleValue = ( SimpleValue ) value;
		   if ( simpleValue.getDatatype() == null ) {
			   simpleValue.setDatatype(
					   new Datatype(
							   resolvedHibernateType.sqlTypes( metadata )[0],
							   resolvedHibernateType.getName(),
							   resolvedHibernateType.getReturnedClass()
					   )
			   );
		   }
	   }
	}",3.4444444444444446
"public static Iterable<AttributeDefinition> getCompositeCollectionIndexSubAttributes(CompositeCollectionElementDefinition compositionElementDefinition){
		final QueryableCollection collectionPersister =
				(QueryableCollection) compositionElementDefinition.getCollectionDefinition().getCollectionPersister();
		return getSingularSubAttributes(
				compositionElementDefinition.getSource(),
				(OuterJoinLoadable) collectionPersister.getOwnerEntityPersister(),
				(CompositeType) collectionPersister.getIndexType(),
				collectionPersister.getTableName(),
				collectionPersister.getIndexColumnNames()
		);
	}",3.0
"/**
	 * As per sections 12.2.3.23.9, 12.2.4.8.9 and 12.2.5.3.6 of the JPA 2.0
	 * specification, the element-collection subelement completely overrides the
	 * mapping for the specified field or property.  Thus, any methods which
	 * might in some contexts merge with annotations must not do so in this
	 * context.
	 */
	private void getElementCollection(List<Annotation> annotationList, XMLContext.Default defaults) {
		for ( Element element : elementsForProperty ) {
			if ( ""element-collection"".equals( element.getName() ) ) {
				AnnotationDescriptor ad = new AnnotationDescriptor( ElementCollection.class );
				addTargetClass( element, ad, ""target-class"", defaults );
				getFetchType( ad, element );
				getOrderBy( annotationList, element );
				getOrderColumn( annotationList, element );
				getMapKey( annotationList, element );
				getMapKeyClass( annotationList, element, defaults );
				getMapKeyTemporal( annotationList, element );
				getMapKeyEnumerated( annotationList, element );
				getMapKeyColumn( annotationList, element );
				buildMapKeyJoinColumns( annotationList, element );
				Annotation annotation = getColumn( element.element( ""column"" ), false, element );
				addIfNotNull( annotationList, annotation );
				getTemporal( annotationList, element );
				getEnumerated( annotationList, element );
				getLob( annotationList, element );
				//Both map-key-attribute-overrides and attribute-overrides
				//translate into AttributeOverride annotations, which need
				//need to be wrapped in the same AttributeOverrides annotation.
				List<AttributeOverride> attributes = new ArrayList<AttributeOverride>();
				attributes.addAll( buildAttributeOverrides( element, ""map-key-attribute-override"" ) );
				attributes.addAll( buildAttributeOverrides( element, ""attribute-override"" ) );
				annotation = mergeAttributeOverrides( defaults, attributes, false );
				addIfNotNull( annotationList, annotation );
				annotation = getAssociationOverrides( element, defaults, false );
				addIfNotNull( annotationList, annotation );
				getCollectionTable( annotationList, element, defaults );
				annotationList.add( AnnotationFactory.create( ad ) );
				getAccessType( annotationList, element );
			}
		}
	}",2.888888888888889
"@Override
	public void release() {
		if ( reader == null ) {
			return;
		}
		try {
			reader.close();
		}
		catch (IOException ignore) {
		}
	}",4.777777777777778
"@Override
	protected XMLEvent internalNextEvent() throws XMLStreamException {
		//If there is an iterator to read from reset was called, use the iterator
		//until it runs out of events.
		if (this.bufferReader != null) {
			final XMLEvent event = this.bufferReader.next();

			//If nothing left in the iterator, remove the reference and fall through to direct reading
			if (!this.bufferReader.hasNext()) {
				this.bufferReader = null;
			}

			return event;
		}

		//Get the next event from the underlying reader
		final XMLEvent event = this.getParent().nextEvent();

		//if buffering add the event
		if (this.eventLimit != 0) {
			this.eventBuffer.offer(event);

			//If limited buffer size and buffer is too big trim the buffer.
			if (this.eventLimit > 0 && this.eventBuffer.size() > this.eventLimit) {
				this.eventBuffer.poll();
			}
		}

		return event;
	}",4.555555555555555
"@Override
	public final String getElementText() throws XMLStreamException {
		XMLEvent event = this.previousEvent;
		if (event == null) {
			throw new XMLStreamException(""Must be on START_ELEMENT to read next text, element was null"");
		}
		if (!event.isStartElement()) {
			throw new XMLStreamException(""Must be on START_ELEMENT to read next text"", event.getLocation());
		}

		final StringBuilder text = new StringBuilder();
		while (!event.isEndDocument()) {
			switch (event.getEventType()) {
				case XMLStreamConstants.CHARACTERS:
				case XMLStreamConstants.SPACE:
				case XMLStreamConstants.CDATA: {
					final Characters characters = event.asCharacters();
					text.append(characters.getData());
					break;
				}
				case XMLStreamConstants.ENTITY_REFERENCE: {
					final EntityReference entityReference = (EntityReference)event;
					final EntityDeclaration declaration = entityReference.getDeclaration();
					text.append(declaration.getReplacementText());
					break;
				}
				case XMLStreamConstants.COMMENT:
				case XMLStreamConstants.PROCESSING_INSTRUCTION: {
					//Ignore
					break;
				}
				default: {
					throw new XMLStreamException(""Unexpected event type '"" + XMLStreamConstantsUtils.getEventName(event.getEventType()) + ""' encountered. Found event: "" + event, event.getLocation());
				}
			}

			event = this.nextEvent();
		}

		return text.toString();
	}",4.111111111111111
"public Point getClosestPoint(Point anotherPt) {
        Rectangle r = getBounds();
        int[] xs = {r.x + r.width / 2,
                    r.x + r.width,
                    r.x + r.width / 2,
                    r.x,
                    r.x + r.width / 2,
        };
        int[] ys = {r.y,
                    r.y + r.height / 2,
                    r.y + r.height,
                    r.y + r.height / 2,
                    r.y,
        };
        Point p =
            Geometry.ptClosestTo(
                xs,
                ys,
                5,
                anotherPt);
        return p;
    }",4.333333333333333
"protected void modelChanged(PropertyChangeEvent mee) {
        super.modelChanged(mee);
        final Object trCollection = mee.getNewValue();
        final String eName = mee.getPropertyName();
        final Object owner = getOwner();
        /*
         * A Concurrent region cannot have incoming or outgoing transitions so
         * incoming or outgoing transitions are redirected to its concurrent
         * composite state container.
         */
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                Object tr = null;
                // TODO: Is this comparison correct?
                // Where is the string created?
                if (eName == ""incoming"") {
                    if (!((Collection) trCollection).isEmpty()) {
                        tr = ((Collection) trCollection).iterator().next();
                    }
                    if (tr != null
                            && Model.getFacade().isATransition(tr)) {
                        Model.getCommonBehaviorHelper().setTarget(tr,
                                Model.getFacade().getContainer(owner));
                    }
                } else if (eName == ""outgoing"") {
                    if (!((Collection) trCollection).isEmpty()) {
                        tr = ((Collection) trCollection).iterator().next();
                    }
                    if (tr != null
                            && Model.getFacade().isATransition(tr))
                    {
                        Model.getStateMachinesHelper().setSource(tr,
                                Model.getFacade().getContainer(owner));
                    }
                }
            }
        });
    }",3.0
"public void setEnclosingFig(Fig encloser) {
        if (getOwner() != null) {
            Object nod = getOwner();
            if (encloser != null) {
                Object comp = encloser.getOwner();
                if (Model.getFacade().isAComponentInstance(comp)) {
                    if (Model.getFacade().getComponentInstance(nod) != comp) {
                        Model.getCommonBehaviorHelper()
                                .setComponentInstance(nod, comp);
                        super.setEnclosingFig(encloser);
                    }
                } else if (Model.getFacade().isANode(comp)) {
                    super.setEnclosingFig(encloser);
                }
            } else if (encloser == null) {
                if (isVisible() 
                        // If we are not visible most likely 
                        // we're being deleted.
                    // TODO: This indicates a more fundamental problem that should
                    // be investigated - tfm - 20061230
                    && Model.getFacade().getComponentInstance(nod) 
                                    != null) {
                    Model.getCommonBehaviorHelper()
                            .setComponentInstance(nod, null);
                    super.setEnclosingFig(encloser);
                }
            }
        }

        if (getLayer() != null) {
            // elementOrdering(figures);
            Collection contents = new ArrayList(getLayer().getContents());
            Iterator it = contents.iterator();
            while (it.hasNext()) {
                Object o = it.next();
                if (o instanceof FigEdgeModelElement) {
                    FigEdgeModelElement figedge = (FigEdgeModelElement) o;
                    figedge.getLayer().bringToFront(figedge);
                }
            }
        }
    }",2.888888888888889
"protected Object[] getUmlActions() {
        Object[] actions = {
            getActionPackage(),
            getActionClass(),
            null,
            getAssociationActions(),
            getAggregationActions(),
            getCompositionActions(),
            getActionAssociationEnd(),
            getActionGeneralization(),
            null,
            getActionInterface(),
            getActionRealization(),
            null,
            getDependencyActions(),
            null,
            getActionAttribute(),
            getActionOperation(),
            getActionAssociationClass(),
            null,
            getDataTypeActions(),
        };

        return actions;
    }",3.2222222222222223
"public void buildModel() {
        if (getTarget() != null) {
            Object target = getTarget();
            Object kind = Model.getFacade().getAggregation(target);
            if (kind == null
                    || kind.equals(
                            Model.getAggregationKind().getNone())) {
                setSelected(ActionSetAssociationEndAggregation.NONE_COMMAND);
            } else {
		if (kind.equals(
		        Model.getAggregationKind().getAggregate())) {
		    setSelected(ActionSetAssociationEndAggregation
		            .AGGREGATE_COMMAND);
		} else {
		    if (kind.equals(
		            Model.getAggregationKind()
		            	.getComposite())) {
			setSelected(ActionSetAssociationEndAggregation
			        .COMPOSITE_COMMAND);
		    } else {
		        setSelected(ActionSetAssociationEndAggregation

			        .NONE_COMMAND);
		    }
		}
            }
        }
    }",2.555555555555556
"/**
     * Construct a property panel for Node Instance elements.
     */
    public PropPanelNodeInstance() {
        super(""Node Instance"", lookupIcon(""NodeInstance""),
                ConfigLoader.getTabPropsOrientation());

        addField(Translator.localize(""label.name""), getNameTextField());
        addField(Translator.localize(""label.namespace""),
                getNamespaceSelector());

        addSeparator();

        addField(Translator.localize(""label.stimili-sent""),
                getStimuliSenderScroll());

        addField(Translator.localize(""label.stimili-received""),
                getStimuliReceiverScroll());

        JList resList = new UMLLinkedList(new UMLContainerResidentListModel());
        addField(Translator.localize(""label.residents""),
                new JScrollPane(resList));

        addSeparator();
        AbstractActionAddModelElement a =
            new ActionAddInstanceClassifier(Model.getMetaTypes().getNode());
        JScrollPane classifierScroll =
                new JScrollPane(new UMLMutableLinkedList(
	                new UMLInstanceClassifierListModel(),
	            a, null, null, true));
	addField(Translator.localize(""label.classifiers""),
                    classifierScroll);


        addAction(new ActionNavigateContainerElement());
        addAction(new ActionNewStereotype());
        addAction(getDeleteAction());
    }",2.6666666666666665
"@Test
    public void shouldReturnOnlyTheNamedDataPoints() throws Throwable {
        SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(TestClassWithNamedDataPoints.class));

        List<PotentialAssignment> assignments = supplier.getValueSources(signature(""methodWantingAllNamedStrings""));
        List<String> assignedStrings = getStringValuesFromAssignments(assignments);

        assertEquals(4, assignedStrings.size());
        assertThat(assignedStrings, hasItems(""named field"", ""named method"", ""named single value"", ""named single method value""));
    }",3.6666666666666665
"@Test
    public void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException()
            throws Throwable {
        thrown.expectMessage(""test timed out after 100 milliseconds"");
        try {
            evaluateWithException(new RuntimeException());
        } catch (Throwable expected) {
        }
        evaluateWithWaitDuration(TIMEOUT + 50);
    }",4.333333333333333
"@Test
    public void stackTraceContainsRealCauseOfTimeout() throws Throwable {
        StuckStatement stuck = new StuckStatement();
        FailOnTimeout stuckTimeout = new FailOnTimeout(stuck, TIMEOUT);
        try {
            stuckTimeout.evaluate();
            // We must not get here, we expect a timeout exception
            fail(""Expected timeout exception"");
        } catch (Exception timeoutException) {
            StackTraceElement[] stackTrace = timeoutException.getStackTrace();
            boolean stackTraceContainsTheRealCauseOfTheTimeout = false;
            boolean stackTraceContainsOtherThanTheRealCauseOfTheTimeout = false;
            for (StackTraceElement element : stackTrace) {
                String methodName = element.getMethodName();
                if (""theRealCauseOfTheTimeout"".equals(methodName)) {
                    stackTraceContainsTheRealCauseOfTheTimeout = true;
                }
                if (""notTheRealCauseOfTheTimeout"".equals(methodName)) {
                    stackTraceContainsOtherThanTheRealCauseOfTheTimeout = true;
                }
            }
            assertTrue(
                    ""Stack trace does not contain the real cause of the timeout"",
                    stackTraceContainsTheRealCauseOfTheTimeout);
            assertFalse(
                    ""Stack trace contains other than the real cause of the timeout, which can be very misleading"",
                    stackTraceContainsOtherThanTheRealCauseOfTheTimeout);
        }
    }",3.555555555555556
"@Test
	public void testQueryCacheModes() {
		EntityManager em = getOrCreateEntityManager();
		Query jpaQuery = em.createQuery( ""from SimpleEntity"" );
		AbstractQueryImpl hibQuery = (AbstractQueryImpl) ( (HibernateQuery) jpaQuery ).getHibernateQuery();

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.USE );
		assertEquals( CacheStoreMode.USE, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.NORMAL, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.BYPASS );
		assertEquals( CacheStoreMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.GET, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.REFRESH );
		assertEquals( CacheStoreMode.REFRESH, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.REFRESH, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE, CacheRetrieveMode.BYPASS );
		assertEquals( CacheRetrieveMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE ) );
		assertEquals( CacheStoreMode.REFRESH, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.REFRESH, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.BYPASS );
		assertEquals( CacheRetrieveMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE ) );
		assertEquals( CacheStoreMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.IGNORE, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.USE );
		assertEquals( CacheRetrieveMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE ) );
		assertEquals( CacheStoreMode.USE, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.PUT, hibQuery.getCacheMode() );
	}",2.6666666666666665
"@Test
	public void testRestrictedCorrelationNoExplicitSelection() {
		CriteriaBuilder builder = entityManagerFactory().getCriteriaBuilder();
		EntityManager em = getOrCreateEntityManager();
		em.getTransaction().begin();

		CriteriaQuery<Order> criteria = builder.createQuery( Order.class );
		Root<Order> orderRoot = criteria.from( Order.class );
		criteria.select( orderRoot );
		// create correlated subquery
		Subquery<Customer> customerSubquery = criteria.subquery( Customer.class );
		Root<Order> orderRootCorrelation = customerSubquery.correlate( orderRoot );
		Join<Order, Customer> orderCustomerJoin = orderRootCorrelation.join( ""customer"" );
		customerSubquery.where( builder.like( orderCustomerJoin.<String>get( ""name"" ), ""%Caruso"" ) );
		criteria.where( builder.exists( customerSubquery ) );
		em.createQuery( criteria ).getResultList();

		em.getTransaction().commit();
		em.close();
	}",2.888888888888889
"/**
	 * Get the value mapped to this key, or null if no value is mapped to this key.
	 *
	 * @param key The cache key
	 *
	 * @return The cached data
	 */
	public final Object get(Object key) {
		try {
			final Element element = getCache().get( key );
			if ( element == null ) {
				return null;
			}
			else {
				return element.getObjectValue();
			}
		}
		catch (net.sf.ehcache.CacheException e) {
			if ( e instanceof NonStopCacheException ) {
				HibernateNonstopCacheExceptionHandler.getInstance()
						.handleNonstopCacheException( (NonStopCacheException) e );
				return null;
			}
			else {
				throw new CacheException( e );
			}
		}
	}",4.222222222222222
"@Test
	public void testModFlagProperties() {
		assertEquals(
				TestTools.makeSet( ""comp1_MOD"" ),
				TestTools.extractModProperties(
						getCfg().getClassMapping(
								""org.hibernate.envers.test.entities.components.ComponentTestEntity_AUD""
						)
				)
		);
	}",4.333333333333333
"@Test
	public void testHistoryOfEdIng2() {
		SetOwnedEntity ed1 = getEntityManager().find( SetOwnedEntity.class, ed1_id );
		SetOwnedEntity ed2 = getEntityManager().find( SetOwnedEntity.class, ed2_id );

		SetOwningEntity rev1 = getAuditReader().find( SetOwningEntity.class, ing2_id, 1 );
		SetOwningEntity rev2 = getAuditReader().find( SetOwningEntity.class, ing2_id, 2 );
		SetOwningEntity rev3 = getAuditReader().find( SetOwningEntity.class, ing2_id, 3 );
		SetOwningEntity rev4 = getAuditReader().find( SetOwningEntity.class, ing2_id, 4 );
		SetOwningEntity rev5 = getAuditReader().find( SetOwningEntity.class, ing2_id, 5 );

		assert rev1.getReferences().equals( Collections.EMPTY_SET );
		assert rev2.getReferences().equals( TestTools.makeSet( ed1, ed2 ) );
		assert rev3.getReferences().equals( TestTools.makeSet( ed1, ed2 ) );
		assert rev4.getReferences().equals( TestTools.makeSet( ed1, ed2 ) );
		assert rev5.getReferences().equals( TestTools.makeSet( ed1, ed2 ) );
	}",3.6666666666666665
"@Test
	public void testTernaryMap() {
		final TernaryMapEntity ternaryMap = new TernaryMapEntity();
		ternaryMap.setId( ternaryMapId );
		ternaryMap.getMap().put( intEntity1, stringEntity1 );
		ternaryMap.getMap().put( new IntTestPrivSeqEntity( 2, intEntity2.getId() ) , new StrTestPrivSeqEntity( ""Value 2"", stringEntity2.getId() ) );

		TernaryMapEntity entity = getAuditReader().find( TernaryMapEntity.class, ternaryMapId, 15 );

		Assert.assertEquals( ternaryMap.getMap(), entity.getMap() );

		ternaryMap.getMap().clear();
		ternaryMap.getMap().put( intEntity1, stringEntity1 );
		ternaryMap.getMap().put( intEntity2, stringEntity2 );

		entity = getAuditReader().find( TernaryMapEntity.class, ternaryMapId, 16 );

		Assert.assertEquals( ternaryMap.getMap(), entity.getMap() );

		List queryResult = getAuditReader().createQuery().forRevisionsOfEntity( TernaryMapEntity.class, false, true )
				.add( AuditEntity.id().eq( ternaryMapId ) )
				.add( AuditEntity.revisionType().eq( RevisionType.DEL ) )
				.getResultList();
		Object[] objArray = (Object[]) queryResult.get( 0 );

		Assert.assertEquals( 17, getRevisionNumber( objArray[1] ) );

		entity = (TernaryMapEntity) objArray[0];
		Assert.assertEquals( ternaryMap.getMap(), entity.getMap() );
	}",2.7777777777777777
"@Test
	@Priority(10)
	public void initData() {
		EntityManager em = getEntityManager();

		// Revision 1
		em.getTransaction().begin();
		country = Country.of( 123, ""Germany"" );
		em.persist( country );
		em.getTransaction().commit();

	}",4.555555555555555
"@Override
	public boolean equals(Object obj) {
		if ( this == obj ) {
			return true;
		}
		if ( !super.equals( obj ) ) {
			return false;
		}
		if ( getClass() != obj.getClass() ) {
			return false;
		}
		VersionsJoinTableRangeTestAlternateEntity other = (VersionsJoinTableRangeTestAlternateEntity) obj;
		if ( alternateValue == null ) {
			if ( other.alternateValue != null ) {
				return false;
			}
		}
		else if ( !alternateValue.equals( other.alternateValue ) ) {
			return false;
		}
		return true;
	}",4.222222222222222
"private Element createMiddleEntityXml(String auditMiddleTableName, String auditMiddleEntityName, String where) {
		final String schema = mainGenerator.getSchema(
				propertyAuditingData.getJoinTable().schema(),
				propertyValue.getCollectionTable()
		);
		final String catalog = mainGenerator.getCatalog(
				propertyAuditingData.getJoinTable().catalog(),
				propertyValue.getCollectionTable()
		);

		final Element middleEntityXml = MetadataTools.createEntity(
				xmlMappingData.newAdditionalMapping(),
				new AuditTableData( auditMiddleEntityName, auditMiddleTableName, schema, catalog ), null, null
		);
		final Element middleEntityXmlId = middleEntityXml.addElement( ""composite-id"" );

		// If there is a where clause on the relation, adding it to the middle entity.
		if ( where != null ) {
			middleEntityXml.addAttribute( ""where"", where );
		}

		middleEntityXmlId.addAttribute( ""name"", mainGenerator.getVerEntCfg().getOriginalIdPropName() );

		// Adding the revision number as a foreign key to the revision info entity to the composite id of the
		// middle table.
		mainGenerator.addRevisionInfoRelation( middleEntityXmlId );

		// Adding the revision type property to the entity xml.
		mainGenerator.addRevisionType(
				isEmbeddableElementType() ? middleEntityXmlId : middleEntityXml,
				middleEntityXml
		);

		// All other properties should also be part of the primary key of the middle entity.
		return middleEntityXmlId;
	}",3.111111111111111
"private void addTransactionFactories(StrategySelectorImpl strategySelector) {
		strategySelector.registerStrategyImplementor( TransactionFactory.class, JdbcTransactionFactory.SHORT_NAME, JdbcTransactionFactory.class );
		strategySelector.registerStrategyImplementor( TransactionFactory.class, ""org.hibernate.transaction.JDBCTransactionFactory"", JdbcTransactionFactory.class );

		strategySelector.registerStrategyImplementor( TransactionFactory.class, JtaTransactionFactory.SHORT_NAME, JtaTransactionFactory.class );
		strategySelector.registerStrategyImplementor( TransactionFactory.class, ""org.hibernate.transaction.JTATransactionFactory"", JtaTransactionFactory.class );

		strategySelector.registerStrategyImplementor( TransactionFactory.class, CMTTransactionFactory.SHORT_NAME, CMTTransactionFactory.class );
		strategySelector.registerStrategyImplementor( TransactionFactory.class, ""org.hibernate.transaction.CMTTransactionFactory"", CMTTransactionFactory.class );
	}",3.888888888888889
"@Override
      public String call() throws Exception {
         try {
            if (isTrace)
               log.tracef(""[%s] Wait for all executions paths to be ready to perform calls"", title(warmup));
            barrier.await();

            long start = System.nanoTime();
            int runs = 0;
            if (isTrace)
               log.tracef(""[%s] Start time: %d"", title(warmup), start);

//            while (USE_TIME && PutFromLoadStressTestCase.this.run.get()) {
//               if (runs % 100000 == 0)
//                  log.infof(""[%s] Query run # %d"", title(warmup), runs);
//
////               Customer customer = query();
////               deleteCached(customer);

               queryItems();
//               deleteCachedItems();
//
//               runs++;
//            }
            long end = System.nanoTime();
            long duration = end - start;
            if (isTrace)
               log.tracef(""[%s] End time: %d, duration: %d, runs: %d"",
                     title(warmup), start, duration, runs);

            return opsPerMS(duration, runs);
         } finally {
            if (isTrace)
               log.tracef(""[%s] Wait for all execution paths to finish"", title(warmup));

            barrier.await();
         }
      }",3.6666666666666665
"private void registeredPutWithInterveningRemovalTest(
         final boolean transactional, final boolean removeRegion)
         throws Exception {
      withCacheManager(new CacheManagerCallable(
            TestCacheManagerFactory.createCacheManager(false)) {
         @Override
         public void call() {
            PutFromLoadValidator testee = new PutFromLoadValidator(cm,
                  transactional ? tm : null,
                  PutFromLoadValidator.NAKED_PUT_INVALIDATION_PERIOD);
            try {
               if (transactional) {
                  tm.begin();
               }
               testee.registerPendingPut(KEY1);
               if (removeRegion) {
                  testee.invalidateRegion();
               } else {
                  testee.invalidateKey(KEY1);
               }

               boolean lockable = testee.acquirePutFromLoadLock(KEY1);
               try {
                  assertFalse(lockable);
               }
               finally {
                  if (lockable) {
                     testee.releasePutFromLoadLock(KEY1);
                  }
               }
            } catch (Exception e) {
               throw new RuntimeException(e);
            }
         }
      });
   }",2.7777777777777777
"@Override
	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
		super.prepareBootstrapRegistryBuilder( builder );
		builder.with(
				new Integrator() {

				    @Override
					public void integrate(
							Configuration configuration,
							SessionFactoryImplementor sessionFactory,
							SessionFactoryServiceRegistry serviceRegistry) {
                        integrate(serviceRegistry);
					}

                    @Override
				    public void integrate( MetadataImplementor metadata,
				                           SessionFactoryImplementor sessionFactory,
				                           SessionFactoryServiceRegistry serviceRegistry ) {
                        integrate(serviceRegistry);
				    }

                    private void integrate( SessionFactoryServiceRegistry serviceRegistry ) {
                        serviceRegistry.getService( EventListenerRegistry.class ).prependListeners(EventType.LOAD,
                                                                                                   new CustomLoadListener());
                    }

					@Override
					public void disintegrate(
							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
					}
				}
		);
	}",3.4444444444444446
"@Test
	@TestForIssue( jiraKey = ""HHH-2277"")
	public void testLoadEntityWithEagerFetchingToKeyManyToOneReferenceBackToSelf() {
		sessionFactory().getStatistics().clear();

		// long winded method name to say that this is a test specifically for HHH-2277 ;)
		// essentially we have a bidirectional association where one side of the
		// association is actually part of a composite PK.
		//
		// The way these are mapped causes the problem because both sides
		// are defined as eager which leads to the infinite loop; if only
		// one side is marked as eager, then all is ok.  In other words the
		// problem arises when both pieces of instance data are coming from
		// the same result set.  This is because no ""entry"" can be placed
		// into the persistence context for the association with the
		// composite key because we are in the process of trying to build
		// the composite-id instance
		Session s = openSession();
		s.beginTransaction();
		Customer cust = new Customer( ""Acme, Inc."" );
		Order order = new Order( new Order.Id( cust, 1 ) );
		cust.getOrders().add( order );
		s.save( cust );
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.beginTransaction();
		try {
			cust = ( Customer ) s.get( Customer.class, cust.getId() );
		}
		catch( OverflowCondition overflow ) {
			fail( ""get()/load() caused overflow condition"" );
		}
		s.delete( cust );
		s.getTransaction().commit();
		s.close();
	}",4.0
"@Test
	public void testNoChildren() throws Exception {
		reader = getReader( Entity2.class, ""field1"", ""element-collection.orm1.xml"" );
		assertAnnotationPresent( ElementCollection.class );
		assertAnnotationNotPresent( OrderBy.class );
		assertAnnotationNotPresent( OrderColumn.class );
		assertAnnotationNotPresent( MapKey.class );
		assertAnnotationNotPresent( MapKeyClass.class );
		assertAnnotationNotPresent( MapKeyTemporal.class );
		assertAnnotationNotPresent( MapKeyEnumerated.class );
		assertAnnotationNotPresent( MapKeyColumn.class );
		assertAnnotationNotPresent( MapKeyJoinColumns.class );
		assertAnnotationNotPresent( MapKeyJoinColumn.class );
		assertAnnotationNotPresent( Column.class );
		assertAnnotationNotPresent( Temporal.class );
		assertAnnotationNotPresent( Enumerated.class );
		assertAnnotationNotPresent( Lob.class );
		assertAnnotationNotPresent( AttributeOverride.class );
		assertAnnotationNotPresent( AttributeOverrides.class );
		assertAnnotationNotPresent( AssociationOverride.class );
		assertAnnotationNotPresent( AssociationOverrides.class );
		assertAnnotationNotPresent( CollectionTable.class );
		assertAnnotationNotPresent( Access.class );
		ElementCollection relAnno = reader.getAnnotation( ElementCollection.class );
		assertEquals( FetchType.LAZY, relAnno.fetch() );
		assertEquals( void.class, relAnno.targetClass() );
	}",3.555555555555556
"@Test
	public void testMultipleMapKeyAttributeOverrides() throws Exception {
		reader = getReader( Entity3.class, ""field1"", ""element-collection.orm11.xml"" );
		assertAnnotationPresent( ElementCollection.class );
		assertAnnotationNotPresent( MapKey.class );
		assertAnnotationNotPresent( MapKeyClass.class );
		assertAnnotationNotPresent( MapKeyTemporal.class );
		assertAnnotationNotPresent( MapKeyEnumerated.class );
		assertAnnotationNotPresent( MapKeyColumn.class );
		assertAnnotationNotPresent( MapKeyJoinColumns.class );
		assertAnnotationNotPresent( MapKeyJoinColumn.class );
		assertAnnotationNotPresent( AttributeOverride.class );
		assertAnnotationPresent( AttributeOverrides.class );
		AttributeOverrides overridesAnno = reader
				.getAnnotation( AttributeOverrides.class );
		AttributeOverride[] overrides = overridesAnno.value();
		assertEquals( 2, overrides.length );
		assertEquals( ""field1"", overrides[0].name() );
		assertEquals( """", overrides[0].column().name() );
		assertFalse( overrides[0].column().unique() );
		assertTrue( overrides[0].column().nullable() );
		assertTrue( overrides[0].column().insertable() );
		assertTrue( overrides[0].column().updatable() );
		assertEquals( """", overrides[0].column().columnDefinition() );
		assertEquals( """", overrides[0].column().table() );
		assertEquals( 255, overrides[0].column().length() );
		assertEquals( 0, overrides[0].column().precision() );
		assertEquals( 0, overrides[0].column().scale() );
		assertEquals( ""field2"", overrides[1].name() );
		assertEquals( ""col1"", overrides[1].column().name() );
		assertTrue( overrides[1].column().unique() );
		assertFalse( overrides[1].column().nullable() );
		assertFalse( overrides[1].column().insertable() );
		assertFalse( overrides[1].column().updatable() );
		assertEquals( ""int"", overrides[1].column().columnDefinition() );
		assertEquals( ""table1"", overrides[1].column().table() );
		assertEquals( 50, overrides[1].column().length() );
		assertEquals( 2, overrides[1].column().precision() );
		assertEquals( 1, overrides[1].column().scale() );
	}",2.888888888888889
"@Test
    public void testExplicitPropertyAccessAnnotationsWithHibernateStyleOverride() throws Exception {
        AnnotationConfiguration cfg = new AnnotationConfiguration();
        Class<?> classUnderTest = Course3.class;
        cfg.addAnnotatedClass( classUnderTest );
        cfg.addAnnotatedClass( Student.class );
        SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
        EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                .getEntityMetamodel()
                .getTuplizer();
        assertTrue(
                ""Field access should be used."",
                tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
        );

        assertTrue(
                ""Property access should be used."",
                tuplizer.getGetter( 0 ) instanceof BasicPropertyAccessor.BasicGetter
        );
		factory.close();
    }",3.2222222222222223
"@Test
	@TestForIssue( jiraKey = ""HHH-7309"" )
	public void testInsertUpdateEntity_NaturalIdCachedAfterTransactionSuccess() {
		
		Session session = openSession();
		session.getSessionFactory().getStatistics().clear();
		session.beginTransaction();
		Another it = new Another( ""it"");
		session.save( it );    // schedules an InsertAction
		it.setSurname(""1234""); // schedules an UpdateAction, without bug-fix
		// this will re-cache natural-id with identical key and at same time invalidate it
		session.flush();
		session.getTransaction().commit();
		session.close();
		
		session = openSession();
		session.beginTransaction();
		it = (Another) session.bySimpleNaturalId(Another.class).load(""it"");
		assertNotNull(it);
		session.delete(it);
		session.getTransaction().commit();
		assertEquals(""In a strict access strategy we would excpect a hit here"", 1, session.getSessionFactory().getStatistics().getNaturalIdCacheHitCount());
	}",3.2222222222222223
"@Test
	@Resources(annotatedClasses = {
			SubclassOfSingleTableInheritance.class,
			SingleEntity.class,
			RootOfSingleTableInheritance.class,
			OtherSubclassOfSingleTableInheritance.class,
			SubclassOfSubclassOfSingleTableInheritance.class
	})
	public void testNoPolymorphism() {
		EntityBinding noInheritanceEntityBinding = getEntityBinding( SingleEntity.class );
		assertTrue( ""SingleEntity should be a root entity"", noInheritanceEntityBinding.isRoot() );
		assertNull( noInheritanceEntityBinding.getSuperEntityBinding() );
		assertSame( noInheritanceEntityBinding, getRootEntityBinding( SingleEntity.class ) );
		assertFalse( noInheritanceEntityBinding.isPolymorphic() );
		assertFalse( noInheritanceEntityBinding.hasSubEntityBindings() );
		assertEquals( 0, noInheritanceEntityBinding.getSubEntityBindingClosureSpan() );
		assertFalse( noInheritanceEntityBinding.getPostOrderSubEntityBindingClosure().iterator().hasNext() );
		assertFalse( noInheritanceEntityBinding.getPreOrderSubEntityBindingClosure().iterator().hasNext() );
		Set<AttributeBinding> directAttributeBindings = new HashSet<AttributeBinding>();
		for ( AttributeBinding attributeBinding : noInheritanceEntityBinding.attributeBindings() ) {
			assertTrue( directAttributeBindings.add( attributeBinding ) );
		}
		assertEquals( 1, directAttributeBindings.size() );
		assertSame(
				noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(),
				directAttributeBindings.iterator().next()
		);
		assertEquals( 1, noInheritanceEntityBinding.getAttributeBindingClosureSpan() );
		Iterator<AttributeBinding> iterator = noInheritanceEntityBinding.attributeBindings().iterator();
		assertTrue( iterator.hasNext() );
		assertSame( noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(), iterator.next() );
		assertFalse( iterator.hasNext() );
		iterator = noInheritanceEntityBinding.getAttributeBindingClosure().iterator();
		assertTrue( iterator.hasNext() );
		assertSame( noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(), iterator.next() );
		assertFalse( iterator.hasNext() );
		iterator =  noInheritanceEntityBinding.getSubEntityAttributeBindingClosure().iterator();
		assertTrue( iterator.hasNext() );
		assertSame( noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(), iterator.next() );
		assertFalse( iterator.hasNext() );
	}",2.333333333333333
"@Test
	@Resources(annotatedClasses = {
			SubclassOfSingleTableInheritance.class,
			SingleEntity.class,
			RootOfSingleTableInheritance.class,
			OtherSubclassOfSingleTableInheritance.class,
			SubclassOfSubclassOfSingleTableInheritance.class
	})
	public void testPreOrderRootSubEntityClosure() {
		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
		EntityBinding subclassEntityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
		EntityBinding otherSubclassEntityBinding = getEntityBinding( OtherSubclassOfSingleTableInheritance.class );
		EntityBinding subclassOfSubclassEntityBinding = getEntityBinding( SubclassOfSubclassOfSingleTableInheritance.class );
		// need to figure out the order of direct subclasses, since it's indeterminate
		Iterator<EntityBinding> directEntityBindingIterator = rootEntityBinding.getDirectSubEntityBindings().iterator();
		boolean isSubclassEntityBindingFirst = subclassEntityBinding == directEntityBindingIterator.next();
		assertEquals( 3, rootEntityBinding.getSubEntityBindingClosureSpan() );
		Iterator<EntityBinding> subEntityBindingIterator = rootEntityBinding.getPreOrderSubEntityBindingClosure().iterator();
		assertTrue( subEntityBindingIterator.hasNext() );
		if ( isSubclassEntityBindingFirst ) {
			assertSame( subclassEntityBinding, subEntityBindingIterator.next() );
			assertTrue( subEntityBindingIterator.hasNext() );
			assertSame( subclassOfSubclassEntityBinding, subEntityBindingIterator.next() );
			assertTrue( subEntityBindingIterator.hasNext() );
			assertSame( otherSubclassEntityBinding, subEntityBindingIterator.next() );
		}
		else {
			assertSame( otherSubclassEntityBinding, subEntityBindingIterator.next() );
			assertTrue( subEntityBindingIterator.hasNext() );
			assertSame( subclassEntityBinding, subEntityBindingIterator.next() );
			assertTrue( subEntityBindingIterator.hasNext() );
			assertSame( subclassOfSubclassEntityBinding, subEntityBindingIterator.next() );
		}
		assertFalse( subEntityBindingIterator.hasNext() );
	}",2.555555555555556
"@Override
	protected void applyRootReturnSelectFragments(SelectStatementBuilder selectStatementBuilder) {
		selectStatementBuilder.appendSelectClauseFragment(
			getQueryableCollection().selectFragment(
					getCollectionReferenceAliases().getCollectionTableAlias(),
					getCollectionReferenceAliases().getCollectionColumnAliases().getSuffix()
			)
		);
		if ( getQueryableCollection().isManyToMany() ) {
			final OuterJoinLoadable elementPersister = (OuterJoinLoadable) getQueryableCollection().getElementPersister();
			selectStatementBuilder.appendSelectClauseFragment(
					elementPersister.selectFragment(
							getCollectionReferenceAliases().getElementTableAlias(),
							getCollectionReferenceAliases().getEntityElementAliases().getColumnAliases().getSuffix()
					)
			);
		}
		super.applyRootReturnSelectFragments( selectStatementBuilder );
	}",3.333333333333333
"@Override
	public void startingCollectionElements(CollectionElementDefinition elementDefinition) {
		final Type elementType = elementDefinition.getType();
		log.tracef(
				""%s Starting collection element graph : %s"",
				StringHelper.repeat( "">>"", fetchSourceStack.size() ),
				elementDefinition.getCollectionDefinition().getCollectionPersister().getRole()
		);

		final CollectionReference collectionReference = currentCollection();
		final CollectionFetchableElement elementGraph = collectionReference.getElementGraph();

		if ( elementType.isAssociationType() || elementType.isComponentType() ) {
			if ( elementGraph == null ) {
				throw new IllegalStateException(
						""CollectionReference did not return an expected element graph : "" +
								elementDefinition.getCollectionDefinition().getCollectionPersister().getRole()
				);
			}
			if ( !elementType.isAnyType() ) {
				pushToStack( (ExpandingFetchSource) elementGraph );
			}
		}
		else {
			if ( elementGraph != null ) {
				throw new IllegalStateException(
						""CollectionReference returned an unexpected element graph : "" +
								elementDefinition.getCollectionDefinition().getCollectionPersister().getRole()
				);
			}
		}
	}",3.555555555555556
"@Override
	protected void beforeTransactionCommit() {
		transactionCoordinator().sendBeforeTransactionCompletionNotifications( this );

		final boolean flush = ! transactionCoordinator().getTransactionContext().isFlushModeNever() &&
				( isDriver || ! transactionCoordinator().getTransactionContext().isFlushBeforeCompletionEnabled() );

		if ( flush ) {
			// if an exception occurs during flush, user must call rollback()
			transactionCoordinator().getTransactionContext().managedFlush();
		}

		if ( isDriver && isInitiator ) {
			transactionCoordinator().getTransactionContext().beforeTransactionCompletion( this );
		}

		closeIfRequired();
	}",4.222222222222222
"@Test
	public void testRevisionsCounts() {
		assertEquals(
				Arrays.asList( 1, 2, 3, 4 ), getAuditReader().getRevisions(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing1_id
		)
		);
		assertEquals(
				Arrays.asList( 1, 2, 4 ), getAuditReader().getRevisions(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id
		)
		);

		assertEquals(
				Arrays.asList( 1, 3, 4 ), getAuditReader().getRevisions(
				ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity.class,
				ed1_id
		)
		);
		assertEquals(
				Arrays.asList( 1, 2, 4 ), getAuditReader().getRevisions(
				ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity.class,
				ed2_id
		)
		);
		assertEquals(
				Arrays.asList( 1, 2, 3, 4 ), getAuditReader().getRevisions(
				ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity.class,
				ed3_id
		)
		);
	}",3.888888888888889
"@Test
	public void testHistoryOfIng2() {
		ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity ed2 = getEntityManager().find(
				ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity.class,
				ed2_id
		);

		ChildIndexedListJoinColumnBidirectionalRefIngEntity rev1 = getAuditReader().find(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id,
				1
		);
		ChildIndexedListJoinColumnBidirectionalRefIngEntity rev2 = getAuditReader().find(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id,
				2
		);
		ChildIndexedListJoinColumnBidirectionalRefIngEntity rev3 = getAuditReader().find(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id,
				3
		);
		ChildIndexedListJoinColumnBidirectionalRefIngEntity rev4 = getAuditReader().find(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id,
				4
		);

		assertEquals( rev1.getReferences().size(), 0 );

		assertEquals( rev2.getReferences().size(), 1 );
		assertEquals( rev2.getReferences().get( 0 ), ed2 );

		assertEquals( rev3.getReferences().size(), 1 );
		assertEquals( rev3.getReferences().get( 0 ), ed2 );

		assertEquals( rev4.getReferences().size(), 0 );
	}",3.555555555555556
"@Test
	public void testObtainEntityNameAssociationWithEntityNameAndNotAuditedModeInNewSession() {
		//force a new session and AR
		forceNewSession();

		loadDataOnSessionAndAuditReader();

		checkEntities();

		checkEntityNames();

	}",4.444444444444445
"@Test
	@Priority(10)
	public void initData() {
		EntityManager em = getEntityManager();

		EmbeddableListEntity1 ele1 = new EmbeddableListEntity1();

		// Revision 1 (ele1: initially 1 element in both collections)
		em.getTransaction().begin();
		ele1.getComponentList().add( c3_1 );
		em.persist( ele1 );
		em.getTransaction().commit();

		// Revision (still 1) (ele1: removing non-existing element)
		em.getTransaction().begin();
		ele1 = em.find( EmbeddableListEntity1.class, ele1.getId() );
		ele1.getComponentList().remove( c3_2 );
		em.getTransaction().commit();

		// Revision 2 (ele1: adding one element)
		em.getTransaction().begin();
		ele1 = em.find( EmbeddableListEntity1.class, ele1.getId() );
		ele1.getComponentList().add( c3_2 );
		em.getTransaction().commit();

		// Revision 3 (ele1: adding one existing element)
		em.getTransaction().begin();
		ele1 = em.find( EmbeddableListEntity1.class, ele1.getId() );
		ele1.getComponentList().add( c3_1 );
		em.getTransaction().commit();

		// Revision 4 (ele1: removing one existing element)
		em.getTransaction().begin();
		ele1 = em.find( EmbeddableListEntity1.class, ele1.getId() );
		ele1.getComponentList().remove( c3_2 );
		em.getTransaction().commit();

		ele1_id = ele1.getId();

		em.close();
	}",3.888888888888889
"@Test
	@Priority(10)
	public void initData() {
		EntityManager em = getEntityManager();

		// Revision 1
		em.getTransaction().begin();
		PropertyOverrideEntity propertyEntity = new PropertyOverrideEntity( ""data 1"", 1, ""data 2"" );
		em.persist( propertyEntity );
		em.getTransaction().commit();
		propertyEntityId = propertyEntity.getId();

		// Revision 2
		em.getTransaction().begin();
		TransitiveOverrideEntity transitiveEntity = new TransitiveOverrideEntity( ""data 1"", 1, ""data 2"", 2, ""data 3"" );
		em.persist( transitiveEntity );
		em.getTransaction().commit();
		transitiveEntityId = transitiveEntity.getId();

		// Revision 3
		em.getTransaction().begin();
		AuditedSpecialEntity auditedEntity = new AuditedSpecialEntity( ""data 1"", 1, ""data 2"" );
		em.persist( auditedEntity );
		em.getTransaction().commit();
		auditedEntityId = auditedEntity.getId();

		propertyTable = getCfg().getClassMapping(
				""org.hibernate.envers.test.integration.superclass.auditoverride.PropertyOverrideEntity_AUD""
		).getTable();
		transitiveTable = getCfg().getClassMapping(
				""org.hibernate.envers.test.integration.superclass.auditoverride.TransitiveOverrideEntity_AUD""
		).getTable();
		auditedTable = getCfg().getClassMapping(
				""org.hibernate.envers.test.integration.superclass.auditoverride.AuditedSpecialEntity_AUD""
		).getTable();
	}",3.555555555555556
"protected void resetRegionUsageState(CacheAccessListener localListener, CacheAccessListener remoteListener) {
		String stdName = StandardQueryCache.class.getName();
		String acctName = Account.class.getName();

		localListener.getSawRegionModification( stdName );
		localListener.getSawRegionModification( acctName );

		localListener.getSawRegionAccess( stdName );
		localListener.getSawRegionAccess( acctName );

		remoteListener.getSawRegionModification( stdName );
		remoteListener.getSawRegionModification( acctName );

		remoteListener.getSawRegionAccess( stdName );
		remoteListener.getSawRegionAccess( acctName );

		log.info( ""Region usage state cleared"" );
	}",3.7777777777777777
"@Override
	public void configure(Configuration cfg) {
		super.configure( cfg );
		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, ""true"" );
		cfg.setProperty( Environment.GENERATE_STATISTICS, ""true"" );
		cfg.setProperty( Environment.USE_QUERY_CACHE, ""false"" );
		cfg.setProperty( Environment.CACHE_REGION_FACTORY, getCacheRegionFactory().getName() );
		cfg.setProperty( Environment.TRANSACTION_STRATEGY, getTransactionFactoryClass().getName() );
		cfg.getProperties().put( AvailableSettings.JTA_PLATFORM, getJtaPlatform() );
		cfg.setProperty( Environment.CONNECTION_PROVIDER, getConnectionProviderClass().getName() );
	}",4.444444444444445
"@Test
	public void testOrphanDelete() {
		Session session = openSession();
		Transaction t = session.beginTransaction();
		Product prod = new Product( ""Widget"" );
		Part part = new Part( ""Widge"", ""part if a Widget"" );
		MapKey mapKey = new MapKey( ""Top"" );
		prod.getParts().put( mapKey, part );
		Part part2 = new Part( ""Get"", ""another part if a Widget"" );
		prod.getParts().put( new MapKey( ""Bottom"" ), part2 );
		session.persist( prod );
		t.commit();
		session.close();

		sessionFactory().getCache().evictEntityRegion(Product.class);
		sessionFactory().getCache().evictEntityRegion(Part.class);

		session = openSession();
		t = session.beginTransaction();
		prod = (Product) session.get(Product.class, ""Widget"");
		assertTrue( Hibernate.isInitialized( prod.getParts() ) );
		part = (Part) session.get(Part.class, ""Widge"");
		prod.getParts().remove(mapKey);
		t.commit();
		session.close();

		sessionFactory().getCache().evictEntityRegion( Product.class );
		sessionFactory().getCache().evictEntityRegion(Part.class);

		session = openSession();
		t = session.beginTransaction();
		prod = (Product) session.get(Product.class, ""Widget"");
		assertTrue( Hibernate.isInitialized( prod.getParts() ) );
		assertNull( prod.getParts().get(new MapKey(""Top"")));
		assertNotNull( session.get(Part.class, ""Get"") );
		session.delete( session.get(Product.class, ""Widget"") );
		t.commit();
		session.close();
	}",3.111111111111111
"protected AnnotationInstance parserPrimaryKeyJoinColumnList(List<JaxbPrimaryKeyJoinColumn> primaryKeyJoinColumnList, AnnotationTarget target) {
		if ( MockHelper.isNotEmpty( primaryKeyJoinColumnList ) ) {
			if ( primaryKeyJoinColumnList.size() == 1 ) {
				return parserPrimaryKeyJoinColumn( primaryKeyJoinColumnList.get( 0 ), target );
			}
			else {
				return create(
						PRIMARY_KEY_JOIN_COLUMNS,
						target,
						nestedPrimaryKeyJoinColumnList( ""value"", primaryKeyJoinColumnList, null )
				);
			}
		}

		return null;

	}",3.7777777777777777
"public static <T> JaxbRoot<T> unmarshallXml(String fileName, String schemaName, Class<T> clazz, ClassLoaderService classLoaderService)
            throws JAXBException {
        Schema schema = getMappingSchema( schemaName, classLoaderService );
        InputStream in = classLoaderService.locateResourceStream( fileName );
        JAXBContext jc = JAXBContext.newInstance( clazz );
        Unmarshaller unmarshaller = jc.createUnmarshaller();
        unmarshaller.setSchema( schema );
        StreamSource stream = new StreamSource( in );
        JAXBElement<T> elem = unmarshaller.unmarshal( stream, clazz );
        Origin origin = new Origin( null, fileName );
        return new JaxbRoot<T>( elem.getValue(), origin );
    }",3.111111111111111
"private AnnotationInstance overrideSchemaCatalogByDefault(AnnotationInstance annotationInstance, EntityMappingsMocker.Default defaults) {
		List<AnnotationValue> newAnnotationValueList = new ArrayList<AnnotationValue>();
		newAnnotationValueList.addAll( annotationInstance.values() );
		boolean schemaDefined = false;
		boolean catalogDefined = false;
		if ( annotationInstance.value( ""schema"" ) != null ) {
			schemaDefined = true;
		}
		if ( annotationInstance.value( ""catalog"" ) != null ) {
			catalogDefined = true;
		}
		if ( schemaDefined && catalogDefined ) {
			return annotationInstance;
		}
		if ( !catalogDefined && StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
			newAnnotationValueList.add(
					AnnotationValue.createStringValue(
							""catalog"", defaults.getCatalog()
					)
			);
		}
		if ( !schemaDefined && StringHelper.isNotEmpty( defaults.getSchema() ) ) {
			newAnnotationValueList.add(
					AnnotationValue.createStringValue(
							""schema"", defaults.getSchema()
					)
			);
		}
		return MockHelper.create(
				annotationInstance.name(),
				annotationInstance.target(),
				MockHelper.toArray( newAnnotationValueList )
		);
	}",3.333333333333333
"public AbstractRowReader(ReaderCollector readerCollector) {
		this.entityReferenceInitializers = readerCollector.getEntityReferenceInitializers() != null
				? new ArrayList<EntityReferenceInitializer>( readerCollector.getEntityReferenceInitializers() )
				: Collections.<EntityReferenceInitializer>emptyList();
		this.arrayReferenceInitializers = readerCollector.getArrayReferenceInitializers() != null
				? new ArrayList<CollectionReferenceInitializer>( readerCollector.getArrayReferenceInitializers() )
				: Collections.<CollectionReferenceInitializer>emptyList();
		this.collectionReferenceInitializers = readerCollector.getNonArrayCollectionReferenceInitializers() != null
				? new ArrayList<CollectionReferenceInitializer>( readerCollector.getNonArrayCollectionReferenceInitializers() )
				: Collections.<CollectionReferenceInitializer>emptyList();
	}",2.555555555555556
"private void resolveEntityKey(
			ResultSet resultSet,
			ResultSetProcessingContextImpl context,
			FetchSource fetchSource,
			Map<EntityReference,EntityReferenceInitializer> initializerByEntityReference) throws SQLException {
		// Resolve any bidirectional entity references first.
		for ( BidirectionalEntityReference bidirectionalEntityReference : fetchSource.getBidirectionalEntityReferences() ) {
			final EntityReferenceInitializer targetEntityReferenceInitializer = initializerByEntityReference.get(
					bidirectionalEntityReference.getTargetEntityReference()
			);
			resolveEntityKey(
					resultSet,
					context,
					targetEntityReferenceInitializer,
					initializerByEntityReference
			);
			targetEntityReferenceInitializer.hydrateEntityState( resultSet, context );
		}
		for ( Fetch fetch : fetchSource.getFetches() ) {
			if ( EntityFetch.class.isInstance( fetch ) ) {
				final EntityFetch entityFetch = (EntityFetch) fetch;
				final EntityReferenceInitializer  entityReferenceInitializer = initializerByEntityReference.get( entityFetch );
				if ( entityReferenceInitializer != null ) {
					resolveEntityKey(
							resultSet,
							context,
							entityReferenceInitializer,
							initializerByEntityReference
					);
					entityReferenceInitializer.hydrateEntityState( resultSet, context );
				}
			}
			else if ( CompositeFetch.class.isInstance( fetch ) ) {
				resolveEntityKey(
						resultSet,
						context,
						(CompositeFetch) fetch,
						initializerByEntityReference );
			}
		}
	}",3.0
"public EntityKey interpretEntityKey(
			SessionImplementor session,
			String optionalEntityName,
			Serializable optionalId,
			Object optionalObject) {
		if ( optionalEntityName != null ) {
			final EntityPersister entityPersister;
			if ( optionalObject != null ) {
				entityPersister = session.getEntityPersister( optionalEntityName, optionalObject );
			}
			else {
				entityPersister = session.getFactory().getEntityPersister( optionalEntityName );
			}
			if ( entityPersister.isInstance( optionalId ) &&
					!entityPersister.getEntityMetamodel().getIdentifierProperty().isVirtual() &&
					entityPersister.getEntityMetamodel().getIdentifierProperty().isEmbedded() ) {
				// non-encapsulated composite identifier
				final Serializable identifierState = ((CompositeType) entityPersister.getIdentifierType()).getPropertyValues(
						optionalId,
						session
				);
				return session.generateEntityKey( identifierState, entityPersister );
			}
			else {
				return session.generateEntityKey( optionalId, entityPersister );
			}
		}
		else {
			return null;
		}
	}",3.0
"@Test
	public void testChildIdColumnName() {
		Assert.assertEquals(
				""other_id"",
				((Column) getCfg()
						.getClassMapping(
								""org.hibernate.envers.test.integration.inheritance.joined.primarykeyjoin.ChildPrimaryKeyJoinEntity_AUD""
						)
						.getKey().getColumnIterator().next()).getName()
		);
	}",3.6666666666666665
"@After
	public void cleanup() {
		b.setC( null );
		b.setD( null );
		b.getGCollection().remove( g );

		c.getBCollection().remove( b );
		c.getDCollection().remove( d );

		d.getBCollection().remove( b );
		d.setC( null );
		d.setE( null );
		d.getFCollection().remove( f );

		e.getDCollection().remove( d );
		e.setF( null );

		f.setD( null );
		f.getECollection().remove( e );
		f.setG( null );

		g.setB( null );
		g.getFCollection().remove( f );

		Session s = openSession();
		s.getTransaction().begin();
		b = ( B ) s.merge( b );
		c = ( C ) s.merge( c );
		d = ( D ) s.merge( d );
		e = ( E ) s.merge( e );
		f = ( F ) s.merge( f );
		g = ( G ) s.merge( g );
		s.delete( f );
		s.delete( g );
		s.delete( b );
		s.delete( d );
		s.delete( e );
		s.delete( c );
		s.getTransaction().commit();
		s.close();
	}",3.2222222222222223
"		long logoId = 0;

		Group group = null;

		try {
			group = getGroup();

			if (!group.isStagingGroup()) {
				return logoId;
			}
		}
		catch (Exception e) {
			return logoId;
		}

		Group liveGroup = group.getLiveGroup();

		LayoutSet liveLayoutSet = null;

		if (isPrivateLayout()) {
			liveLayoutSet = liveGroup.getPrivateLayoutSet();
		}
		else {
			liveLayoutSet = liveGroup.getPublicLayoutSet();
		}

		return liveLayoutSet.getLogoId();
	}

	@Override
	public String getSettings() {
		if (_settingsProperties == null) {
			return super.getSettings();
		}
		else {
			return _settingsProperties.toString();
		}
	}

	public UnicodeProperties getSettingsProperties() {
		if (_settingsProperties == null) {
			_settingsProperties = new UnicodeProperties(true);

			try {
				_settingsProperties.load(super.getSettings());
			}
			catch (IOException ioe) {
				_log.error(ioe, ioe);
			}
		}
",3.541832669322709
"import com.liferay.portalweb.portal.util.RuntimeVariables;

/**
 * @author Brian Wing Shun Chan
 */
public class TearDownBlogsEntryCPTest extends BaseTestCase {
	public void testTearDownBlogsEntryCP() throws Exception {
		int label = 1;

		while (label >= 1) {
			switch (label) {
			case 1:
				selenium.open(""/web/guest/home/"");
				loadRequiredJavaScriptModules();

				for (int second = 0;; second++) {
					if (second >= 90) {
						fail(""timeout"");
					}

					try {
						if (selenium.isElementPresent(""link=Control Panel"")) {
							break;
						}
					}
					catch (Exception e) {
					}

					Thread.sleep(1000);
				}
",3.234042553191489
"			DB db = DBFactoryUtil.getDB();

			Thread currentThread = Thread.currentThread();

			ClassLoader classLoader = currentThread.getContextClassLoader();

			String tablesSQL = StringUtil.read(
				classLoader,
				""com/liferay/portal/tools/sql/dependencies/portal-tables.sql"");

			String indexesSQL = StringUtil.read(
				classLoader,
				""com/liferay/portal/tools/sql/dependencies/indexes.sql"");

			String indexesProperties = StringUtil.read(
				classLoader,
				""com/liferay/portal/tools/sql/dependencies/indexes.properties"");

			db.updateIndexes(
				tablesSQL, indexesSQL, indexesProperties, _dropIndexes);
		}
		catch (Exception e) {
			_log.error(e, e);
		}
	}

	public void upgradeProcess(int buildNumber) throws UpgradeException {
		if (buildNumber == ReleaseInfo.getBuildNumber()) {
			if (_log.isDebugEnabled()) {
				_log.debug(
					""Skipping upgrade process from "" + buildNumber + "" to "" +
						ReleaseInfo.getBuildNumber());
			}

			return;
		}

		String[] upgradeProcessClassNames = getUpgradeProcessClassNames(
			PropsKeys.UPGRADE_PROCESSES);

		if (upgradeProcessClassNames.length == 0) {
			upgradeProcessClassNames = getUpgradeProcessClassNames(
				PropsKeys.UPGRADE_PROCESSES + StringPool.PERIOD + buildNumber);

			if (upgradeProcessClassNames.length == 0) {
				if (_log.isInfoEnabled()) {
					_log.info(
						""Upgrading from "" + buildNumber + "" to "" +
							ReleaseInfo.getBuildNumber() + "" is not supported"");
				}
",3.080357142857143
"
	public SetServerManagerContextPathCommand( IRemoteServerWorkingCopy server, String serverManagerContextPath ) {
		super( server, ""Set Server Manager Context Path"" );
		this.serverManagerContextPath = serverManagerContextPath;
	}

	public void execute() {
		oldServerManagerContextPath = server.getServerManagerContextPath();
		server.setServerManagerContextPath( serverManagerContextPath );
	}
",3.632478632478633
"			try {
				if (selenium.isVisible(""//section"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",3.5434782608695654
"		createGroup(model, ""websites"", parameter_group);

		
		return model;
	}
	
	private static BasicPluginConfigModel createInstallationConfigGroup(final JythonPlugin plugin, final JythonPluginCore core, final JythonPluginInitialiser jpi, final BasicPluginConfigModel parent, final boolean init_ok) {
		BasicPluginConfigModel model = core.plugin_interface.getUIManager().createBasicPluginConfigModel(parent.getSection(), ""azjython.install"");
		addJythonStatusParameter(init_ok, core, model, false);
		
		// Things to disable upon installing Jython.
		final List disable_on_install = new ArrayList();

		// We reuse this multiple times to store parameters in a group.
		ArrayList parameter_group = new ArrayList();
		
		LabelParameter lp = model.addLabelParameter2(""azjython.config.auto_config.info"");
		final ActionParameter start_param = model.addActionParameter2(""azjython.blank"", ""azjython.config.auto_config.start"");
		final ActionParameter stop_param = model.addActionParameter2(""azjython.blank"", ""azjython.config.auto_config.stop"");
		start_param.setEnabled(!init_ok);
		stop_param.setEnabled(false);
				
		parameter_group.add(lp);
		parameter_group.add(start_param);
		parameter_group.add(stop_param);
		disable_on_install.add(start_param);
		disable_on_install.add(stop_param);
		createGroup(model, ""auto_config"", parameter_group);
				
		final DirectoryParameter dm = model.addDirectoryParameter2(""jython.path"", ""azjython.config.jythonpath"", """");
		disable_on_install.add(dm);
		parameter_group.add(dm);
					
		ActionParameter am = model.addActionParameter2(""azjython.config.install"", ""azjython.config.install.action"");
		disable_on_install.add(am);
		parameter_group.add(am);
		
		final ParameterListener auto_install_listener = new ParameterListener() {
			public void parameterChanged(Parameter p) {
				boolean installed = jpi.installJython(true);
				if (installed) {
					for (int i=0; i < disable_on_install.size(); i++) {
						((Parameter)disable_on_install.get(i)).setEnabled(false);
					}
				}
			}
		};
		
		am.addListener(auto_install_listener);
		am.setEnabled(!init_ok);
",2.936651583710407
"					RuntimeVariables.replace(""Select All""));
				assertTrue(selenium.isChecked(
						""xPath=(//input[@name='_125_allRowIds'])[2]""));
				selenium.clickAt(""//input[@value='Deactivate']"",
					RuntimeVariables.replace(""Deactivate""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				assertTrue(selenium.getConfirmation()
								   .matches(""^Are you sure you want to deactivate the selected users[\\s\\S]$""));

				for (int second = 0;; second++) {
					if (second >= 90) {
						fail(""timeout"");
					}

					try {
						if (selenium.isVisible(
									""//div[@class='portlet-msg-success']"")) {
							break;
						}
					}
					catch (Exception e) {
					}

					Thread.sleep(1000);
				}

				assertEquals(RuntimeVariables.replace(
						""Your request completed successfully.""),
					selenium.getText(""//div[@class='portlet-msg-success']""));

			case 2:
				selenium.clickAt(""link=Search All Users"",
					RuntimeVariables.replace(""Search All Users""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();

				boolean advancedVisible = selenium.isVisible(
						""link=Advanced \u00bb"");

				if (!advancedVisible) {
					label = 3;

					continue;
				}

				selenium.clickAt(""link=Advanced \u00bb"",
					RuntimeVariables.replace(""Advanced""));

			case 3:
",3.0398230088495577
"		return listenerID;
	}

	public String getMessageID() {
		return messageID;
	}

	public String getOperationID() {
		return operationID;
	}

	protected long getSequenceNo() {
		return lSequenceNo;
	}

	protected void setSequenceNo(long sequenceNo) {
		lSequenceNo = sequenceNo;
	}

	public String toString() {
		String paramString = parameters.toString();
		return ""PlaformMessage {""
				+ ""cn""
				+ contentNetworkID
				+ "", ""
				+ lSequenceNo
				+ "", ""
				+ messageID
				+ "", ""
				+ listenerID
				+ "", ""
				+ operationID
				+ "", ""
				+ (paramString.length() > 32767 ? paramString.substring(0, 32767)
						: paramString) + ""}"";
	}

	public String toShortString() {
		return (requiresAuthorization ? ""AUTH: "" : """") + getMessageID() + "".""
				+ getListenerID() + ""."" + getOperationID();
	}

	/**
	 * @return
	 *
	 * @since 3.1.1.1
	 */
	public boolean sendAZID() {
		return sendAZID;
	}
",3.7136929460580914
"		else if (RUBY.getValue().equals(value)) {
			return RUBY;
		}

		throw new IllegalArgumentException(""Invalid value "" + value);
	}

	public String getValue() {
		return _value;
	}
",3.992307692307692
"		selenium.open(""/web/guest/home/"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isElementPresent(""link=Site Name"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		selenium.clickAt(""link=Site Name"", RuntimeVariables.replace(""Site Name""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		selenium.clickAt(""link=Web Content Display Test Page"",
			RuntimeVariables.replace(""Web Content Display Test Page""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		assertTrue(selenium.isPartialText(""//a[@id='_145_addApplication']"",
				""More""));
		selenium.clickAt(""//a[@id='_145_addApplication']"",
			RuntimeVariables.replace(""More""));

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isElementPresent(
							""//div[@title='Web Content Display']/p/a"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		selenium.clickAt(""//div[@title='Web Content Display']/p/a"",
			RuntimeVariables.replace(""Web Content Display""));
",3.324110671936759
"
			sendRedirect(actionRequest, actionResponse);
		}
		catch (Exception e) {
			if (e instanceof PrincipalException) {
				SessionErrors.add(actionRequest, e.getClass().getName());

				setForward(actionRequest, ""portlet.sites_admin.error"");
			}
			else {
				throw e;
			}
		}
	}

	@Override
	public ActionForward render(
			ActionMapping mapping, ActionForm form, PortletConfig portletConfig,
			RenderRequest renderRequest, RenderResponse renderResponse)
		throws Exception {

		try {
			ActionUtil.getGroup(renderRequest);
			ActionUtil.getRole(renderRequest);

			Role role = (Role)renderRequest.getAttribute(WebKeys.ROLE);

			if (role != null) {
				String name = role.getName();

				if (name.equals(RoleConstants.ORGANIZATION_USER) ||
					name.equals(RoleConstants.SITE_MEMBER)) {

					throw new NoSuchRoleException();
				}
			}
		}
		catch (Exception e) {
			if (e instanceof NoSuchGroupException ||
				e instanceof NoSuchRoleException ||
				e instanceof PrincipalException) {

				SessionErrors.add(renderRequest, e.getClass().getName());

				return mapping.findForward(""portlet.sites_admin.error"");
			}
			else {
				throw e;
			}
		}
",3.464
"		float trialFitness = posFitnesses[solutionPosID];

		if(trialFitness BETTER_THAN fitnesses[solutionPosID])
		{
			posBetter = true;
			bias = 0.2f*bias + 0.4f*(dif+bias);
		}
		else
		{
			trialFitness = negFitnesses[solutionPosID];
			if(trialFitness BETTER_THAN fitnesses[solutionPosID])
			{
				negBetter = true;
				bias = bias - 0.4f*(dif+bias);
			}
		}

		if(posBetter || negBetter)
		{
			successes[solutionPosID]++;
			fails[solutionPosID] = 0;
			biases[solutionPosID] = bias;
			fitnesses[solutionPosID] = trialFitness;
			
		}
		else
		{
			successes[solutionPosID] = 0;
			fails[solutionPosID]++;
		}
",3.745967741935484
"
		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(
							""//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		selenium.selectFrame(
			""//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe"");
		selenium.type(""//body"",
			RuntimeVariables.replace(""WCD Web Content Content""));
		selenium.selectFrame(""relative=top"");
		selenium.clickAt(""//a[@id='_15_abstractLink']"",
			RuntimeVariables.replace(""Abstract""));

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}
",3.1772151898734178
" */
public class AddAddress1MyAccountTest extends BaseTestCase {
	public void testAddAddress1MyAccount() throws Exception {
		selenium.open(""/web/guest/home"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}
",3.459016393442623
"		    	
		    	String	temp = """";
		    	
		    	for (int i=0;i<library_path.length();i++){
		    		
		    		char	c = library_path.charAt(i);
		    		
		    		if ( c != '""' ){
		    			
		    			temp += c;
		    			
		    		}else{
		    			
		    			changed	= true;
		    		}
		    	}
		    	
		    	library_path	= temp;
		    	
		    		// remove trailing separator chars if they exist as they stuff up
		    		// the following ""
		    	
		    	while( library_path.endsWith(File.separator)){
		    	
		    		changed = true;
		    		
		    		library_path = library_path.substring( 0, library_path.length()-1 );
		    	}
		    	
		    	if ( changed ){
",3.4110169491525424
"		return (Address)message.get(_ADDRESS);
	}

	public static ClusterLink getClusterLink() {
		if ((_clusterLink == null) || !_clusterLink.isEnabled()) {
			if (_log.isWarnEnabled()) {
				_log.warn(""ClusterLinkUtil has not been initialized"");
			}

			return null;
		}

		return _clusterLink;
	}

	public static List<Address> getLocalTransportAddresses() {
		if ((_clusterLink == null) || !_clusterLink.isEnabled()) {
			if (_log.isWarnEnabled()) {
				_log.warn(""ClusterLinkUtil has not been initialized"");
			}

			return Collections.emptyList();
		}

		return _clusterLink.getLocalTransportAddresses();
	}

	public static List<Address> getTransportAddresses(Priority priority) {
		if ((_clusterLink == null) || !_clusterLink.isEnabled()) {
			if (_log.isWarnEnabled()) {
				_log.warn(""ClusterLinkUtil has not been initialized"");
			}

			return Collections.emptyList();
		}

		return _clusterLink.getTransportAddresses(priority);
	}

	public static boolean isForwardMessage(Message message) {
		return message.getBoolean(CLUSTER_FORWARD_MESSAGE);
	}

	public static void sendMulticastMessage(
		Message message, Priority priority) {

		if ((_clusterLink == null) || !_clusterLink.isEnabled()) {
			if (_log.isWarnEnabled()) {
				_log.warn(""ClusterLinkUtil has not been initialized"");
			}
",3.129032258064516
"				}
			}
		}
	}
	
	protected int
	isBuddy(
		Peer		peer )
	{
		String	peer_ip = peer.getIp();
",2.0458715596330275
"		Category category );
		
  /**
   * A category has been removed from the CategoryManager
   * @param category Category that was removed
   */  
	public void
	categoryRemoved(
		Category category );
",3.054621848739496
"
/**
 * @author Brian Wing Shun Chan
 */
public class PluginUtil {

	public static <P extends Plugin> List<P> restrictPlugins(
			List<P> plugins, long companyId, long userId)
		throws SystemException {

		List<P> visiblePlugins = new ArrayList<P>(plugins.size());

		for (P plugin : plugins) {
			PluginSetting pluginSetting =
				PluginSettingLocalServiceUtil.getPluginSetting(
					companyId, plugin.getPluginId(), plugin.getPluginType());

			if (pluginSetting.isActive() &&
				pluginSetting.hasPermission(userId)) {

				visiblePlugins.add(plugin);
			}
		}

		return visiblePlugins;
	}

	public static <P extends Plugin> List<P> restrictPlugins(
			List<P> plugins, User user)
		throws SystemException {
",3.321285140562249
"	public void testCreate() throws Exception {
		long pk = nextLong();

		SCProductVersion scProductVersion = _persistence.create(pk);

		assertNotNull(scProductVersion);

		assertEquals(scProductVersion.getPrimaryKey(), pk);
	}

	public void testRemove() throws Exception {
		SCProductVersion newSCProductVersion = addSCProductVersion();

		_persistence.remove(newSCProductVersion);

		SCProductVersion existingSCProductVersion = _persistence.fetchByPrimaryKey(newSCProductVersion.getPrimaryKey());

		assertNull(existingSCProductVersion);
	}

	public void testUpdateNew() throws Exception {
		addSCProductVersion();
	}

	public void testUpdateExisting() throws Exception {
		long pk = nextLong();

		SCProductVersion newSCProductVersion = _persistence.create(pk);

		newSCProductVersion.setCompanyId(nextLong());

		newSCProductVersion.setUserId(nextLong());

		newSCProductVersion.setUserName(randomString());

		newSCProductVersion.setCreateDate(nextDate());

		newSCProductVersion.setModifiedDate(nextDate());

		newSCProductVersion.setProductEntryId(nextLong());

		newSCProductVersion.setVersion(randomString());

		newSCProductVersion.setChangeLog(randomString());

		newSCProductVersion.setDownloadPageURL(randomString());

		newSCProductVersion.setDirectDownloadURL(randomString());

		newSCProductVersion.setRepoStoreArtifact(randomBoolean());
",3.2231404958677685
"									""//div[@class='lfr-component lfr-menu-list']/ul/li[3]/a"")) {
							break;
						}
					}
					catch (Exception e) {
					}

					Thread.sleep(1000);
				}

				selenium.click(RuntimeVariables.replace(
						""//div[@class='lfr-component lfr-menu-list']/ul/li[3]/a""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				assertTrue(selenium.getConfirmation()
								   .matches(""^Are you sure you want to delete this[\\s\\S]$""));

			case 4:

				boolean bookmarksFolder4Present = selenium.isElementPresent(
						""//td[4]/span/ul/li/strong/a"");

				if (!bookmarksFolder4Present) {
					label = 5;

					continue;
				}

				selenium.clickAt(""//td[4]/span/ul/li/strong/a"",
					RuntimeVariables.replace(""""));
",3.1714285714285717
"package org.bouncycastle.jce;

import java.util.Enumeration;

import org.bouncycastle.asn1.x9.X962NamedCurves;
import org.bouncycastle.asn1.x9.X9ECParameters;
import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;

/**
 * a table of locally supported named curves.
 */
public class ECNamedCurveTable
{
    /**
     * return a parameter spec representing the passed in named
     * curve. The routine returns null if the curve is not present.
     * 
     * @param name the name of the curve requested
     * @return a parameter spec for the curve, null if it is not available.
     */
    public static ECNamedCurveParameterSpec getParameterSpec(
        String  name)
    {
        X9ECParameters  ecP = X962NamedCurves.getByName(name);
        if (ecP == null)
        {
            return null;
        }

        return new ECNamedCurveParameterSpec(
                                        name,
                                        ecP.getCurve(),
                                        ecP.getG(),
                                        ecP.getN(),
                                        ecP.getH(),
                                        ecP.getSeed());

    }

    /**
     * return an enumeration of the names of the available curves.
     *
     * @return an enumeration of the names of the available curves.
     */
    public static Enumeration getNames()
    {
        return X962NamedCurves.getNames();
    }
",3.935483870967742
"package net.sourceforge.squirrel_sql.client.gui.db;

import javax.swing.JFrame;

import net.sourceforge.squirrel_sql.client.ApplicationArguments;
import net.sourceforge.squirrel_sql.client.gui.db.aliasproperties.ConnectionPropertiesPanel;

public class ConnectionPropertiesPanelTestUI {

	
	
    /**
     * @param args
     */
    public static void main(String[] args) {
        ApplicationArguments.initialize(new String[] {});
        
        
        final JFrame frame = new JFrame(""Test ConnectionPropertiesPanel"");

        SQLAliasConnectionProperties props = new SQLAliasConnectionProperties();
        
        ConnectionPropertiesPanel panel = new ConnectionPropertiesPanel(props);
        
        frame.getContentPane().add(panel);
        frame.setSize(500,300);
        frame.setVisible(true);
        
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
",3.865079365079365
"				if (selenium.isVisible(
							""//td[@id='cke_contents__19_editor']/iframe"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",3.0118577075098814
"/**
 * Copyright (c) 2000-2012 Liferay, Inc. All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */

package com.liferay.portal.sharepoint.methods;

import com.liferay.portal.sharepoint.ResponseElement;
import com.liferay.portal.sharepoint.SharepointRequest;
import com.liferay.portal.sharepoint.SharepointStorage;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Bruno Farache
 */
public class UncheckoutDocumentMethodImpl extends BaseMethodImpl {

	public String getMethodName() {
		return _METHOD_NAME;
	}

	@Override
	public String getRootPath(SharepointRequest sharepointRequest) {
		return sharepointRequest.getParameterValue(""document_name"");
	}

	@Override
	protected List<ResponseElement> getElements(
			SharepointRequest sharepointRequest)
		throws Exception {

		List<ResponseElement> elements = new ArrayList<ResponseElement>();

		SharepointStorage storage = sharepointRequest.getSharepointStorage();

		elements.add(storage.getDocumentTree(sharepointRequest));

		return elements;
	}
",3.661157024793389
"	getLeecherCount();
	
		/**
		 * Gives access to the number of peers that have failed NAT checks, 0 if NAT checking
		 * is disabled.
		 * @return
		 */
	
	public int
	getBadNATCount();
",3.475806451612903
"			""8"", ""com.liferay.portlet.calendar"",
			new String[] {""ADD_EVENT"", ""EXPORT_ALL_EVENTS""});

		updatePortletPermissions(
			""20"", ""com.liferay.portlet.documentlibrary"",
			new String[] {""ADD_FOLDER""});

		updatePortletPermissions(
			""31"", ""com.liferay.portlet.imagegallery"",
			new String[] {""ADD_FOLDER""});

		updatePortletPermissions(
			""15"", ""com.liferay.portlet.journal"",
			new String[] {
				""ADD_ARTICLE"", ""ADD_FEED"", ""ADD_STRUCTURE"", ""ADD_TEMPLATE"",
				""APPROVE_ARTICLE""
			});

		updatePortletPermissions(
			""19"", ""com.liferay.portlet.messageboards"",
			new String[] {""ADD_CATEGORY"", ""BAN_USER""});

		updatePortletPermissions(
			""25"", ""com.liferay.portlet.polls"", new String[] {""ADD_QUESTION""});

		updatePortletPermissions(
			""34"", ""com.liferay.portlet.shopping"",
			new String[] {""ADD_CATEGORY"", ""MANAGE_COUPONS"", ""MANAGE_ORDERS""});

		updatePortletPermissions(
			""98"", ""com.liferay.portlet.softwarecatalog"",
			new String[] {""ADD_FRAMEWORK_VERSION"", ""ADD_PRODUCT_ENTRY""});

		updatePortletPermissions(
			""99"", ""com.liferay.portlet.tags"",
			new String[] {""ADD_ENTRY"", ""ADD_VOCABULARY""});

		updatePortletPermissions(
			""36"", ""com.liferay.portlet.wiki"", new String[] {""ADD_NODE""});
	}

	protected Object[] getLayout(long plid) throws Exception {
		Connection con = null;
		PreparedStatement ps = null;
		ResultSet rs = null;

		try {
			con = DataAccess.getConnection();

			ps = con.prepareStatement(_GET_LAYOUT);
",3.1219512195121952
"package net.sourceforge.squirrel_sql.plugins.graph;

import java.awt.*;

public class ConnectionPoints
{
   Point[] points;
   boolean pointsAreLeftOfWindow;

",4.148
"						""_2_announcementsTypetestEmailCheckbox"");

				if (testEmailChecked) {
					label = 6;

					continue;
				}

				selenium.clickAt(""_2_announcementsTypetestEmailCheckbox"",
					RuntimeVariables.replace(""""));
",3.1875
"	public void setCompanyId(long companyId);

	/**
	 * Returns the user ID of this meetups registration.
	 *
	 * @return the user ID of this meetups registration
	 */
	public long getUserId();

	/**
	 * Sets the user ID of this meetups registration.
	 *
	 * @param userId the user ID of this meetups registration
	 */
	public void setUserId(long userId);

	/**
	 * Returns the user uuid of this meetups registration.
	 *
	 * @return the user uuid of this meetups registration
	 * @throws SystemException if a system exception occurred
	 */
	public String getUserUuid() throws SystemException;

	/**
	 * Sets the user uuid of this meetups registration.
	 *
	 * @param userUuid the user uuid of this meetups registration
	 */
	public void setUserUuid(String userUuid);
",4.171875
"		if (name == null) {
			throw new IllegalArgumentException();
		}

		_events.add(new EventImpl(name.getLocalPart(), name, value));
	}

	public void setEvent(String name, Serializable value) {
		if (name == null) {
			throw new IllegalArgumentException();
		}

		setEvent(new QName(getDefaultNamespace(), name), value);
	}

	public void setPortletMode(PortletMode portletMode)
		throws PortletModeException {

		if (_redirectLocation != null) {
			throw new IllegalStateException();
		}

		if (!_portletRequestImpl.isPortletModeAllowed(portletMode)) {
			throw new PortletModeException(portletMode.toString(), portletMode);
		}

		try {
			_portletMode = PortalUtil.updatePortletMode(
				_portletName, _user, _layout, portletMode,
				_portletRequestImpl.getHttpServletRequest());
",3.2519083969465647
"			_instance._disconnect();
		}
	}

	public static void send(String to, String msg) {
		_instance._send(to, msg);
	}

	public void update(Observable obs, Object obj) {
		_connecting = false;
",3.70566037735849
"				WorkflowConstants.CONTEXT_ENTRY_CLASS_NAME));

		if (workflowContext.containsKey(
				WorkflowConstants.CONTEXT_ENTRY_CLASS_PK)) {

			kaleoInstanceToken.setClassPK(
				GetterUtil.getLong(
					(String)workflowContext.get(
						WorkflowConstants.CONTEXT_ENTRY_CLASS_PK)));
		}
",2.764940239043825
"/**
 * Copyright (c) 2000-2012 Liferay, Inc. All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */

package com.liferay.portal.workflow.kaleo.runtime.util;

import com.liferay.portal.kernel.json.JSONFactoryUtil;
import com.liferay.portal.kernel.json.JSONObject;
import com.liferay.portal.service.ServiceContext;
import com.liferay.portal.workflow.kaleo.model.KaleoInstanceToken;
import com.liferay.portal.workflow.kaleo.model.KaleoTaskInstanceToken;
import com.liferay.portal.workflow.kaleo.runtime.ExecutionContext;
import com.liferay.portal.workflow.kaleo.service.KaleoInstanceTokenLocalServiceUtil;
import com.liferay.portal.workflow.kaleo.service.KaleoTaskInstanceTokenLocalServiceUtil;
import com.liferay.portal.workflow.kaleo.util.WorkflowContextUtil;

import java.io.Serializable;

import java.util.Map;
",3.879377431906615
"
		long fileEntryTypeId = ParamUtil.getLong(
			serviceContext, ""fileEntryTypeId"", -1L);
		Map<String, Fields> fieldsMap = getFieldsMap(
			serviceContext, fileEntryTypeId);

		DLFileEntry dlFileEntry = dlFileEntryLocalService.updateFileEntry(
			userId, fileEntryId, sourceFileName, mimeType, title, description,
			changeLog, majorVersion, fileEntryTypeId, fieldsMap, null, is, size,
			serviceContext);
",2.8780487804878048
"	 */
	public UserFinder getUserFinder() {
		return userFinder;
	}

	/**
	 * Sets the user finder.
	 *
	 * @param userFinder the user finder
	 */
	public void setUserFinder(UserFinder userFinder) {
		this.userFinder = userFinder;
	}

	/**
	 * Returns the asset entry local service.
	 *
	 * @return the asset entry local service
	 */
	public AssetEntryLocalService getAssetEntryLocalService() {
		return assetEntryLocalService;
	}

	/**
	 * Sets the asset entry local service.
	 *
	 * @param assetEntryLocalService the asset entry local service
	 */
	public void setAssetEntryLocalService(
		AssetEntryLocalService assetEntryLocalService) {
		this.assetEntryLocalService = assetEntryLocalService;
	}

	/**
	 * Returns the asset entry remote service.
	 *
	 * @return the asset entry remote service
	 */
	public AssetEntryService getAssetEntryService() {
		return assetEntryService;
	}

	/**
	 * Sets the asset entry remote service.
	 *
	 * @param assetEntryService the asset entry remote service
	 */
	public void setAssetEntryService(AssetEntryService assetEntryService) {
		this.assetEntryService = assetEntryService;
	}
",4.127572016460905
"public abstract class AliasAction extends SquirrelAction
{
   /** Logger for this class. */
   private static ILogger s_log =
      LoggerController.createLogger(DeleteAliasAction.class);
   /** Internationalized strings for this class. */
   private static final StringManager s_stringMgr =
       StringManagerFactory.getStringManager(DeleteAliasAction.class);

   public AliasAction(IApplication app)
   {
      super(app);
   }

   protected void moveToFrontAndSelectAliasFrame()
   {
      IApplication app = getApplication();
      AliasesListInternalFrame tw = app.getWindowManager().getAliasesListInternalFrame();
      tw.moveToFront();
      try
      {
         tw.setSelected(true);
      }
      catch (PropertyVetoException ex)
      {
            //i18n[DeleteAliasAction.error.selectingwindow=Error selecting window]
         s_log.error(s_stringMgr.getString(""DeleteAliasAction.error.selectingwindow""), ex);
      }
   }
",3.401639344262295
"		DownloadListener	l )
	{
	}

	public void 
	addCompletionListener(
		DownloadCompletionListener l ) 
	{
		notSupported();
	}
	
	public void 
	removeCompletionListener(
		DownloadCompletionListener l ) 
	{
		notSupported();
	}
	
	public void
	addTrackerListener(
		DownloadTrackerListener	l )
	{
	}

	public void 
	addTrackerListener(
		DownloadTrackerListener l, 
		boolean immediateTrigger)
	{
	}
  
	public void
	removeTrackerListener(
		DownloadTrackerListener	l )
	{
	}

	public void
	addDownloadWillBeRemovedListener(
		DownloadWillBeRemovedListener	l )
	{
		notSupported();
	}

	public void
	removeDownloadWillBeRemovedListener(
		DownloadWillBeRemovedListener	l )
	{
		notSupported();
	}
",3.071129707112971
" */
public class AuthTokenWrapper implements AuthToken {

	public AuthTokenWrapper(AuthToken authToken) {
		_authToken = authToken;
		_originalAuthToken = authToken;
	}

	public void check(HttpServletRequest request) throws PortalException {
		_authToken.check(request);
	}

	public String getToken(HttpServletRequest request) {
		return _authToken.getToken(request);
	}

	public String getToken(
		HttpServletRequest request, long plid, String portletId) {

		return _authToken.getToken(request, plid, portletId);
	}

	public void setAuthToken(AuthToken authToken) {
		if (authToken == null) {
			_authToken = _originalAuthToken;
		}
		else {
			_authToken = authToken;
		}
	}
",3.57429718875502
"		}
		catch (Exception e) {
			_log.error(e, e);

			throw new RemoteException(e.getMessage());
		}
	}

	public static void testCounterIncrement_Rollback()
		throws RemoteException {
		try {
			PortalServiceUtil.testCounterIncrement_Rollback();
		}
		catch (Exception e) {
			_log.error(e, e);

			throw new RemoteException(e.getMessage());
		}
	}

	public static void testDeleteClassName() throws RemoteException {
		try {
			PortalServiceUtil.testDeleteClassName();
		}
		catch (Exception e) {
			_log.error(e, e);

			throw new RemoteException(e.getMessage());
		}
	}
",3.207792207792208
"	public long getClassPK();

	/**
	 * Sets the class p k of this expando row.
	 *
	 * @param classPK the class p k of this expando row
	 */
	public void setClassPK(long classPK);

	public boolean isNew();
",3.5319148936170213
"
		Date createDate = getCreateDate();

		if (createDate != null) {
			passwordPolicyCacheModel.createDate = createDate.getTime();
		}
		else {
			passwordPolicyCacheModel.createDate = Long.MIN_VALUE;
		}

		Date modifiedDate = getModifiedDate();

		if (modifiedDate != null) {
			passwordPolicyCacheModel.modifiedDate = modifiedDate.getTime();
		}
		else {
			passwordPolicyCacheModel.modifiedDate = Long.MIN_VALUE;
		}

		passwordPolicyCacheModel.defaultPolicy = getDefaultPolicy();

		passwordPolicyCacheModel.name = getName();

		String name = passwordPolicyCacheModel.name;

		if ((name != null) && (name.length() == 0)) {
			passwordPolicyCacheModel.name = null;
		}

		passwordPolicyCacheModel.description = getDescription();
",3.3836206896551726
"				if (selenium.isVisible(
							""link=Web Content Display Permissions Page"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",2.7782608695652176
"		throws com.liferay.portal.kernel.exception.PortalException,
			com.liferay.portal.kernel.exception.SystemException;

	public void deleteEntry(long entryId)
		throws com.liferay.portal.kernel.exception.PortalException,
			com.liferay.portal.kernel.exception.SystemException;

	@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
	public java.util.List<com.liferay.portlet.bookmarks.model.BookmarksEntry> getEntries(
		long groupId, long folderId, int start, int end)
		throws com.liferay.portal.kernel.exception.SystemException;

	@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
	public java.util.List<com.liferay.portlet.bookmarks.model.BookmarksEntry> getEntries(
		long groupId, long folderId, int start, int end,
		com.liferay.portal.kernel.util.OrderByComparator orderByComparator)
		throws com.liferay.portal.kernel.exception.SystemException;

	@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
	public int getEntriesCount(long groupId, long folderId)
		throws com.liferay.portal.kernel.exception.SystemException;

	@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
	public com.liferay.portlet.bookmarks.model.BookmarksEntry getEntry(
		long entryId)
		throws com.liferay.portal.kernel.exception.PortalException,
			com.liferay.portal.kernel.exception.SystemException;

	@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
	public int getFoldersEntriesCount(long groupId,
		java.util.List<java.lang.Long> folderIds)
		throws com.liferay.portal.kernel.exception.SystemException;

	@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
	public java.util.List<com.liferay.portlet.bookmarks.model.BookmarksEntry> getGroupEntries(
		long groupId, int start, int end)
		throws com.liferay.portal.kernel.exception.SystemException;

	@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
	public java.util.List<com.liferay.portlet.bookmarks.model.BookmarksEntry> getGroupEntries(
		long groupId, long userId, int start, int end)
		throws com.liferay.portal.kernel.exception.SystemException;

	@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
	public int getGroupEntriesCount(long groupId)
		throws com.liferay.portal.kernel.exception.SystemException;

	@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
	public int getGroupEntriesCount(long groupId, long userId)
		throws com.liferay.portal.kernel.exception.SystemException;
",1.991416309012876
"
import com.liferay.portalweb.portal.BaseTestCase;
import com.liferay.portalweb.portal.util.RuntimeVariables;

/**
 * @author Brian Wing Shun Chan
 */
public class ViewDeleteDLDocumentTypeTest extends BaseTestCase {
	public void testViewDeleteDLDocumentType() throws Exception {
		selenium.open(""/web/guest/home/"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""link=Documents and Media Test Page"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		selenium.clickAt(""link=Documents and Media Test Page"",
			RuntimeVariables.replace(""Documents and Media Test Page""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		Thread.sleep(5000);
		assertFalse(selenium.isElementPresent(
				""//div[@class='lfr-component lfr-menu-list']/ul/li[10]/a""));
		selenium.open(""/web/guest/home/"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""link=Documents and Media Test Page"")) {
					break;
				}
			}
			catch (Exception e) {
			}
",3.2297872340425533
"			try {
				if (selenium.isVisible(""link=Sign Out"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		selenium.clickAt(""link=Sign Out"", RuntimeVariables.replace(""Sign Out""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""//input[@value='Sign In']"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",3.439655172413793
"public class PluginGlobalPreferencesTab implements IGlobalPreferencesPanel {

    protected PluginQueryTokenizerPreferencesPanel _prefs = null;

    private JScrollPane _myscrolledPanel;

    private String _title = null;
    
    private String _hint = null;
    
    public PluginGlobalPreferencesTab(PluginQueryTokenizerPreferencesPanel prefsPanel) {
        _myscrolledPanel = new JScrollPane(prefsPanel);
        _prefs = prefsPanel;
    }

    public void initialize(IApplication app) {
        /* Do Nothing */
    }

    public void uninitialize(IApplication app) {
        /* Do Nothing */
    }

    public void applyChanges() {
        if (_prefs != null) {
            _prefs.applyChanges();
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see net.sourceforge.squirrel_sql.client.util.IOptionPanel#getTitle()
     */
    public String getTitle() {
        return _title;
    }

    public void setTitle(String title) {
        this._title = title;
    }
    
    /*
     * (non-Javadoc)
     * 
     * @see net.sourceforge.squirrel_sql.client.util.IOptionPanel#getHint()
     */
    public String getHint() {
        return _hint;
    }
",3.653508771929825
"			layoutRevision.setCreateDate(serviceContext.getCreateDate(now));
			layoutRevision.setModifiedDate(serviceContext.getModifiedDate(now));
			layoutRevision.setLayoutSetBranchId(
				oldLayoutRevision.getLayoutSetBranchId());
			layoutRevision.setParentLayoutRevisionId(
				oldLayoutRevision.getLayoutRevisionId());
			layoutRevision.setHead(false);
			layoutRevision.setLayoutBranchId(layoutBranchId);
			layoutRevision.setPlid(oldLayoutRevision.getPlid());
			layoutRevision.setPrivateLayout(
				oldLayoutRevision.isPrivateLayout());
			layoutRevision.setName(name);
			layoutRevision.setTitle(title);
			layoutRevision.setDescription(description);
			layoutRevision.setKeywords(keywords);
			layoutRevision.setRobots(robots);
			layoutRevision.setTypeSettings(typeSettings);

			if (iconImage) {
				layoutRevision.setIconImage(iconImage);
				layoutRevision.setIconImageId(iconImageId);
			}

			layoutRevision.setThemeId(themeId);
			layoutRevision.setColorSchemeId(colorSchemeId);
			layoutRevision.setWapThemeId(wapThemeId);
			layoutRevision.setWapColorSchemeId(wapColorSchemeId);
			layoutRevision.setCss(css);
			layoutRevision.setStatus(WorkflowConstants.STATUS_DRAFT);
			layoutRevision.setStatusDate(serviceContext.getModifiedDate(now));
",2.4827586206896552
"				selenium.clickAt(""link=Search All Users"",
					RuntimeVariables.replace(""Search All Users""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();

				boolean advancedVisible = selenium.isVisible(
						""link=Advanced \u00bb"");

				if (!advancedVisible) {
					label = 3;
",3.1012145748987856
"		return _dataType;
	}

	public int getPrecision()
	{
		return _precision;
	}

	public String getLiteralPrefix()
	{
		return _literalPrefix;
	}

	public String getLiteralSuffix()
	{
		return _literalSuffix;
	}

	public String getCreateParams()
	{
		return _createParams;
	}

    /**
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result + (_autoIncrement ? 1231 : 1237);
        return result;
    }

    /**
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (!super.equals(obj))
            return false;
        if (getClass() != obj.getClass())
            return false;
        final DataTypeInfo other = (DataTypeInfo) obj;
        if (!getSimpleName().equals(other.getSimpleName()))
            return false;
        return true;
    }
",3.606425702811245
"
package org.gudy.azureus2.pluginsimpl.local.update;

/**
 * @author parg
 *
 */

import java.io.*;

import org.gudy.azureus2.platform.PlatformManager;
import org.gudy.azureus2.platform.PlatformManagerCapabilities;
import org.gudy.azureus2.platform.PlatformManagerFactory;
import org.gudy.azureus2.plugins.update.*;

import org.gudy.azureus2.core3.util.*;
import org.gudy.azureus2.core3.internat.MessageText;
import org.gudy.azureus2.core3.logging.*;

import com.aelitis.azureus.core.update.AzureusRestarter;
import com.aelitis.azureus.core.update.AzureusRestarterFactory;

public class 
UpdateInstallerImpl
	implements UpdateInstaller
{
		// change these and you'll need to change the Updater!!!!
	
	protected static final String	UPDATE_DIR 	= ""updates"";
	protected static final String	ACTIONS		= ""install.act"";
	
	protected static AEMonitor	class_mon 	= new AEMonitor( ""UpdateInstaller:class"" );

	private UpdateManagerImpl	manager;
	private File				install_dir;
	
	protected static void
	checkForFailedInstalls(
		UpdateManagerImpl	manager )
	{
		try{
			File	update_dir = new File( manager.getUserDir() + File.separator + UPDATE_DIR );
			
			File[]	dirs = update_dir.listFiles();
			
			if ( dirs != null ){
				
				boolean	found_failure = false;
				
				String	files = """";
",2.7991967871485945
"
				boolean suborganization2Present = selenium.isElementPresent(
						""//td[4]/span/ul/li/strong/a"");

				if (!suborganization2Present) {
					label = 3;

					continue;
				}

				selenium.clickAt(""//input[@name='_125_allRowIds']"",
					RuntimeVariables.replace(""All Rows""));
				selenium.click(RuntimeVariables.replace(
						""//input[@value='Delete']""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				assertTrue(selenium.getConfirmation()
								   .matches(""^Are you sure you want to delete this[\\s\\S]$""));

			case 3:
				selenium.clickAt(""link=Users and Organizations"",
					RuntimeVariables.replace(""Users and Organizations""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				selenium.type(""//input[@id='_125_keywords']"",
					RuntimeVariables.replace(""Selenium""));
				selenium.click(RuntimeVariables.replace(
						""//input[@value='Search']""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				selenium.clickAt(""//input[@name='_125_rowIds']"",
					RuntimeVariables.replace(""Row""));
				selenium.click(RuntimeVariables.replace(
						""//input[@value='Delete']""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				assertTrue(selenium.getConfirmation()
								   .matches(""^Are you sure you want to delete this[\\s\\S]$""));
				selenium.type(""//input[@id='_125_keywords']"",
					RuntimeVariables.replace(""Test""));
				selenium.click(RuntimeVariables.replace(
						""//input[@value='Search']""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();

				boolean organization3Present = selenium.isElementPresent(
						""//td[4]/span/ul/li/strong/a"");

				if (!organization3Present) {
					label = 9;
",2.2674897119341564
"		throws PortalException, SystemException {

		for (PollsQuestion question :
				pollsQuestionPersistence.findByGroupId(groupId)) {

			deleteQuestion(question);
		}
	}

	public PollsQuestion getQuestion(long questionId)
		throws PortalException, SystemException {

		return pollsQuestionPersistence.findByPrimaryKey(questionId);
	}

	public List<PollsQuestion> getQuestions(long groupId)
		throws SystemException {

		return pollsQuestionPersistence.findByGroupId(groupId);
	}

	public List<PollsQuestion> getQuestions(long groupId, int start, int end)
		throws SystemException {

		return pollsQuestionPersistence.findByGroupId(groupId, start, end);
	}

	public int getQuestionsCount(long groupId) throws SystemException {
		return pollsQuestionPersistence.countByGroupId(groupId);
	}
",3.395833333333333
"	public String get(Object key) {
		String value = null;

		if (key != null) {
			FacesContext facesContext = FacesContext.getCurrentInstance();

			Locale locale = facesContext.getViewRoot().getLocale();

			if (locale == null) {
				locale = facesContext.getApplication().getDefaultLocale();
			}

			value = LanguageUtil.get(locale, key.toString());

			if (_log.isDebugEnabled()) {
				_log.debug(
					""{locale="" + locale + "", key="" + key + "", value="" + value);
			}
		}

		return value;
	}

	public boolean isEmpty() {
		throw new UnsupportedOperationException();
	}

	public Set<String> keySet() {
		throw new UnsupportedOperationException();
	}
",3.54320987654321
"		testSuite.addTestSuite(AddPortletMBTest.class);
		testSuite.addTestSuite(AddMBCategoryTest.class);
		testSuite.addTestSuite(AddMBMessage1Tag1Test.class);
		testSuite.addTestSuite(AddMBMessage2Tag2Test.class);
		testSuite.addTestSuite(AddMBMessage3Tag3Test.class);
		testSuite.addTestSuite(AddMBMessageATagTest.class);
		testSuite.addTestSuite(AddMBMessageBTagTest.class);
		testSuite.addTestSuite(AddMBMessageCTagTest.class);
		testSuite.addTestSuite(SearchTagsTest.class);
		testSuite.addTestSuite(ViewTagsTest.class);
",3.531496062992126
"		throws InstanceNotFoundException, MBeanRegistrationException {

		synchronized (_objectNameCache) {
			ObjectName objectName = _objectNameCache.get(objectNameCacheKey);

			if (objectName == null) {
				_mBeanServer.unregisterMBean(defaultObjectName);
			}
			else {
				_objectNameCache.remove(objectNameCacheKey);
",3.401639344262295
"				selenium.clickAt(""link=Control Panel"",
					RuntimeVariables.replace(""Control Panel""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				selenium.clickAt(""link=Sites"", RuntimeVariables.replace(""Sites""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				selenium.type(""//input[@id='_134_name']"",
					RuntimeVariables.replace(""Community""));
				selenium.clickAt(""//input[@value='Search']"",
					RuntimeVariables.replace(""Search""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();

				boolean community1Present = selenium.isElementPresent(
						""//span[@title='Actions']/ul/li/strong/a/span"");

				if (!community1Present) {
					label = 2;

					continue;
				}

				selenium.clickAt(""//span[@title='Actions']/ul/li/strong/a/span"",
					RuntimeVariables.replace(""Actions""));

				for (int second = 0;; second++) {
					if (second >= 90) {
						fail(""timeout"");
					}
",2.676348547717842
"	
	public long
	getInterval();
	
	public long
	getMinInterval();
	
	public int
	getTimeUntilNextUpdate();
",3.724
"
import com.liferay.portal.kernel.cal.DayAndPosition;
import com.liferay.portal.kernel.cal.Duration;
import com.liferay.portal.kernel.cal.Recurrence;

import java.util.Calendar;

/**
 * @author Douglas Wong
 */
public class RecurrenceMonthlyByDayTest extends RecurrenceTestCase {

	public void testRecurrence() {
		Recurrence recurrence = getRecurrence(
			dtStart, durationOneHour, FRIDAY, 3, 1);

		Calendar beforeRecurrence = getCalendar(2008, FEBRUARY, 15, 22, 9);

		assertRecurrenceEquals(false, recurrence, beforeRecurrence);

		Calendar duringRecurrence1 = getCalendar(2008, FEBRUARY, 15, 22, 10);
		Calendar duringRecurrence2 = getCalendar(2008, MARCH, 21, 22, 15);

		assertRecurrenceEquals(true, recurrence, duringRecurrence1);
		assertRecurrenceEquals(true, recurrence, duringRecurrence2);

		Calendar afterRecurrence = getCalendar(2008, FEBRUARY, 15, 23, 10);

		assertRecurrenceEquals(false, recurrence, afterRecurrence);
	}
",3.686991869918699
"/**
 * Created on Sep 19, 2008
 *
 * Copyright 2008 Vuze, Inc.  All rights reserved.
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License only.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA 
 */
 
package org.gudy.azureus2.plugins.download;

/**
 * For registering columns, menus, etc with a datasource
 * @author TuxPaper
 * @created Sep 19, 2008
 *
 */
public interface DownloadTypeIncomplete
{

",3.9344262295081966
"
	/**
	 * Sets the org group permission finder.
	 *
	 * @param orgGroupPermissionFinder the org group permission finder
	 */
	public void setOrgGroupPermissionFinder(
		OrgGroupPermissionFinder orgGroupPermissionFinder) {
		this.orgGroupPermissionFinder = orgGroupPermissionFinder;
	}
",3.280632411067194
"		com.liferay.portal.service.ServiceContext serviceContext)
		throws com.liferay.portal.kernel.exception.PortalException,
			com.liferay.portal.kernel.exception.SystemException {
		try {
			MethodKey methodKey = new MethodKey(LayoutSetPrototypeServiceUtil.class.getName(),
					""updateLayoutSetPrototype"",
					_updateLayoutSetPrototypeParameterTypes4);

			MethodHandler methodHandler = new MethodHandler(methodKey,
					layoutSetPrototypeId, nameMap, description, active,
					layoutsUpdateable, serviceContext);

			Object returnObj = null;

			try {
				returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler);
			}
			catch (Exception e) {
				if (e instanceof com.liferay.portal.kernel.exception.PortalException) {
					throw (com.liferay.portal.kernel.exception.PortalException)e;
				}

				if (e instanceof com.liferay.portal.kernel.exception.SystemException) {
					throw (com.liferay.portal.kernel.exception.SystemException)e;
				}

				throw new com.liferay.portal.kernel.exception.SystemException(e);
			}

			return (com.liferay.portal.model.LayoutSetPrototype)returnObj;
		}
		catch (com.liferay.portal.kernel.exception.SystemException se) {
			_log.error(se, se);

			throw se;
		}
	}

	public static com.liferay.portal.model.LayoutSetPrototype updateLayoutSetPrototype(
		HttpPrincipal httpPrincipal, long layoutSetPrototypeId,
		java.lang.String settings)
		throws com.liferay.portal.kernel.exception.PortalException,
			com.liferay.portal.kernel.exception.SystemException {
		try {
			MethodKey methodKey = new MethodKey(LayoutSetPrototypeServiceUtil.class.getName(),
					""updateLayoutSetPrototype"",
					_updateLayoutSetPrototypeParameterTypes5);

			MethodHandler methodHandler = new MethodHandler(methodKey,
					layoutSetPrototypeId, settings);
",2.612021857923497
"/**
 * Copyright (c) 2000-2012 Liferay, Inc. All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */

package com.liferay.portal.kernel.messaging.proxy;

import java.io.Serializable;

/**
 * @author Micha Kiener
 * @author Michael C. Han
 * @author Brian Wing Shun Chan
 */
public class ProxyResponse implements Serializable {

	public Exception getException() {
		return _exception;
	}

	public Object getResult() {
		return _result;
	}

	public boolean hasError() {
		if (_exception != null) {
			return true;
		}
		else {
			return false;
		}
	}

	public void setException(Exception exception) {
		_exception = exception;
	}

	public void setResult(Object result) {
		_result = result;
	}
",4.021505376344086
"				continue;
				
			}else if ( c == '\\' ){
				
				escape = true;
				
				continue;
			}
			
			if ( c == '""' || c == '\'' && ( i == 0 || chars[ i-1 ] != '\\' )){
				
				if ( quote == ' ' ){
						
					bit_contains_quotes = true;
					
					quote = c;
					
				}else if ( quote == c ){
										
					quote = ' ';
					
				}else{
					
					bit += c;
				}
			}else{
				
				if ( quote == ' ' ){
					
					if ( c == ' ' ){
",2.747422680412371
"		}
	}

	public void addBar_Rollback(java.lang.String text)
		throws com.liferay.portal.kernel.exception.SystemException {
		MethodHandler methodHandler = new MethodHandler(_addBar_RollbackMethodKey17,
				ClpSerializer.translateInput(text));

		try {
			_classLoaderProxy.invoke(methodHandler);
		}
		catch (Throwable t) {
			if (t instanceof com.liferay.portal.kernel.exception.SystemException) {
				throw (com.liferay.portal.kernel.exception.SystemException)t;
			}

			if (t instanceof RuntimeException) {
				throw (RuntimeException)t;
			}
			else {
				throw new RuntimeException(t.getClass().getName() +
					"" is not a valid exception"");
			}
		}
	}

	public com.liferay.testtransaction.model.Bar addBar_Success(
		java.lang.String text)
		throws com.liferay.portal.kernel.exception.SystemException {
		Object returnObj = null;

		MethodHandler methodHandler = new MethodHandler(_addBar_SuccessMethodKey18,
				ClpSerializer.translateInput(text));

		try {
			returnObj = _classLoaderProxy.invoke(methodHandler);
		}
		catch (Throwable t) {
			if (t instanceof com.liferay.portal.kernel.exception.SystemException) {
				throw (com.liferay.portal.kernel.exception.SystemException)t;
			}

			if (t instanceof RuntimeException) {
				throw (RuntimeException)t;
			}
			else {
				throw new RuntimeException(t.getClass().getName() +
					"" is not a valid exception"");
			}
		}
",2.751322751322751
"public class SWTSkinPropertiesImpl
	extends SkinPropertiesImpl
	implements SWTSkinProperties
{
	private static Map colorMap = new LightHashMap();

	/**
	 * @param skinPath
	 * @param mainSkinFile
	 */
	public SWTSkinPropertiesImpl(ClassLoader classLoader, String skinPath, String mainSkinFile) {
		super(classLoader, skinPath, mainSkinFile);
	}

	/**
	 * 
	 */
	public SWTSkinPropertiesImpl() {
		super();
	}

	// @see com.aelitis.azureus.ui.swt.skin.SWTSkinProperties#getColor(java.lang.String)
	public Color getColor(String sID) {
		Color color;
		if (colorMap.containsKey(sID)) {
			return (Color) colorMap.get(sID);
		}

		try {
			int[] rgb = getColorValue(sID);
			if (rgb[0] > -1) {
				color = ColorCache.getColor(Utils.getDisplay(), rgb[0], rgb[1], rgb[2]);
			} else {
				color = ColorCache.getColor(Utils.getDisplay(), getStringValue(sID));
			}
		} catch (Exception e) {
			//				IMP.getLogger().log(LoggerChannel.LT_ERROR,
			//						""Failed loading color : color."" + colorNames[i]);
			color = null;
		}

		colorMap.put(sID, color);

		return color;
	}

	public void clearCache() {
		super.clearCache();
		colorMap.clear();
	}
",3.3825136612021858
"		selenium.clickAt(""link=Control Panel"",
			RuntimeVariables.replace(""Control Panel""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		selenium.clickAt(""link=Users and Organizations"",
			RuntimeVariables.replace(""Users and Organizations""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		selenium.type(""//input[@id='_125_keywords']"",
			RuntimeVariables.replace(""selen01""));
		selenium.clickAt(""//input[@value='Search']"",
			RuntimeVariables.replace(""Search""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		selenium.clickAt(""//td[2]/a"", RuntimeVariables.replace(""User Name""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""//a[@id='_125_phoneNumbersLink']"")) {
					break;
				}
			}
			catch (Exception e) {
			}
",2.764705882352941
"	 */
	public void setGadgetKey(String gadgetKey);

	/**
	 * Returns the service name of this o auth token.
	 *
	 * @return the service name of this o auth token
	 */
	@AutoEscape
	public String getServiceName();
",3.830687830687831
"    }

    abstract void encode(DEROutputStream out)
        throws IOException;

    public String toString()
    {
      return ""#""+new String(Hex.encode(string));
    }
",3.727722772277228
"      _app = app;
   }


	protected void paintComponent(Graphics g)
	{
		setPreferredSize(getRequiredSize());
		super.paintComponent(g);
	}

	public void remove(Component comp)
	{
		if (comp != null)
		{
			comp.removeComponentListener(_listener);
         super.remove(comp);
		}
		revalidate();
		repaint();
	}

	protected void addImpl(Component comp, Object constraints, int index)
	{
		if (comp != null)
		{
			comp.addComponentListener(_listener);
			revalidate();
		}
		super.addImpl(comp, constraints, index);
	}
",3.4507772020725387
"
		for (KaleoTimer model : models) {
			soapModels.add(toSoapModel(model));
		}

		return soapModels.toArray(new KaleoTimerSoap[soapModels.size()]);
	}

	public KaleoTimerSoap() {
	}
",3.59375
"import net.sourceforge.squirrel_sql.fw.util.ICommand;
import net.sourceforge.squirrel_sql.fw.util.Resources;
import net.sourceforge.squirrel_sql.fw.util.StringManager;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;
import net.sourceforge.squirrel_sql.plugins.refactoring.commands.AddAutoIncrementCommand;

public class AddAutoIncrementAction extends AbstractRefactoringAction
{
	private static final long serialVersionUID = -5316665324698095673L;

	/**
	 * Internationalized strings for this class.
	 */
	private static final StringManager s_stringMgr =
		StringManagerFactory.getStringManager(AddAutoIncrementAction.class);

	private static interface i18n
	{
		String ACTION_PART = s_stringMgr.getString(""AddAutoIncrementAction.actionPart"");

		String OBJECT_PART = s_stringMgr.getString(""Shared.tableObject"");

		String SINGLE_OBJECT_MESSAGE =
			s_stringMgr.getString(""Shared.singleObjectMessage"", OBJECT_PART, ACTION_PART);
	}

	public AddAutoIncrementAction(final IApplication app, final Resources rsrc)
	{
		super(app, rsrc);
	}
",3.4923076923076923
"			RuntimeVariables.replace(""Add""));

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(
							""//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		assertEquals(RuntimeVariables.replace(""Basic Document""),
			selenium.getText(
				""//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a""));
		selenium.clickAt(""//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a"",
			RuntimeVariables.replace(""Basic Document""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		selenium.type(""//input[@id='_20_file']"",
			RuntimeVariables.replace(
				""L:\\portal\\build\\portal-web\\test\\com\\liferay\\portalweb\\portlet\\documentlibrary\\dependencies\\test_document.txt""));
		selenium.type(""//input[@id='_20_title']"",
			RuntimeVariables.replace(""DL Folder Document Title""));
		selenium.type(""//textarea[@id='_20_description']"",
			RuntimeVariables.replace(""DL Folder Document Description""));
		selenium.clickAt(""//input[@value='Publish']"",
			RuntimeVariables.replace(""Publish""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""//div[@class='portlet-msg-success']"")) {
					break;
				}
			}
			catch (Exception e) {
			}
",2.5851063829787235
"				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		selenium.clickAt(""//div[@title='Knowledge Base Article']/p/a"",
			RuntimeVariables.replace(""Add""));
",3.510204081632653
"import com.liferay.portal.model.User;
import com.liferay.portal.security.permission.ActionKeys;
import com.liferay.portal.service.base.EmailAddressServiceBaseImpl;
import com.liferay.portal.service.permission.CommonPermissionUtil;

import java.util.List;

/**
 * @author Brian Wing Shun Chan
 * @author Alexander Chow
 */
public class EmailAddressServiceImpl extends EmailAddressServiceBaseImpl {

	public EmailAddress addEmailAddress(
			String className, long classPK, String address, int typeId,
			boolean primary)
		throws PortalException, SystemException {

		CommonPermissionUtil.check(
			getPermissionChecker(), className, classPK, ActionKeys.UPDATE);

		return emailAddressLocalService.addEmailAddress(
			getUserId(), className, classPK, address, typeId, primary);
	}

	public void deleteEmailAddress(long emailAddressId)
		throws PortalException, SystemException {

		EmailAddress emailAddress = emailAddressPersistence.findByPrimaryKey(
			emailAddressId);

		CommonPermissionUtil.check(
			getPermissionChecker(), emailAddress.getClassNameId(),
			emailAddress.getClassPK(), ActionKeys.UPDATE);

		emailAddressLocalService.deleteEmailAddress(emailAddressId);
	}

	public EmailAddress getEmailAddress(long emailAddressId)
		throws PortalException, SystemException {

		EmailAddress emailAddress = emailAddressPersistence.findByPrimaryKey(
			emailAddressId);

		CommonPermissionUtil.check(
			getPermissionChecker(), emailAddress.getClassNameId(),
			emailAddress.getClassPK(), ActionKeys.VIEW);

		return emailAddress;
	}
",3.327777777777778
"/**
 * @author Brian Wing Shun Chan
 */
public class DBUpgradeTags528TestSuite extends BaseTestSuite {

	public static Test suite() {
		TestSuite testSuite = new TestSuite();

		testSuite.addTest(LoginTests.suite());
		testSuite.addTest(TagsTestPlan.suite());
",3.82122905027933
"		find.append(""\\s*</array>.*"");
		value.append(""\n\t\t\t"");
		
		String match = ""(?s)(<key>"" + key + ""</key>\\s*<array>)(.*?)(</array>)"";
		
		setValue(find.toString(),match,value.toString());
	}
	
	private boolean 
	isValuePresent(
		String match )
	
		throws IOException
	{
		String fileContent = getFileContent();
		
		//System.out.println(""Searching for:\n"" + match);
		return fileContent.matches(match);
	}
	

	/**
	 * 
	 * @param find the regex expression to find if the value is already present
	 * @param match the regex expression that will match for the replace, it needs to capture 3 groups, the 2nd one being replaced by value
	 * @param value the value that replaces the 2nd match group
	 */
	private void 
	setValue(
		String find,
		String match,
		String value)
	
		throws IOException
	{
		String fileContent = getFileContent();
		
		if( !isValuePresent(find)) {
			//System.out.println(""Changing "" +plistFile);
			fileContent = fileContent.replaceFirst(match, ""$1""+value + ""$3"");
			setFileContent(fileContent);
			touchFile();
		}
	}
	
	private String 
	getFileContent()
		throws IOException
	{
		FileReader fr = null;
",3.3154761904761907
"   			return true;
   		}
   	}
      return false;
   }

	@Test
   public void testGetValueAt()
   {
   	for (int rowIdx = 0; rowIdx < classUnderTest.getRowCount(); rowIdx++) {
   		for (int colIdx = 0; colIdx < classUnderTest.getColumnCount(); colIdx++) {
   			assertNotNull(classUnderTest.getValueAt(rowIdx, colIdx));
   		}
   	}
   }

	@Test
   public void testGetValueAt_InvalidColumn()
   {
		try {
			classUnderTest.getValueAt(0, classUnderTest.getColumnCount());
			fail(""Expected an exception for call to getValue with a column that is one higher that the "" +
					""highest column index allowed by this table model"");
		} catch (IndexOutOfBoundsException e) {
			// This is acceptable
		} catch (IllegalArgumentException e) {
			// This is acceptable
		}
		
   }
",3.269461077844311
"import org.eclipse.sapphire.modeling.annotations.Type;
import org.eclipse.sapphire.modeling.annotations.ValidFileSystemResourceType;
import org.eclipse.sapphire.modeling.xml.annotations.XmlBinding;

/**
 * @author Gregory Amerson
 */
@GenerateImpl
public interface IPortalPropertiesFile extends IModelElement
{
",3.560693641618497
"					PropsKeys.XUGGLER_ENABLED, PropsValues.XUGGLER_ENABLED) ||
				_hasAudio(fileVersion)) {

				return;
			}

			if (_isGeneratePreview(fileVersion)) {
				File file = null;

				if (fileVersion instanceof LiferayFileVersion) {
					try {
						LiferayFileVersion liferayFileVersion =
							(LiferayFileVersion)fileVersion;

						file = liferayFileVersion.getFile(false);
					}
					catch (UnsupportedOperationException uoe) {
					}
				}

				if (file == null) {
					InputStream inputStream = fileVersion.getContentStream(
						false);

					FileUtil.write(audioTempFile, inputStream);

					file = audioTempFile;
				}

				try {
					_generateAudioXuggler(fileVersion, file, previewTempFile);
				}
				catch (Exception e) {
					_log.error(e, e);
				}
			}
		}
		catch (NoSuchFileEntryException nsfee) {
		}
		finally {
			_fileVersionIds.remove(fileVersion.getFileVersionId());

			FileUtil.delete(audioTempFile);
			FileUtil.delete(previewTempFile);
		}
	}

	private void _generateAudioXuggler(
			FileVersion fileVersion, File srcFile, File destFile)
		throws Exception {
",2.818713450292398
"		public LiferayDecorationsProvider(IRuntime adaptableObject) {
			// runtime = adaptableObject;
		}

		public ImageDescriptor getIcon() {
			return LiferayServerUIPlugin.imageDescriptorFromPlugin(
				LiferayServerUIPlugin.PLUGIN_ID, ""icons/e16/server.png"" );
		}

	}
",3.351851851851852
"import com.liferay.portal.kernel.exception.PortalException;

/**
 * @author Alexander Chow
 */
public class LockException extends PortalException {

	public LockException() {
		super();
	}
",3.6809815950920246
"		calendarImpl.setCalendarId(getCalendarId());
		calendarImpl.setGroupId(getGroupId());
		calendarImpl.setCompanyId(getCompanyId());
		calendarImpl.setUserId(getUserId());
		calendarImpl.setUserName(getUserName());
		calendarImpl.setCreateDate(getCreateDate());
		calendarImpl.setModifiedDate(getModifiedDate());
		calendarImpl.setResourceBlockId(getResourceBlockId());
		calendarImpl.setCalendarResourceId(getCalendarResourceId());
		calendarImpl.setName(getName());
		calendarImpl.setDescription(getDescription());
		calendarImpl.setColor(getColor());
		calendarImpl.setDefaultCalendar(getDefaultCalendar());

		calendarImpl.resetOriginalValues();

		return calendarImpl;
	}

	public int compareTo(Calendar calendar) {
		int value = 0;

		value = getName().compareTo(calendar.getName());

		if (value != 0) {
			return value;
		}

		return 0;
	}
",3.3067484662576687
"     */
    public void init(CipherParameters params)
        throws IllegalArgumentException;

    /**
     * Return the name of the algorithm the MAC implements.
     *
     * @return the name of the algorithm the MAC implements.
     */
    public String getAlgorithmName();

    /**
     * Return the block size for this cipher (in bytes).
     *
     * @return the block size for this cipher in bytes.
     */
	public int getMacSize();

    /**
     * add a single byte to the mac for processing.
     *
     * @param in the byte to be processed.
     * @exception IllegalStateException if the MAC is not initialised.
     */
	public void update(byte in)
        throws IllegalStateException;

    /**
     * @param in the array containing the input.
     * @param inOff the index in the array the data begins at.
     * @param len the length of the input starting at inOff.
     * @exception IllegalStateException if the MAC is not initialised.
     * @exception DataLengthException if there isn't enough data in in.
     */
	public void update(byte[] in, int inOff, int len)
        throws DataLengthException, IllegalStateException;

    /**
     * Compute the final statge of the MAC writing the output to the out
     * parameter.
     * <p>
     * doFinal leaves the MAC in the same state it was after the last init.
     *
     * @param out the array the MAC is to be output to.
     * @param outOff the offset into the out buffer the output is to start at.
     * @exception DataLengthException if there isn't enough space in out.
     * @exception IllegalStateException if the MAC is not initialised.
     */
	public int doFinal(byte[] out, int outOff)
        throws DataLengthException, IllegalStateException;
",3.8012048192771086
"	{
		DHTNATPuncher puncher = plugin.getDHT().getNATPuncher();
		
		if ( puncher == null ){
			
			return( null );
		}
		
		return( puncher.punch( ""Tunnel"", contact, null, null ));
	}
",3.338888888888889
"			WebKeys.MOBILE_DEVICE_RULES_RULE_EDITOR_JSP, editorJSP);

		long ruleGroupId = BeanParamUtil.getLong(
			rule, renderRequest, ""ruleGroupId"");

		MDRRuleGroup ruleGroup = MDRRuleGroupServiceUtil.getRuleGroup(
			ruleGroupId);

		renderRequest.setAttribute(
			WebKeys.MOBILE_DEVICE_RULES_RULE_GROUP, ruleGroup);

		return mapping.findForward(""portlet.mobile_device_rules.edit_rule"");
	}

	@Override
	public void serveResource(
			ActionMapping mapping, ActionForm form, PortletConfig portletConfig,
			ResourceRequest resourceRequest, ResourceResponse resourceResponse)
		throws Exception {

		long ruleId = ParamUtil.getLong(resourceRequest, ""ruleId"");

		if (ruleId > 0) {
			MDRRule rule = MDRRuleServiceUtil.fetchRule(ruleId);

			resourceRequest.setAttribute(
				WebKeys.MOBILE_DEVICE_RULES_RULE, rule);
		}

		String type = ParamUtil.getString(resourceRequest, ""type"");
",2.790960451977401
"            {
               continue;
            }

            SchemaLoadInfo schemaLoadInfo = new SchemaLoadInfo(addStringArrays(tableTypes, viewTypes));
            schemaLoadInfo.schemaName = _schemaDetails[i].getSchemaName();
            schemaLoadInfo.tableTypes = new String[0];

            if(SQLAliasSchemaDetailProperties.SCHEMA_LOADING_ID_DONT_LOAD !=_schemaDetails[i].getTable())
            {
               schemaLoadInfo.tableTypes = addStringArrays(schemaLoadInfo.tableTypes, tableTypes);
            }

            if(SQLAliasSchemaDetailProperties.SCHEMA_LOADING_ID_DONT_LOAD !=_schemaDetails[i].getView())
            {
               schemaLoadInfo.tableTypes = addStringArrays(schemaLoadInfo.tableTypes, viewTypes);
            }

            if(SQLAliasSchemaDetailProperties.SCHEMA_LOADING_ID_DONT_LOAD !=_schemaDetails[i].getProcedure())
            {
               schemaLoadInfo.loadProcedures = true;
            }
            else
            {
               schemaLoadInfo.loadProcedures = false;

            }

            schemaLoadInfos.add(schemaLoadInfo);
         }
",2.916201117318436
"
    private com.sap.engine.services.dc.wsgate.Option[] options;

    public Deploy() {
    }

    public Deploy(
           com.sap.engine.services.dc.wsgate.ArchiveFile[] archiveFiles,
           com.sap.engine.services.dc.wsgate.Option[] options) {
           this.archiveFiles = archiveFiles;
           this.options = options;
    }


    /**
     * Gets the archiveFiles value for this Deploy.
     * 
     * @return archiveFiles
     */
    public com.sap.engine.services.dc.wsgate.ArchiveFile[] getArchiveFiles() {
        return archiveFiles;
    }


    /**
     * Sets the archiveFiles value for this Deploy.
     * 
     * @param archiveFiles
     */
    public void setArchiveFiles(com.sap.engine.services.dc.wsgate.ArchiveFile[] archiveFiles) {
        this.archiveFiles = archiveFiles;
    }

    public com.sap.engine.services.dc.wsgate.ArchiveFile getArchiveFiles(int i) {
        return this.archiveFiles[i];
    }

    public void setArchiveFiles(int i, com.sap.engine.services.dc.wsgate.ArchiveFile _value) {
        this.archiveFiles[i] = _value;
    }


    /**
     * Gets the options value for this Deploy.
     * 
     * @return options
     */
    public com.sap.engine.services.dc.wsgate.Option[] getOptions() {
        return options;
    }
",3.337278106508876
"
/**
 * @author Peter Shin
 * @author Brian Wing Shun Chan
 */
public class AdminActivityKeys {

	public static final int ADD_KB_ARTICLE = 1;

	public static final int ADD_KB_COMMENT = 5;
",3.907608695652174
"/**
* <p>Title: sqsc-isqlj</p>
* <p>Description: SquirrelSQL plugin for iSqlJ</p>
* <p>Copyright: Copyright (c) 2003 Stathis Alexopoulos</p>
* @author Stathis Alexopoulos stathis@rege.org
* <br>
* <br>
* <p>
*    This file is part of sqsc-isqlj.
* </p>
* <br>
* <p>
*    sqsc-isqlj is free software; you can redistribute it and/or modify
*    it under the terms of the GNU Lesser General Public License as published by
*    the Free Software Foundation; either version 2 of the License, or
*    (at your option) any later version.
*
*    Foobar is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU Lesser General Public License for more details.
*
*    You should have received a copy of the GNU Lesser General Public License
*    along with Foobar; if not, write to the Free Software
*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
* </p>
*/

import net.sourceforge.squirrel_sql.client.plugin.IPlugin;
import net.sourceforge.squirrel_sql.client.plugin.PluginResources;
",3.732984293193717
"import com.liferay.portalweb.portal.BaseTestCase;
import com.liferay.portalweb.portal.util.RuntimeVariables;

/**
 * @author Brian Wing Shun Chan
 */
public class AddFrontPageTest extends BaseTestCase {
	public void testAddFrontPage() throws Exception {
		selenium.open(""/web/guest/home/"");
		loadRequiredJavaScriptModules();
",3.7096774193548394
"				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""//section"")) {
					break;
				}
			}
			catch (Exception e) {
			}
",3.44
"					RuntimeVariables.replace(""Control Panel""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				selenium.clickAt(""link=Web Content"",
					RuntimeVariables.replace(""Web Content""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();

				boolean webContent1Present = selenium.isElementPresent(
						""_15_rowIds"");

				if (!webContent1Present) {
					label = 2;

					continue;
				}

				selenium.clickAt(""//input[@name='_15_allRowIds']"",
					RuntimeVariables.replace(""""));
				selenium.click(RuntimeVariables.replace(
						""//input[@value='Delete']""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				assertTrue(selenium.getConfirmation()
								   .matches(""^Are you sure you want to delete the selected web content[\\s\\S]$""));

			case 2:

				boolean webContent2Present = selenium.isElementPresent(
						""_15_rowIds"");
",2.9604519774011298
"			selenium.getValue(""//input[@value='New Message']""));
		selenium.clickAt(""//input[@value='New Message']"",
			RuntimeVariables.replace(""New Message""));

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""//span[2]/span/button"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		selenium.clickAt(""//span[2]/span/button"",
			RuntimeVariables.replace(""Dropdown""));
		assertEquals(RuntimeVariables.replace(
				""socialofficefriendfn socialofficefriendmn socialofficefriendln""),
			selenium.getText(""//div[8]/div/div/ul/li[1]""));
		selenium.clickAt(""//div[8]/div/div/ul/li[1]"",
			RuntimeVariables.replace(
				""socialofficefriendfn socialofficefriendmn socialofficefriendln""));
		assertEquals(""socialofficefriendfn socialofficefriendmn socialofficefriendln <socialofficefriendsn>,"",
			selenium.getValue(""//span/input""));
		assertTrue(selenium.isVisible(""//span[1]/span/span/input""));
		selenium.type(""//span[1]/span/span/input"",
			RuntimeVariables.replace(""Message3 Subject""));
		assertTrue(selenium.isVisible(""//textarea""));
		selenium.type(""//textarea"", RuntimeVariables.replace(""Message3 Body""));
		selenium.clickAt(""//input[@value='Send']"",
			RuntimeVariables.replace(""Send""));

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""//div[@class='portlet-msg-success']"")) {
					break;
				}
			}
			catch (Exception e) {
			}
",2.763313609467456
"			LiferayPortletRequest liferayPortletRequest,
			LiferayPortletResponse liferayPortletResponse)
		throws Exception;

	public PortletURL getURLExport(
			LiferayPortletRequest liferayPortletRequest,
			LiferayPortletResponse liferayPortletResponse)
		throws Exception;

	public String getUrlTitle();
",3.1277777777777778
"
      JPanel pnlName = new JPanel(new BorderLayout());

		// i18n[graph.name=Name]
      JLabel lblName = new JLabel(s_stringMgr.getString(""graph.name""));
      pnlName.add(lblName, BorderLayout.WEST);
      txtName = new JTextField();
      pnlName.add(txtName, BorderLayout.CENTER);

      pnlEdit.add(pnlName);
",3.4833333333333334
"		StringBundler sb = new StringBundler(17);

		sb.append(""{resourcePermissionId="");
		sb.append(resourcePermissionId);
		sb.append("", companyId="");
		sb.append(companyId);
		sb.append("", name="");
		sb.append(name);
		sb.append("", scope="");
		sb.append(scope);
		sb.append("", primKey="");
		sb.append(primKey);
		sb.append("", roleId="");
		sb.append(roleId);
		sb.append("", ownerId="");
		sb.append(ownerId);
		sb.append("", actionIds="");
		sb.append(actionIds);
		sb.append(""}"");

		return sb.toString();
	}

	public ResourcePermission toEntityModel() {
		ResourcePermissionImpl resourcePermissionImpl = new ResourcePermissionImpl();

		resourcePermissionImpl.setResourcePermissionId(resourcePermissionId);
		resourcePermissionImpl.setCompanyId(companyId);

		if (name == null) {
			resourcePermissionImpl.setName(StringPool.BLANK);
		}
		else {
			resourcePermissionImpl.setName(name);
		}

		resourcePermissionImpl.setScope(scope);

		if (primKey == null) {
			resourcePermissionImpl.setPrimKey(StringPool.BLANK);
		}
		else {
			resourcePermissionImpl.setPrimKey(primKey);
		}

		resourcePermissionImpl.setRoleId(roleId);
		resourcePermissionImpl.setOwnerId(ownerId);
		resourcePermissionImpl.setActionIds(actionIds);

		resourcePermissionImpl.resetOriginalValues();
",3.382978723404255
"		selenium.clickAt(""//input[@value='Search']"",
			RuntimeVariables.replace(""Search""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		assertEquals(RuntimeVariables.replace(""Open""),
			selenium.getText(""//td[2]/a""));
		selenium.clickAt(""//td[2]/a"", RuntimeVariables.replace(""Open""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		assertEquals(RuntimeVariables.replace(""Test1 Folder1""),
			selenium.getText(""//b""));
		selenium.clickAt(""//b"", RuntimeVariables.replace(""Test1 Folder1""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		selenium.clickAt(""//input[@value='Add Document']"",
			RuntimeVariables.replace(""Add Document""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(
							""//a[@class='use-fallback using-new-uploader']"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		assertEquals(RuntimeVariables.replace(""Use the classic uploader.""),
			selenium.getText(""//a[@class='use-fallback using-new-uploader']""));
		selenium.click(""//a[@class='use-fallback using-new-uploader']"");
		selenium.type(""//input[@id='_20_file']"",
			RuntimeVariables.replace(
				""L:\\portal\\build\\portal-web\\test\\com\\liferay\\portalweb\\portal\\dbupgrade\\sampledata523\\documentlibrary\\document\\dependencies\\test_document.txt""));
		selenium.type(""//input[@id='_20_title']"",
			RuntimeVariables.replace(""Test1 Document1""));
		selenium.type(""//textarea[@id='_20_description']"",
			RuntimeVariables.replace(""This is Test1 Document1""));
		selenium.clickAt(""//input[@value='Save']"",
			RuntimeVariables.replace(""Save""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
",2.4468085106382977
"/**
 * @author Brian Wing Shun Chan
 */
public class ViewSitePublicPageDropDownTests extends BaseTestSuite {
	public static Test suite() {
		TestSuite testSuite = new TestSuite();
		testSuite.addTestSuite(AddSitesTest.class);
		testSuite.addTestSuite(AddSitesPublicPageTest.class);
		testSuite.addTestSuite(ViewSitesPublicPageDropDownTest.class);
		testSuite.addTestSuite(TearDownSitesTest.class);
",3.7801047120418847
"/*
 * Copyright (C) 2007 Rob Manning
 * manningr@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package net.sourceforge.squirrel_sql.plugins.dbdiff;

import net.sourceforge.squirrel_sql.client.session.ISession;
import net.sourceforge.squirrel_sql.fw.sql.IDatabaseObjectInfo;

/**
 * This is implemented in order to pass needed info along to diff executor.
 */
public interface SessionInfoProvider
{

	public void setSourceSession(ISession session);

	public ISession getSourceSession();

	public IDatabaseObjectInfo[] getSourceSelectedDatabaseObjects();

	public IDatabaseObjectInfo[] getDestSelectedDatabaseObjects();

	public void setDestSelectedDatabaseObjects(IDatabaseObjectInfo[] infos);

	public void setSourceSelectedDatabaseObjects(IDatabaseObjectInfo[] infos);

	public void setDestSession(ISession session);

	public ISession getDestSession();

	/**
	 * @return the scriptFileManager
	 */
	public IScriptFileManager getScriptFileManager();
",3.735
"		String[]	labels,
		String	 	defaultValue );

	/**
	 * 
	 * @param key
	 * @param resource_name
	 * @param encoding_type
	 * @param defaultValue
	 * @return
	 * @since 2.1.0.2
	 */
	public PasswordParameter
	addPasswordParameter2(
		String 		key,
		String 		resource_name,
		int			encoding_type,		// see PasswordParameter.ET_ constants
		byte[]	 	defaultValue );		// plain default value

	/**
	 * 
	 * @param key
	 * @param resource_name
	 * @param defaultValue
	 * @return
	 * @since 2.1.0.2
	 */
	public IntParameter
	addIntParameter2(
		String 		key,
		String 		resource_name,
		int	 		defaultValue );

	/**
	 * 
	 * @param key
	 * @param resource_name
	 * @param defaultValue
	 * @param min_value Minimum allowed value
	 * @param max_value Maximum allowed value
	 * @return
	 * @since 3.0.3.5
	 */
	public IntParameter
	addIntParameter2(
		String 		key,
		String 		resource_name,
		int	 		defaultValue,
		int         min_value,
		int         max_value);
",3.0753768844221105
"				sql = _SQL_SELECT_SCPRODUCTVERSION.concat(SCProductVersionModelImpl.ORDER_BY_JPQL);
			}

			Session session = null;

			try {
				session = openSession();

				Query q = session.createQuery(sql);

				if (orderByComparator == null) {
					list = (List<SCProductVersion>)QueryUtil.list(q,
							getDialect(), start, end, false);

					Collections.sort(list);
				}
				else {
					list = (List<SCProductVersion>)QueryUtil.list(q,
							getDialect(), start, end);
				}
			}
			catch (Exception e) {
				throw processException(e);
			}
			finally {
				if (list == null) {
					FinderCacheUtil.removeResult(finderPath, finderArgs);
				}
				else {
					cacheResult(list);
",3.479591836734694
" */

package com.liferay.portalweb.portal.dbupgrade.sampledata523.shopping.coupon;

import com.liferay.portalweb.portal.BaseTestCase;
import com.liferay.portalweb.portal.util.RuntimeVariables;

/**
 * @author Brian Wing Shun Chan
 */
public class ViewCouponTest extends BaseTestCase {
	public void testViewCoupon() throws Exception {
		selenium.open(""/user/joebloggs/home/"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isElementPresent(""link=Communities I Own"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",3.515957446808511
"		assertEquals(existingEntryId, newEntryId);
	}

	public void testDynamicQueryByProjectionMissing() throws Exception {
		DynamicQuery dynamicQuery = DynamicQueryFactoryUtil.forClass(RatingsEntry.class,
				RatingsEntry.class.getClassLoader());

		dynamicQuery.setProjection(ProjectionFactoryUtil.property(""entryId""));

		dynamicQuery.add(RestrictionsFactoryUtil.in(""entryId"",
				new Object[] { nextLong() }));

		List<Object> result = _persistence.findWithDynamicQuery(dynamicQuery);

		assertEquals(0, result.size());
	}

	public void testResetOriginalValues() throws Exception {
		if (!PropsValues.HIBERNATE_CACHE_USE_SECOND_LEVEL_CACHE) {
			return;
		}

		RatingsEntry newRatingsEntry = addRatingsEntry();

		_persistence.clearCache();

		RatingsEntryModelImpl existingRatingsEntryModelImpl = (RatingsEntryModelImpl)_persistence.findByPrimaryKey(newRatingsEntry.getPrimaryKey());

		assertEquals(existingRatingsEntryModelImpl.getUserId(),
			existingRatingsEntryModelImpl.getOriginalUserId());
		assertEquals(existingRatingsEntryModelImpl.getClassNameId(),
			existingRatingsEntryModelImpl.getOriginalClassNameId());
		assertEquals(existingRatingsEntryModelImpl.getClassPK(),
			existingRatingsEntryModelImpl.getOriginalClassPK());
	}

	protected RatingsEntry addRatingsEntry() throws Exception {
		long pk = nextLong();

		RatingsEntry ratingsEntry = _persistence.create(pk);

		ratingsEntry.setCompanyId(nextLong());

		ratingsEntry.setUserId(nextLong());

		ratingsEntry.setUserName(randomString());

		ratingsEntry.setCreateDate(nextDate());

		ratingsEntry.setModifiedDate(nextDate());
",2.806451612903226
"		while (label >= 1) {
			switch (label) {
			case 1:
				selenium.open(""/web/guest/home/"");
				loadRequiredJavaScriptModules();

				for (int second = 0;; second++) {
					if (second >= 90) {
						fail(""timeout"");
					}

					try {
						if (selenium.isElementPresent(""link=Control Panel"")) {
							break;
						}
					}
					catch (Exception e) {
					}

					Thread.sleep(1000);
				}

				selenium.clickAt(""link=Control Panel"",
					RuntimeVariables.replace(""Control Panel""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				selenium.clickAt(""link=Web Content"",
					RuntimeVariables.replace(""Web Content""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();

				boolean webContent1Present = selenium.isElementPresent(
						""_15_rowIds"");

				if (!webContent1Present) {
					label = 2;

					continue;
				}

				selenium.clickAt(""//input[@name='_15_allRowIds']"",
					RuntimeVariables.replace(""""));
				selenium.click(RuntimeVariables.replace(
						""//input[@value='Delete']""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				assertTrue(selenium.getConfirmation()
								   .matches(""^Are you sure you want to delete the selected web content[\\s\\S]$""));

			case 2:
",3.016042780748663
"
		String emailMessageAddedSubjectPrefix = getParameter(
			actionRequest, ""emailMessageAddedSubjectPrefix"");
		String emailMessageAddedBody = getParameter(
			actionRequest, ""emailMessageAddedBody"");

		if (Validator.isNull(emailMessageAddedSubjectPrefix)) {
			SessionErrors.add(actionRequest, ""emailMessageAddedSubjectPrefix"");
		}
		else if (Validator.isNull(emailMessageAddedBody)) {
			SessionErrors.add(actionRequest, ""emailMessageAddedBody"");
		}
	}

	protected void validateEmailMessageUpdated(ActionRequest actionRequest)
		throws Exception {

		String emailMessageUpdatedSubjectPrefix = getParameter(
			actionRequest, ""emailMessageUpdatedSubjectPrefix"");
		String emailMessageUpdatedBody = getParameter(
			actionRequest, ""emailMessageUpdatedBody"");

		if (Validator.isNull(emailMessageUpdatedSubjectPrefix)) {
			SessionErrors.add(
				actionRequest, ""emailMessageUpdatedSubjectPrefix"");
		}
		else if (Validator.isNull(emailMessageUpdatedBody)) {
			SessionErrors.add(actionRequest, ""emailMessageUpdatedBody"");
		}
	}
",3.1666666666666665
"/**
 * @author Brian Wing Shun Chan
 */
public class UnitConverterTestPlan extends BaseTestSuite {

	public static Test suite() {
		TestSuite testSuite = new TestSuite();

		testSuite.addTest(PortletTestPlan.suite());
		testSuite.addTest(UnitTestPlan.suite());
",4.1891891891891895
"
import com.liferay.portal.kernel.log.Log;
import com.liferay.portal.kernel.log.LogFactoryUtil;
import com.liferay.portal.kernel.util.PortalClassLoaderUtil;
import com.liferay.portal.kernel.util.SortedProperties;
import com.liferay.portal.util.PropsUtil;
import com.liferay.portal.util.PropsValues;

import java.util.Enumeration;
import java.util.Properties;
",4.136842105263158
" */

package com.liferay.portalweb.portlet.shopping.item.addtoshoppingcartcategoryitemmultiple;

import com.liferay.portalweb.portal.BaseTestCase;
import com.liferay.portalweb.portal.util.RuntimeVariables;

/**
 * @author Brian Wing Shun Chan
 */
public class AddToShoppingCartCategoryItem3Test extends BaseTestCase {
	public void testAddToShoppingCartCategoryItem3() throws Exception {
		selenium.open(""/web/guest/home/"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""link=Shopping Test Page"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",3.502673796791444
"
		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isElementPresent(""link=Control Panel"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		selenium.clickAt(""link=Control Panel"", RuntimeVariables.replace(""""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		selenium.clickAt(""link=Organizations"", RuntimeVariables.replace(""""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		selenium.type(""_126_keywords"",
			RuntimeVariables.replace(""Web Content Display""));
		selenium.clickAt(""//input[@value='Search']"",
			RuntimeVariables.replace(""""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		Thread.sleep(5000);
		assertEquals(RuntimeVariables.replace(""Actions""),
			selenium.getText(""//strong/a""));
		selenium.clickAt(""//strong/a"", RuntimeVariables.replace(""Actions""));

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(
							""//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",2.7650273224043715
"public class ComponentTag extends BaseComponentTag {

	protected void setAttributes(HttpServletRequest request) {
		Map<String, Object> options = getOptions();
		HashMap<String, Object> optionsJSON = new HashMap<String, Object>();

		_proccessAttributes(options, optionsJSON);

		super.setAttributes(request);

		setNamespacedAttribute(request, ""options"", options);
		setNamespacedAttribute(request, ""optionsJSON"", optionsJSON);
	}

	private boolean _isEventAttribute(String key) {
		Matcher afterMatcher = _EVENT_AFTER_REGEX.matcher(key);
		Matcher onMatcher = _EVENT_ON_REGEX.matcher(key);

		return (afterMatcher.find() || onMatcher.find());
	}

	private boolean _isValidAttribute(String key) {
		List<String> excludeAttributes = Collections.EMPTY_LIST;

		if (getExcludeAttributes() != null) {
			excludeAttributes = Arrays.asList(
				getExcludeAttributes().split(StringPool.COMMA));
		}

		return !(excludeAttributes.contains(key) ||
			key.equals(_DYNAMIC_ATTRIBUTES));
	}

	private void _proccessAttributes(Map<String, Object> options,
		Map<String, Object> newOptions) {

		Map<String, String> afterEventOptionsMap =
			new HashMap<String, String>();

		Map<String, String> onEventOptionsMap =	new HashMap<String, String>();

		for (String key : options.keySet()) {
			if (!_isValidAttribute(key)) {
				continue;
			}

			Object value = options.get(key);

			String originalKey =
				ReservedAttributeUtil.getOriginalName(getName(), key);
",3.569948186528497
" */

package com.liferay.portalweb.portlet.wiki.wikipage.deletewikipagechildpage;

import com.liferay.portalweb.portal.BaseTestCase;
import com.liferay.portalweb.portal.util.RuntimeVariables;

/**
 * @author Brian Wing Shun Chan
 */
public class DeleteWikiPageChildPageTest extends BaseTestCase {
	public void testDeleteWikiPageChildPage() throws Exception {
		selenium.open(""/web/guest/home/"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""link=Wiki Test Page"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",3.745192307692308
"   */
  public ICMPEchoPacket(ICMPEchoPacket packet) {
    super(packet);
  }


  public int getICMPHeaderByteLength() {
    return 8;
  }

",3.971830985915493
"	public java.util.List<com.liferay.portlet.polls.model.PollsVote> getQuestionVotes(
		long questionId, int start, int end)
		throws com.liferay.portal.kernel.exception.SystemException {
		return _pollsVoteLocalService.getQuestionVotes(questionId, start, end);
	}

	public int getQuestionVotesCount(long questionId)
		throws com.liferay.portal.kernel.exception.SystemException {
		return _pollsVoteLocalService.getQuestionVotesCount(questionId);
	}
",3.1372549019607843
"					RuntimeVariables.replace(""Actions""));

				for (int second = 0;; second++) {
					if (second >= 90) {
						fail(""timeout"");
					}

					try {
						if (selenium.isVisible(
									""//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a"")) {
							break;
						}
					}
					catch (Exception e) {
					}

					Thread.sleep(1000);
				}

				assertEquals(RuntimeVariables.replace(""Delete""),
					selenium.getText(
						""//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a""));
				selenium.click(RuntimeVariables.replace(
						""//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a""));
				selenium.waitForPageToLoad(""30000"");
				loadRequiredJavaScriptModules();
				assertTrue(selenium.getConfirmation()
								   .matches(""^Are you sure you want to delete this[\\s\\S]$""));

			case 3:
",3.145
"package org.gudy.azureus2.countrylocator.statisticsProviders;

import java.util.Map;

import org.gudy.azureus2.plugins.peers.Peer;

/**
 * IStatisticsProvider (see {@link #getStatistics(Peer[])})
 * 
 * @author gooogelybear
 * @author free_lancer
 */
public interface IStatisticsProvider {
		
	/**
	 * Calculates stats values for a column in the stats table. <br />
	 * 
	 * @param peers the peers for which the stats will be calculated
	 * @return A map indexed by country code which contains the stats values as values
	 */
	public Map getStatistics(Peer[] peers);
	
	public String getName();
	
	/**
	 * 
	 * @return The measurement unit used for the stats values, e.g. ""kB/s""
	 */
	public String getUnit();
",4.243781094527363
"
				boolean advancedVisible = selenium.isVisible(
						""link=Advanced \u00bb"");

				if (!advancedVisible) {
					label = 3;

					continue;
				}

				selenium.clickAt(""link=Advanced \u00bb"",
					RuntimeVariables.replace(""Advanced""));

			case 3:

				for (int second = 0;; second++) {
					if (second >= 90) {
						fail(""timeout"");
					}

					try {
						if (selenium.isVisible(""//select[@id='_125_status']"")) {
							break;
						}
					}
					catch (Exception e) {
					}

					Thread.sleep(1000);
				}
",3.1020408163265305
"			try {
				if (selenium.isElementPresent(""link=Control Panel"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",3.3535353535353534
" */

package com.liferay.portalweb.portal.cluster.cluster3;

import com.liferay.portalweb.portal.BaseTestCase;
import com.liferay.portalweb.portal.util.RuntimeVariables;

/**
 * @author Brian Wing Shun Chan
 */
public class AssertNodeTwoTest extends BaseTestCase {
	public void testAssertNodeTwo() throws Exception {
		selenium.open(""/web/guest/home/"");
		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""//input[@id='_58_login']"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}
",3.345744680851064
"		loadRequiredJavaScriptModules();

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}

			try {
				if (selenium.isVisible(""link=Requests Test Page"")) {
					break;
				}
			}
			catch (Exception e) {
			}

			Thread.sleep(1000);
		}

		selenium.click(RuntimeVariables.replace(""link=Requests Test Page""));
		selenium.waitForPageToLoad(""30000"");
		loadRequiredJavaScriptModules();
		assertTrue(selenium.isPartialText(""//a[@id='_145_addApplication']"",
				""More""));
		selenium.clickAt(""//a[@id='_145_addApplication']"",
			RuntimeVariables.replace(""More""));

		for (int second = 0;; second++) {
			if (second >= 90) {
				fail(""timeout"");
			}
",3.160220994475138
"    PrimaryKeyInfo() {
        super(null, null, null, null, null);
    }
    
    /**
     * Create a new PrimaryKeyInfo object.
     * 
     * @param catalog catalog name
     * @param schema schema name
     * @param aColumnName the name of the column that either by itself or along
     *                    with others form(s) a unique index value for a single
     *                    row in a table. 
     * @param aKeySequence sequence number within primary key
     * @param aPrimaryKeyName the name of the primary key
     * @param md
     */
	public PrimaryKeyInfo(String catalog, 
                   String schema,
                   String aTableName,
                   String aColumnName, 
                   short aKeySequence, 
                   String aPrimaryKeyName,
                   ISQLDatabaseMetaData md)
	{
		super(catalog, schema, aPrimaryKeyName, DatabaseObjectType.PRIMARY_KEY, md);
        columnName = aColumnName;
        tableName = aTableName;
        keySequence = aKeySequence;
	}

    /**
     * @param columnName The columnName to set.
     */
    public void setColumnName(String columnName) {
        this.columnName = columnName;
    }

    /**
     * @return Returns the columnName.
     */
    public String getColumnName() {
        return columnName;
    }

    /**
     * @param keySequence The keySequence to set.
     */
    public void setKeySequence(short keySequence) {
        this.keySequence = keySequence;
    }
",3.956284153005464
"
			Object ret = body.eval(callstack, interpreter);

			boolean breakout = false;
			if(ret instanceof ReturnControl)
			{
				switch(((ReturnControl)ret).kind )
				{
					case RETURN:
						return ret;
",2.9917355371900825
"
        if (actionList.size() == 1) {
            ActionMenu menu = actionList.get(0);

            if (menu.getSubItems().length == 0) {
                return null;
            }

            if (menu.getSubItems().length == 1) {
                Action action = menu.getSubItems()[0].getAction();

",3.743801652892562
"		private String compactString(String source) {
			String result= DELTA_START + source.substring(fPrefix, source.length() - fSuffix + 1) + DELTA_END;
			if (fPrefix > 0)
				result= computeCommonPrefix() + result;
			if (fSuffix > 0)
				result= result + computeCommonSuffix();
",2.6942148760330578
"    /**
     * Constructor, with a argument reference to the PUBLIC User Object which
     * is null if this is the SYS or PUBLIC user.
     *
     * The dependency upon a GranteeManager is undesirable.  Hopefully we
     * can get rid of this dependency with an IOC or Listener re-design.
     */
    Grantee(String name, Grantee inGrantee,
            GranteeManager man) throws HsqlException {

        rightsMap      = new IntValueHashMap();
        granteeName    = name;
        granteeManager = man;}
",4.033057851239669
"    /**
     * Quits the application without any questions.
     */
    public void quit() {
        getConnectController().quitGame(true);
        if (!windowed) {
            gd.setFullScreenWindow(null);
        }
        System.exit(0);}
",4.190082644628099
"    xsp = jj_scanpos;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) return true;
",2.190082644628099
"  /**
   * Attention: DO NOT USE THIS!
   * Under Os/2 it has some problems with calculating the real Date!
   * 
   * @deprecated
   */
  public Date(int daysSince1970) {

    long l = (long) daysSince1970 * 24 * 60 * 60 * 1000;
    java.util.Date d = new java.util.Date(l);
    Calendar cal = Calendar.getInstance();}
",3.628099173553719
"	public TestMethodRunner(Object test, Method method, RunNotifier notifier, Description description) {
		super(test.getClass(), Before.class, After.class, test);
		fTest= test;
		fMethod= method;
",2.8595041322314048
"    /**
     * Returns a vector containing the URI (type + path) for all the databases.
     */
    public static Vector getDatabaseURIs() {

        Vector   v  = new Vector();
        Iterator it = databaseIDMap.values().iterator();

        while (it.hasNext()) {
            Database db = (Database) it.next();
",4.132231404958677
"    private void moveUnit(KeyEvent e) {
        if (!parent.isMapboardActionsEnabled()) {
            return;
        }
        
        switch (e.getKeyCode()) {
        case KeyEvent.VK_ESCAPE:
            // main menu
            break;
        case KeyEvent.VK_NUMPAD1:
        case KeyEvent.VK_END:
            inGameController.moveActiveUnit(Map.SW);
",3.347107438016529
"
		if ( clas == null )
			throw new ClassNotFoundException(
				""Class: "" + value+ "" not found in namespace"");

		asClass = clas;
		return asClass;
",3.644628099173554
"
        
        btPanel.add(cancel);

        getRootPane().setDefaultButton(ok);
        
        panel.add(btPanel, BorderLayout.SOUTH);
",3.5371900826446283
"	 * @param expected expected value
	 * @param actual actual value
	 */
	static public void assertEquals(String message, Object expected, Object actual) {
		if (expected == null && actual == null)
			return;
		if (expected != null && isEquals(expected, actual))
			return;
		else if (expected instanceof String && actual instanceof String) {
			String cleanMessage= message == null ? """" : message;
",3.041322314049587
"    Object removeName(String name) throws HsqlException {

        Object owner = nameList.remove(name);

        if (owner == null) {

            // should contain name
            throw Trace.error(Trace.GENERAL_ERROR);
        }

        return owner;
",4.049586776859504
"
        int stepSize = Math.min((option.getMaximumValue() - option.getMinimumValue()) / 10, 1000);
        spinner = new JSpinner(new SpinnerNumberModel(option.getValue(), option.getMinimumValue(),
                option.getMaximumValue(), Math.max(1, stepSize)));
        spinner.setToolTipText(option.getShortDescription());
",1.834710743801653
"		if ( parent != null )
			setStrictJava( parent.getStrictJava() );
		this.sourceFileInfo = sourceFileInfo;

		BshClassManager bcm = BshClassManager.createClassManager( this );
",2.900826446280992
"        
        mDevices = new Vector<DeviceIf>();
        
        DeviceFileHandling reader = new DeviceFileHandling();

        for (int i = 0; i < num; i++) {
            String classname = (String) in.readObject();
",3.7355371900826446
"	/**
	 * Do not use. Testing purposes only.
	 */
	public Result runMain(String... args) {
		System.out.println(""JUnit version "" + Version.id());
		List<Class<?>> classes= new ArrayList<Class<?>>();
		List<Failure> missingClasses= new ArrayList<Failure>();
",2.471074380165289
"    /**
     * temp constraint constructor
     */
    Constraint(HsqlName name, int[] mainCols, Table refTable, int[] refCols,
               int type, int deleteAction, int updateAction) {

        core              = new ConstraintCore();
        constName         = name;
        constType         = type;
",3.553719008264463
"        int eventId = active? ON : OFF;
        ActionEvent blinkEvent = new ActionEvent(this,eventId,""blink"");
        
        fireActionEvent(blinkEvent);
",3.2644628099173554
"		else if ( isPrimitive( returnType ) ) 
		{
			int opcode = IRETURN;
			String type;
			String meth;
",3.727272727272727
"    /**
     * Returns the PluginPanel
     * @return Panel
     */
    public JPanel createSettingsPanel() {
      mPanel = new CapturePluginPanel(mOwner, mCloneData);
      mPanel.setBorder(Borders.createEmptyBorder(Sizes.DLUY5,Sizes.DLUX5,Sizes.DLUY5,Sizes.DLUX5));
      mPanel.setSelectedTab(mCurrentPanel);
",2.7355371900826446
"	protected void printFailures(Result result) {
		if (result.getFailureCount() == 0)
			return;
		if (result.getFailureCount() == 1)
			getWriter().println(""There was "" + result.getFailureCount() + "" failure:"");
		else
			getWriter().println(""There were "" + result.getFailureCount() + "" failures:"");
",3.933884297520661
"    public static long getNormalisedTime(long t) {

        synchronized (tempCalDefault) {
            setTimeInMillis(tempCalDefault, t);
            resetToTime(tempCalDefault);

            return getTimeInMillis(tempCalDefault);
",3.479338842975207
"
            public boolean check(Unit u, PathNode p) {
                if (p.getTile().getSettlement() != null && p.getTile().getSettlement().getOwner() == player
                        && p.getTile().getSettlement() != inSettlement) {
                    Settlement s = p.getTile().getSettlement();
                    int turns = p.getTurns();
                    destinations.add(new ChoiceItem(s.toString() + "" ("" + turns + "")"", s));
",2.0991735537190084
"
     if ((bufpos + 1) >= len)
        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
     else
     {
        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                                                          len - bufpos - 1);
        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
",2.3884297520661155
"    /**
     * Compute the proper position for a centered window
     */
    private Point comuteDisplayPointCentre(Dimension dim) {
        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
        int x = (screen.width - dim.width) / 2;
        int y = (screen.height - dim.height) / 2;
",3.7520661157024793
"	public void filter(Filter filter) throws NoTestsRemainException {
		for (Iterator<Runner> iter= fRunners.iterator(); iter.hasNext();) {
			Runner runner= iter.next();
			if (filter.shouldRun(runner.getDescription()))
				filter.apply(runner);
			else
				iter.remove();
",2.8677685950413223
"        boolean    hasReturnValue;

        outlen = parameters.length;
        offset = 0;
",3.9421487603305785
"    /**
     * Sets the currently chosen <code>MapTransform</code>.
     * @param mt The transform that should be applied to a
     *      <code>Tile</code> that is clicked on the map.
     */
    public void setMapTransform(MapTransform mt) {
        currentMapTransform = mt;
        MapControlsAction mca = (MapControlsAction) freeColClient.getActionManager().getFreeColAction(MapControlsAction.ID);
        if (mca.getMapControls() != null) {
            mca.getMapControls().update(mt);
",2.793388429752066
"			
			if (iterateOverMe instanceof String)
				return createEnumeration(((String)iterateOverMe).toCharArray());
			
			if (iterateOverMe instanceof StringBuffer)
				return createEnumeration(
					iterateOverMe.toString().toCharArray());

			throw new IllegalArgumentException(
				""Cannot enumerate object of type ""+iterateOverMe.getClass());
",3.2644628099173554
"  /**
   * Constructs a new Date object, initialized with the current date.
   */
  public Date() {
    Calendar mCalendar = Calendar.getInstance();
    mYear = mCalendar.get(Calendar.YEAR);
    mMonth = mCalendar.get(Calendar.MONTH) + 1;
",4.223140495867769
"		/**
		 * @param contextLength the maximum length for <code>expected</code> and <code>actual</code>. When contextLength 
		 * is exceeded, the Strings are shortened
		 * @param expected the expected string value
		 * @param actual the actual string value
		 */
		public ComparisonCompactor(int contextLength, String expected, String actual) {
			fContextLength= contextLength;
			fExpected= expected;
			fActual= actual;
",4.016528925619835
"
            case CompiledStatement.DELETE :
                return executeDeleteStatement(cs);

            case CompiledStatement.CALL :
                return executeCallStatement(cs);

            case CompiledStatement.DDL :
                return executeDDLStatement(cs);
",4.347107438016529
"    /**
     * Creates a new <code>DisbandUnitAction</code>.
     * 
     * @param freeColClient The main controller object for the client.
     */
    DisbandUnitAction(FreeColClient freeColClient) {
        super(freeColClient, ""unit.state.8"", null, KeyStroke.getKeyStroke('D', 0));
        putValue(BUTTON_IMAGE, freeColClient.getImageLibrary().getUnitButtonImageIcon(ImageLibrary.UNIT_BUTTON_DISBAND,
                0));
        putValue(BUTTON_ROLLOVER_IMAGE, freeColClient.getImageLibrary().getUnitButtonImageIcon(
                ImageLibrary.UNIT_BUTTON_DISBAND, 1));
",2.008264462809917
"			Class clas = object.getClass();
			Field field = Reflect.resolveJavaField( 
				clas, name, false/*onlyStatic*/ );
			if ( field != null )
				return new Variable( 
					name, field.getType(), new LHS( object, field ) );
",2.5454545454545454
"    
    for(AbstractPluginProgramFormating config : mConfigs)
      if(config != null && config.isValid())
        list.add(new ProgramReceiveTarget(this, config.getName(), config.getId()));
    
    if(list.isEmpty())
      list.add(new ProgramReceiveTarget(this, DEFAULT_CONFIG.getName(), DEFAULT_CONFIG.getId()));
    
    return list.toArray(new ProgramReceiveTarget[list.size()]);
",2.5785123966942147
"	Class<? extends Throwable> expectedException(Method method) {
		Test annotation= method.getAnnotation(Test.class);
		if (annotation.expected() == None.class)
			return null;
		else
			return annotation.expected();
",2.7768595041322315
"            row[1] = ns.getCatalogName(row[0]);
            row[2] = schema.equals(defschema) ? Boolean.TRUE
                                              : Boolean.FALSE;

            t.insertSys(row);
",2.9669421487603307
"    /**
     * Handles an ""deliverGift""-request.
     * 
     * @param element The element (root element in a DOM-parsed XML tree) that
     *            holds all the information.
     */
    private Element deliverGift(Element element) {
        Element unitElement = Message.getChildElement(element, Unit.getXMLElementTagName());

        Unit unit = (Unit) getGame().getFreeColGameObject(unitElement.getAttribute(""ID""));
        unit.readFromXMLElement(unitElement);
",2.909090909090909
"      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
        break;
      case NE:
        t = jj_consume_token(NE);
",2.4214876033057853
"  public synchronized void removeProgram(Program program) {
    PluginTreeNode node = findProgramTreeNode(program, false);
    if (node != null) {
      mChildNodes.remove(node);
      if (mMarker != null) {
        program.unmark(mMarker);
",3.0826446280991737
"		private TestClassRunnerForParameters(Class<?> klass, Object[] parameters, int i) {
			super(klass);
			fParameters= parameters;
			fParameterSetNumber= i;
",3.289256198347108
"        void link(IndexRowIterator other) {

            other.next = next;
            other.last = this;
            next.last  = other;
",4.074380165289257
"        final String heightText = Messages.message(""height"");
        
        final JTextField inputWidth = new JTextField(Integer.toString(DEFAULT_WIDTH), COLUMNS);
        final JTextField inputHeight = new JTextField(Integer.toString(DEFAULT_HEIGHT), COLUMNS);
",3.84297520661157
"	/**
		Get the top level namespace or this namespace if we are the top.
		Note: this method should probably return type bsh.This to be consistent
		with getThis();
	*/
    public This getGlobal( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getGlobal( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
",3.760330578512397
"    /**
     * Read Settings
     * @param stream
     * @throws IOException
     * @throws ClassNotFoundException
     */
    public void readData(ObjectInputStream stream) throws IOException, ClassNotFoundException {
      int version = stream.readInt();
      mNumber = stream.readInt();
      mName = stream.readUTF();
",3.87603305785124
"	/**
	 * Constructs a comparison failure.
	 * @param message the identifying message or null
	 * @param expected the expected string value
	 * @param actual the actual string value
	 */
	public ComparisonFailure (String message, String expected, String actual) {
		super (message);
		fExpected= expected;
		fActual= actual;
",3.933884297520661
"    public void close() {

        if (isClosed) {
            return;
        }

        isClosed = true;

        try {
            resultOut.setResultType(ResultConstants.SQLDISCONNECT);
",4.049586776859504
"        public void actionPerformed(ActionEvent evt) {
            if (!hasFocus()) {
                stopBlinking();
            }

            if (blinkOn) {
                setOpaque(false);
                blinkOn = false;
",4.1652892561983474
"	private static String getBaseName( String className ) 
	{
		int i = className.indexOf(""$"");
		if ( i == -1 )
			return className;

		return className.substring(i+1);
",3.9173553719008254
"
    panel.add(UiUtilities.createHelpTextArea(mLocalizer.msg(""help"",""No endtime defined"")), cc.xy(1,1));
    
    mTimePanel = new TimeDateChooserPanel(date);
    panel.add(mTimePanel, cc.xy(1,3));
",2.644628099173554
"		try {
			suiteMethod= klass.getMethod(""suite"");
			if (! Modifier.isStatic(suiteMethod.getModifiers())) {
				throw new Exception(klass.getName() + "".suite() must be static"");
			}
			suite= (Test) suiteMethod.invoke(null); // static method
",2.727272727272727
"
            // ----------------------------------------------------------------
            // required
            // ----------------------------------------------------------------
            addColumn(t, ""PROCEDURE_CAT"", Types.VARCHAR);
            addColumn(t, ""PROCEDURE_SCHEM"", Types.VARCHAR);
            addColumn(t, ""PROCEDURE_NAME"", Types.VARCHAR, false);    // not null
",3.603305785123967
"
        if (missionChip == null) {
            GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
                    .getDefaultConfiguration();
            loadMissionChip(gc, color, expertMission);

            if (expertMission) {
                missionChip = expertMissionChips.get(color);
",2.71900826446281
"	/**
		Swap in the value as the new top of the stack and return the old
		value.
	*/
	public NameSpace swap( NameSpace newTop ) {
		NameSpace oldTop = (NameSpace)(stack.elementAt(0));
		stack.setElementAt( newTop, 0 );
		return oldTop;
",3.611570247933885
"      
      String classname = (String) in.readObject();
      String devname = (String)in.readObject();
      
      DeviceIf dev = DriverFactory.getInstance().createDevice(classname, devname);
",3.603305785123967
"			String simpleName= runnerClass.getSimpleName();
			InitializationError error= new InitializationError(String.format(
					CONSTRUCTOR_ERROR_FORMAT, simpleName, simpleName));
			return Request.errorReport(fTestClass, error).getRunner();
",2.413223140495868
"    public boolean isReadOnly() throws HsqlException {

        Object info = getAttribute(Session.INFO_CONNECTION_READONLY);

        isReadOnly = ((Boolean) info).booleanValue();

        return isReadOnly;
",3.826446280991736
" 
        boolean response = warehouseDialog.getResponseBoolean();
        remove(warehouseDialog);
        return response;
",3.884297520661157
"			else if ( returnType.equals(""F"") )
				opcode = FRETURN;
			else if ( returnType.equals(""J"") )  //long
				opcode = LRETURN;

			cv.visitInsn(opcode);
",3.776859504132232
"    String channelId;
    
    if (version==1) {
      dataServiceId = (String)in.readObject();
      channelId=""""+in.readInt();
",3.471074380165289
"	@Override
	public Description getDescription() {
		Description spec= Description.createSuiteDescription(getName());
		List<Method> testMethods= fTestMethods;
		for (Method method : testMethods)
				spec.addChild(methodDescription(method));
",2.652892561983471
"
            while (classNames.hasNext()) {
                clsName         = (String) classNames.next();
                clsCat          = ns.getCatalogName(clsName);
                clsSchem        = ns.getSchemaName(clsName);
",3.5950413223140494
"
        String[] texts = new String[messages.length];
        ImageIcon[] images = new ImageIcon[messages.length];
        for (int i = 0; i < messages.length; i++) {
            String ID = messages[i].getMessageID();
",3.2148760330578514
"
      mProgramTable.changeSelection(row, 0, false, false);

      Program p = (Program) mProgramTableModel.getValueAt(row, 1);

      JPopupMenu menu = devplugin.Plugin.getPluginManager().createPluginContextMenu(p, CapturePlugin.getInstance());
",2.603305785123967
"  /**
   * Add one zero if neccessary
   * @param number
   * @return
   */
  private CharSequence addZero(int number) {
    StringBuilder builder = new StringBuilder();
    
    if (number < 10) {
      builder.append('0');
    }
    
    builder.append(Integer.toString(number));
",4.016528925619835
"	@Override
	public void run(RunNotifier notifier) {
		TestResult result= new TestResult();
		result.addListener(createAdaptingListener(notifier));
		fTest.run(result);
",3.363636363636364
"        t.checkColumnsMatch(tc.core.mainColArray, tc.core.refTable,
                            tc.core.refColArray);
        session.commit();

        TableWorks tableWorks = new TableWorks(session, t);
",2.925619834710744
"        @Override
        public void mousePressed(MouseEvent e) {
            if (f.getDesktopPane() == null || f.getDesktopPane().getDesktopManager() == null) {
                return;
            }
            loc = SwingUtilities.convertPoint((Component) e.getSource(), e.getX(), e.getY(), null);
            f.getDesktopPane().getDesktopManager().beginDraggingFrame(f);
",2.4049586776859506
"	/**
		Translate bsh.Modifiers into ASM modifier bitflags.
	*/
	static int getASMModifiers( Modifiers modifiers ) 
	{
		int mods = 0;
		if ( modifiers == null )
			return mods;

		if ( modifiers.hasModifier(""public"") )
			mods += ACC_PUBLIC;
",3.6942148760330578
"    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {

        JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
        
        String str;
        
        if (value instanceof DeviceIf) {
            DeviceIf device = (DeviceIf)value; 
",2.8595041322314048
"		public String compact(String message) {
			if (fExpected == null || fActual == null || areStringsEqual())
				return Assert.format(message, fExpected, fActual);

			findCommonPrefix();
			findCommonSuffix();
",3.3801652892561984
"
        classNames = classNameSet.iterator();

        while (classNames.hasNext()) {
            className = (String) classNames.next();
            methods   = iterateRoutineMethods(className, andAliases);
",3.809917355371901
"    /**
     * Generates a color chip image and stores it in memory.
     * 
     * @param gc The GraphicsConfiguration is needed to create images that are
     *            compatible with the local environment.
     * @param c The color of the color chip to create.
     */
    private void loadColorChip(GraphicsConfiguration gc, Color c) {
        BufferedImage tempImage = gc.createCompatibleImage(11, 17);
        Graphics g = tempImage.getGraphics();
        if (c.equals(Color.BLACK)) {
            g.setColor(Color.WHITE);
",3.396694214876033
"      
      out.writeObject(device.getDriver().getClass().getName());
      out.writeObject(device.getName());
      
      device.writeData(out);
",3.487603305785124
"        
        File data = new File(Plugin.getPluginManager().getTvBrowserSettings().getTvBrowserUserHome()  + File.separator + 
                ""CaptureDevices"" + File.separator + mCount + "".dat"");
        
        ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(data));
        
        dev.writeData(stream);
",2.727272727272727
"	private static Class<?>[] getAnnotatedClasses(Class<?> klass) throws InitializationError {
		SuiteClasses annotation= klass.getAnnotation(SuiteClasses.class);
		if (annotation == null)
			throw new InitializationError(String.format(""class '%s' must have a SuiteClasses annotation"", klass.getName()));
		return annotation.value();
",2.2975206611570247
"
        for (int j = 0; j < fieldcount; j++) {
            int i = Column.compare(session.database.collation, a[cols[j]],
                                   b[cols[j]], coltypes[cols[j]]);

            if (i != 0) {
                return i;
            }
        }

        return 0;
",3.347107438016529
"    /**
     * Closes all panels, changes the background and shows the main menu.
     */
    public void returnToTitle() {
        // TODO: check if the GUI object knows that we're not
        // inGame. (Retrieve value of GUI::inGame.)  If GUI thinks
        // we're still in the game then log an error because at this
        // point the GUI should have been informed.
        closeMenus();
        removeInGameComponents();
        showMainPanel();
",4.148760330578512
"	/**
		subsequent imports override earlier ones
	*/
    public void	importPackage(String name)
    {
		if(importedPackages == null)
			importedPackages = new Vector();

		// If it exists, remove it and add it at the end (avoid memory leak)
		if ( importedPackages.contains( name ) )
			importedPackages.remove( name );

		importedPackages.addElement(name);
",3.933884297520661
"        
        if(dataServiceId.compareTo(cmpDataServiceId) != 0) {
          return false;
        }
        
        String country = getCountry();
        String cmpCountry = cmp.getCountry();
",4.0
"	public void filter(Filter filter) throws NoTestsRemainException {
		for (Iterator<Method> iter= fTestMethods.iterator(); iter.hasNext();) {
			Method method= iter.next();
			if (!filter.shouldRun(methodDescription(method)))
				iter.remove();
		}
		if (fTestMethods.isEmpty())
			throw new NoTestsRemainException();
",2.768595041322314
"        /* fredt - in FK constraints column lists for iColMain and iColRef have
           identical sets to visible columns of iMain and iRef respectively
           but the order of columns can be different and must be preserved
         */
        core.mainColArray = mainCols;
        core.colLen       = core.mainColArray.length;
        core.refColArray  = refCols;
",3.9421487603305785
"    /**
    * Adds a message to the list of messages that need to be displayed on the GUI.
    * @param message The message to add.
    */
    public synchronized void addMessage(GUIMessage message) {
        if (getMessageCount() == MESSAGE_COUNT) {
            messages.remove(0);
        }
        messages.add(message);

        freeColClient.getCanvas().repaint(0, 0, getWidth(), getHeight());
",3.603305785123967
"private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec0[i2] & l2) != 0L);
      default : 
         if ((jjbitVec1[i1] & l1) != 0L)
            return true;
         return false;
",2.644628099173554
"    private static Date correctTimeZone(final Date date) {
       Date ret=date;
       if(java.util.TimeZone.getDefault().useDaylightTime()){
            if(java.util.TimeZone.getDefault().inDaylightTime(date))
                ret.setTime(date.getTime()+1*60*60*1000);
        }
        return ret;
",2.87603305785124
"	@Override
	public String getMessage() {
		StringBuilder builder= new StringBuilder();
		if (fMessage != null)
			builder.append(fMessage);
		builder.append(""arrays first differed at element "");
",3.231404958677686
"    String getStateString() {

        int state = getState();

        switch (state) {

            case DATABASE_CLOSING :
                return ""DATABASE_CLOSING"";

            case DATABASE_ONLINE :
                return ""DATABASE_ONLINE"";
",4.289256198347108
"    public boolean displayTileCursor(Tile tile, int canvasX, int canvasY) {
        if (currentMode == ViewMode.VIEW_TERRAIN_MODE) {

            Position selectedTilePos = gui.getSelectedTile();
            if (selectedTilePos == null)
                return false;

            if (selectedTilePos.getX() == tile.getX() && selectedTilePos.getY() == tile.getY()) {
                TerrainCursor cursor = gui.getCursor();
",3.355371900826446
"private final int jjMoveStringLiteralDfa18_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(16, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(17, 0L, active1, active2);
",2.090909090909091
"    /**
     * Get the List of all available Channels
     * 
     * @return All available Channels
     */
    public ElgatoChannel[] getAvailableChannels() {
        ArrayList<ElgatoChannel> list = new ArrayList<ElgatoChannel>();

        String res = null;
        try {
            res = mAppleScript.executeScript(CHANNELLIST);
",3.363636363636364
"		private Method getParametersMethod() throws Exception {
			for (Method each : fKlass.getMethods()) {
				if (Modifier.isStatic(each.getModifiers())) {
					Annotation[] annotations= each.getAnnotations();
					for (Annotation annotation : annotations) {
						if (annotation.annotationType() == Parameters.class)
							return each;
					}
				}
			}
			throw new Exception(""No public static parameters method on class ""
					+ getName());
",2.355371900826446
"
        Node r = x.getRight();

        if (r != null) {
            x = r;

            Node l = x.getLeft();
",4.074380165289257
"        InGameInputHandler inGameInputHandler = freeColClient.getInGameInputHandler();

        freeColClient.getClient().setMessageHandler(inGameInputHandler);
        gui.setInGame(true);
",3.190082644628099
"    /**
     * Applies this action.
     * 
     * @param e The <code>ActionEvent</code>.
     */
    public void actionPerformed(ActionEvent e) {
        final Game game = freeColClient.getGame();
        final Map map = game.getMap();

        Parameters p = showParametersDialog();
",3.809917355371901
"    public ActionMenu getButtonAction() {
        AbstractAction action = new AbstractAction() {

            public void actionPerformed(ActionEvent evt) {
                showDialog();
            }
        };
        action.putValue(Action.NAME, mLocalizer.msg(""CapturePlugin"", ""Capture Plugin""));
        action.putValue(Action.SMALL_ICON, createImageIcon(""mimetypes"", ""video-x-generic"", 16));
",2.909090909090909
"			Description description= Description.createSuiteDescription(name);
			int n= ts.testCount();
			for (int i= 0; i < n; i++)
				description.addChild(makeDescription(ts.testAt(i)));
",3.008264462809917
"
        if (expression.exprType != VALUE && expression.exprType != COLUMN
                && expression.exprType != FUNCTION
                && expression.exprType != ALTERNATIVE
                && expression.exprType != CASEWHEN
                && expression.exprType != CONVERT) {
            StringBuffer temp = new StringBuffer();

            ddl = temp.append('(').append(ddl).append(')').toString();
        }

        return ddl;
",2.958677685950413
"    private synchronized void purgeOldMessagesFromMessagesToIgnore(int thisTurn) {
        List<String> keysToRemove = new ArrayList<String>();
        for (Entry<String, Integer> entry : messagesToIgnore.entrySet()) {
            if (entry.getValue().intValue() < thisTurn - 1) {
                if (logger.isLoggable(Level.FINER)) {
                    logger.finer(""Removing old model message with key "" + entry.getKey() + "" from ignored messages."");
                }
                keysToRemove.add(entry.getKey());
",2.1322314049586777
"@Override
    public void runTest(final Test test, final TestResult result) {
        Thread t = new Thread() {
            @Override
            public void run() {
                try {
                    // inlined due to limitation in VA/Java
                    //ActiveTestSuite.super.runTest(test, result);
                    test.run(result);
                } finally {
                    ActiveTestSuite.this.runFinished();
                }
            }
        };
        t.start();
    }",4.222222222222222
"/**
     * ...as the moon sets over the early morning Merlin, Oregon
     * mountains, our intrepid adventurers type...
     */
    static public Test createTest(Class<?> theClass, String name) {
        Constructor<?> constructor;
        try {
            constructor = getTestConstructor(theClass);
        } catch (NoSuchMethodException e) {
            return warning(""Class "" + theClass.getName() + "" has no public constructor TestCase(String name) or TestCase()"");
        }
        Object test;
        try {
            if (constructor.getParameterTypes().length == 0) {
                test = constructor.newInstance(new Object[0]);
                if (test instanceof TestCase) {
                    ((TestCase) test).setName(name);
                }
            } else {
                test = constructor.newInstance(new Object[]{name});
            }
        } catch (InstantiationException e) {
            return (warning(""Cannot instantiate test case: "" + name + "" ("" + exceptionToString(e) + "")""));
        } catch (InvocationTargetException e) {
            return (warning(""Exception in constructor: "" + name + "" ("" + exceptionToString(e.getTargetException()) + "")""));
        } catch (IllegalAccessException e) {
            return (warning(""Cannot access test case: "" + name + "" ("" + exceptionToString(e) + "")""));
        }
        return (Test) test;
    }",3.555555555555556
"/**
     * Provides serialization support.
     *
     * @param stream  the input stream (<code>null</code> not permitted).
     *
     * @throws IOException  if there is an I/O error.
     * @throws ClassNotFoundException  if there is a classpath problem.
     */
    private void readObject(ObjectInputStream stream)
        throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        this.titlePaint = SerialUtilities.readPaint(stream);
        this.subtitlePaint = SerialUtilities.readPaint(stream);
        this.chartBackgroundPaint = SerialUtilities.readPaint(stream);
        this.legendBackgroundPaint = SerialUtilities.readPaint(stream);
        this.legendItemPaint = SerialUtilities.readPaint(stream);
        this.plotBackgroundPaint = SerialUtilities.readPaint(stream);
        this.plotOutlinePaint = SerialUtilities.readPaint(stream);
        this.labelLinkPaint = SerialUtilities.readPaint(stream);
        this.baselinePaint = SerialUtilities.readPaint(stream);
        this.domainGridlinePaint = SerialUtilities.readPaint(stream);
        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);
        this.crosshairPaint = SerialUtilities.readPaint(stream);
        this.axisLabelPaint = SerialUtilities.readPaint(stream);
        this.tickLabelPaint = SerialUtilities.readPaint(stream);
        this.itemLabelPaint = SerialUtilities.readPaint(stream);
        this.shadowPaint = SerialUtilities.readPaint(stream);
        this.thermometerPaint = SerialUtilities.readPaint(stream);
        this.wallPaint = SerialUtilities.readPaint(stream);
        this.errorIndicatorPaint = SerialUtilities.readPaint(stream);
        this.gridBandPaint = SerialUtilities.readPaint(stream);
        this.gridBandAlternatePaint = SerialUtilities.readPaint(stream);
    }",3.555555555555556
"/**
     * Constructs a panel that displays the specified chart.
     *
     * @param chart  the chart.
     */
    public ChartPanel(JFreeChart chart) {

        this(
            chart,
            DEFAULT_WIDTH,
            DEFAULT_HEIGHT,
            DEFAULT_MINIMUM_DRAW_WIDTH,
            DEFAULT_MINIMUM_DRAW_HEIGHT,
            DEFAULT_MAXIMUM_DRAW_WIDTH,
            DEFAULT_MAXIMUM_DRAW_HEIGHT,
            DEFAULT_BUFFER_USED,
            true,  // properties
            true,  // save
            true,  // print
            true,  // zoom
            true   // tooltips
        );

    }",4.333333333333333
"/**
     * static initializer, register all appropriate notations.
     */
    static void init() {
        NotationProviderFactory2 npf = NotationProviderFactory2.getInstance();
        NotationName name = /*Notation.findNotation(""Java"");*/
            Notation.makeNotation(
                    ""Java"",
                    null,
                    ResourceLoaderWrapper.lookupIconResource(""JavaNotation""));

        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_NAME,
                name, ModelElementNameNotationJava.class);
        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_ATTRIBUTE,
                name, AttributeNotationJava.class);
        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_OPERATION,
                name, OperationNotationJava.class);
        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_ASSOCIATION_END_NAME,
                name, AssociationEndNameNotationJava.class);
        npf.addNotationProvider(
                NotationProviderFactory2.TYPE_ASSOCIATION_NAME,
                name, AssociationNameNotationJava.class);
    }",4.0
"/**
     * {@inheritDoc}
     *
     * Overridden to find the start of a line-end.
     */
    public boolean addChar(char c) {
	if (c == '\n') {
	    hasLf = true;
	    return true;
	}

	if (c == '\r') {
	    hasCr = true;
	    return true;
	}

	return false;
    }",4.555555555555555
"/**
     * Loads the bundle (if not already loaded).
     *
     * @param name The name of the bundle to load.
     */
    private static void loadBundle(String name) {
        if (bundles.containsKey(name)) {
            return;
        }
        String resource = BUNDLES_PATH + ""."" + name;
        ResourceBundle bundle = null;
        try {
            LOG.debug(""Loading "" + resource);
            bundle = ResourceBundle.getBundle(resource, Locale.getDefault());
        } catch (MissingResourceException e1) {
            LOG.debug(""Resource "" + resource
		      + "" not found in the default class loader."");

	    Iterator iter = classLoaders.iterator();
	    while (iter.hasNext()) {
		ClassLoader cl = (ClassLoader) iter.next();
		try {
		    LOG.debug(""Loading "" + resource + "" from "" + cl);
		    bundle =
			ResourceBundle.getBundle(resource,
						 Locale.getDefault(),
						 cl);
		    break;
		} catch (MissingResourceException e2) {
		    LOG.debug(""Resource "" + resource + "" not found in "" + cl);
		}
	    }
        }

        bundles.put(name, bundle);
    }",3.0
"protected synchronized String evalToString(
            Object self,
            String expr,
            String sep)
    	throws ExpansionException {

        _scratchBindings.put(""self"", self);
        java.util.List values = eval(_scratchBindings, expr);
        _strBuf.setLength(0);
        Iterator iter = values.iterator();
        while (iter.hasNext()) {
            Object v = iter.next();
            if (Model.getFacade().isAModelElement(v)) {
                v = Model.getFacade().getName(v);
                if ("""".equals(v)) {
                    v = Translator.localize(""misc.name.anon"");
                }
            }
            if (Model.getFacade().isAExpression(v)) {
                v = Model.getFacade().getBody(v);
                if ("""".equals(v)) {
                    v = ""(unspecified)"";
                }
            }
            if (!"""".equals(v)) {
                _strBuf.append(v);
                if (iter.hasNext()) {
                    _strBuf.append(sep);
                }
            }
        }
        return _strBuf.toString();
    }",3.111111111111111
"/**
     * Notify all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     * @see EventListenerList
     */
    public void fireTreeStructureChanged(
					 Object source,
					 Object[] path,
					 int[] childIndices,
					 Object[] children) {

        // Guaranteed to return a non-null array
        Object[] listeners = listenerList.getListenerList();
        TreeModelEvent e = null;
        // Process the listeners last to first, notifying
        // those that are interested in this event
        for (int i = listeners.length - 2; i >= 0; i -= 2) {
            if (listeners[i] == TreeModelListener.class) {
                // Lazily create the event:
                if (e == null)
                    e =
                        new TreeModelEvent(
					   source,
					   path,
					   childIndices,
					   children);
                ((TreeModelListener) listeners[i + 1]).treeStructureChanged(e);
            }
        }
    }",3.7777777777777777
"private void myDoubleClick(Object src) {
	Object sel = null;
	Diagram d = null;
	if (src == resultsTable) {
	    int row = resultsTable.getSelectionModel().getMinSelectionIndex();
	    if (row < 0) {
                return;
            }
	    sel = results.elementAt(row);
	    d = (Diagram) diagrams.elementAt(row);
	} else if (src == relatedTable) {
	    int row = relatedTable.getSelectionModel().getMinSelectionIndex();
	    if (row < 0) {
                return;
            }
	    numJumpToRelated++;
	    sel = related.elementAt(row);
	}

	if (d != null) {
            LOG.debug(""go "" + sel + "" in "" + d.getName());
            TargetManager.getInstance().setTarget(d);
        }
	TargetManager.getInstance().setTarget(sel);
    }",3.2222222222222223
"public void propertyChange(PropertyChangeEvent evt) {
        // the project changed
        if (evt.getPropertyName()
            .equals(ProjectManager.CURRENT_PROJECT_PROPERTY_NAME)) {
            Project p = (Project) evt.getNewValue();
            if (p != null) {
                titleHandler.buildTitle(p.getName(), null);
                //Designer.TheDesigner.getToDoList().removeAllElements();
                Designer.setCritiquingRoot(p);
                // update all panes
                TargetManager.getInstance().setTarget(p.getInitialTarget());
            }
        }
    }",4.0
"public void testFailure() {
        String expected = expected(new String[]{"".F"", ""Time: 0"", ""Failures here"", """", ""FAILURES!!!"", ""Tests run: 1,  Failures: 1,  Errors: 0"", """"});
        ResultPrinter printer = new TestResultPrinter(new PrintStream(output)) {
            @Override
            public void printFailures(TestResult result) {
                getWriter().println(""Failures here"");
            }
        };
        runner.setPrinter(printer);
        TestSuite suite = new TestSuite();
        suite.addTest(new TestCase() {
            @Override
            public void runTest() {
                throw new AssertionFailedError();
            }
        });
        runner.doRun(suite);
        assertEquals(expected, output.toString());
    }",3.333333333333333
"private Object createTestUsingFieldInjection() throws Exception {
            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();
            if (annotatedFieldsByParameter.size() != fParameters.length) {
                throw new Exception(""Wrong number of parameters and @Parameter fields."" +
                        "" @Parameter fields counted: "" + annotatedFieldsByParameter.size() + "", available parameters: "" + fParameters.length + ""."");
            }
            Object testClassInstance = getTestClass().getJavaClass().newInstance();
            for (FrameworkField each : annotatedFieldsByParameter) {
                Field field = each.getField();
                Parameter annotation = field.getAnnotation(Parameter.class);
                int index = annotation.value();
                try {
                    field.set(testClassInstance, fParameters[index]);
                } catch (IllegalArgumentException iare) {
                    throw new Exception(getTestClass().getName() + "": Trying to set "" + field.getName() +
                            "" with the value "" + fParameters[index] +
                            "" that is not the right type ("" + fParameters[index].getClass().getSimpleName() + "" instead of "" +
                            field.getType().getSimpleName() + "")."", iare);
                }
            }
            return testClassInstance;
        }",3.555555555555556
"@Override
        protected void validateFields(List<Throwable> errors) {
            super.validateFields(errors);
            if (fieldsAreAnnotated()) {
                List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();
                int[] usedIndices = new int[annotatedFieldsByParameter.size()];
                for (FrameworkField each : annotatedFieldsByParameter) {
                    int index = each.getField().getAnnotation(Parameter.class).value();
                    if (index < 0 || index > annotatedFieldsByParameter.size() - 1) {
                        errors.add(
                                new Exception(""Invalid @Parameter value: "" + index + "". @Parameter fields counted: "" +
                                        annotatedFieldsByParameter.size() + "". Please use an index between 0 and "" +
                                        (annotatedFieldsByParameter.size() - 1) + ""."")
                        );
                    } else {
                        usedIndices[index]++;
                    }
                }
                for (int index = 0; index < usedIndices.length; index++) {
                    int numberOfUse = usedIndices[index];
                    if (numberOfUse == 0) {
                        errors.add(new Exception(""@Parameter("" + index + "") is never used.""));
                    } else if (numberOfUse > 1) {
                        errors.add(new Exception(""@Parameter("" + index + "") is used more than once ("" + numberOfUse + "").""));
                    }
                }
            }
        }",3.555555555555556
"String[] parseOptions(String[] args) {
        for (int i = 0; i != args.length; ++i) {
            String arg = args[i];

            try {
                if (arg.equals(""--"")) {
                    return copyArray(args, i + 1, args.length);
                } else if (arg.startsWith(""--"")) {
                    if (arg.startsWith(""--filter="") || arg.equals(""--filter"")) {
                        String filterSpec;
                        if (arg.equals(""--filter"")) {
                            ++i;

                            if (i < args.length) {
                                filterSpec = args[i];
                            } else {
                                parserErrors.add(new CommandLineParserError(arg + "" value not specified""));

                                break;
                            }
                        } else {
                            filterSpec = arg.substring(arg.indexOf('=') + 1);
                        }

                        filter = filter.intersect(FilterFactories.createFilterFromFilterSpec(
                                createSuiteDescription(arg), filterSpec));
                    } else {
                        parserErrors.add(new CommandLineParserError(""JUnit knows nothing about the "" + arg + "" option""));
                    }
                } else {
                    return copyArray(args, i, args.length);
                }
            } catch (FilterFactory.FilterNotCreatedException e) {
                parserErrors.add(e);
            }
        }

        return new String[]{};
    }",2.6666666666666665
"private static Set<String> buildHintsSet() {
		HashSet<String> hints = new HashSet<String>();
		hints.add( HINT_TIMEOUT );
		hints.add( SPEC_HINT_TIMEOUT );
		hints.add( HINT_COMMENT );
		hints.add( HINT_FETCH_SIZE );
		hints.add( HINT_CACHE_REGION );
		hints.add( HINT_CACHEABLE );
		hints.add( HINT_READONLY );
		hints.add( HINT_CACHE_MODE );
		hints.add( HINT_FLUSH_MODE );
		hints.add( HINT_NATIVE_LOCKMODE );
		hints.add( HINT_FETCHGRAPH );
		hints.add( HINT_LOADGRAPH );
		return java.util.Collections.unmodifiableSet( hints );
	}",4.444444444444445
"@Test
	public void testHiLoAlgorithm() {
		session = (SessionImpl) sessionFactory.openSession();
		((Session)session).beginTransaction();

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// initially sequence should be uninitialized
		assertEquals( 0L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// historically the hilo generators skipped the initial block of values;
		// 		so the first generated id value is maxlo + 1, here be 4
		Long generatedValue = (Long) generator.generate( session, null );
		assertEquals( 1L, generatedValue.longValue() );
		// which should also perform the first read on the sequence which should set it to its ""start with"" value (1)
		assertEquals( 1L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		generatedValue = (Long) generator.generate( session, null );
		assertEquals( 2L, generatedValue.longValue() );
		assertEquals( 2L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		generatedValue = (Long) generator.generate( session, null );
		assertEquals( 3L, generatedValue.longValue() );
		assertEquals( 3L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		generatedValue = (Long) generator.generate( session, null );
		assertEquals( 4L, generatedValue.longValue() );
		assertEquals( 4L, extractSequenceValue( (session) ) );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		generatedValue = (Long) generator.generate( session, null );
		assertEquals( 5L, generatedValue.longValue() );
		assertEquals( 5L, extractSequenceValue( (session) ) );

		((Session)session).getTransaction().commit();
		((Session)session).close();
	}",3.6666666666666665
"/**
	 * Constructs a PostgresPlusDialect
	 */
	public PostgresPlusDialect() {
		super();

		registerFunction( ""ltrim"", new StandardSQLFunction( ""ltrim"" ) );
		registerFunction( ""rtrim"", new StandardSQLFunction( ""rtrim"" ) );
		registerFunction( ""soundex"", new StandardSQLFunction( ""soundex"" ) );
		registerFunction( ""sysdate"", new NoArgSQLFunction( ""sysdate"", StandardBasicTypes.DATE, false ) );
		registerFunction( ""rowid"", new NoArgSQLFunction( ""rowid"", StandardBasicTypes.LONG, false ) );
		registerFunction( ""rownum"", new NoArgSQLFunction( ""rownum"", StandardBasicTypes.LONG, false ) );
		registerFunction( ""instr"", new StandardSQLFunction( ""instr"", StandardBasicTypes.INTEGER ) );
		registerFunction( ""lpad"", new StandardSQLFunction( ""lpad"", StandardBasicTypes.STRING ) );
		registerFunction( ""replace"", new StandardSQLFunction( ""replace"", StandardBasicTypes.STRING ) );
		registerFunction( ""rpad"", new StandardSQLFunction( ""rpad"", StandardBasicTypes.STRING ) );
		registerFunction( ""translate"", new StandardSQLFunction( ""translate"", StandardBasicTypes.STRING ) );
		registerFunction( ""substring"", new StandardSQLFunction( ""substr"", StandardBasicTypes.STRING ) );
		registerFunction( ""coalesce"", new NvlFunction() );
		registerFunction( ""atan2"", new StandardSQLFunction( ""atan2"", StandardBasicTypes.FLOAT ) );
		registerFunction( ""mod"", new StandardSQLFunction( ""mod"", StandardBasicTypes.INTEGER ) );
		registerFunction( ""nvl"", new StandardSQLFunction( ""nvl"" ) );
		registerFunction( ""nvl2"", new StandardSQLFunction( ""nvl2"" ) );
		registerFunction( ""power"", new StandardSQLFunction( ""power"", StandardBasicTypes.FLOAT ) );
		registerFunction( ""add_months"", new StandardSQLFunction( ""add_months"", StandardBasicTypes.DATE ) );
		registerFunction( ""months_between"", new StandardSQLFunction( ""months_between"", StandardBasicTypes.FLOAT ) );
		registerFunction( ""next_day"", new StandardSQLFunction( ""next_day"", StandardBasicTypes.DATE ) );
	}",4.0
"/**
	 * Constructs a Oracle8iDialect
	 */
	public Oracle8iDialect() {
		super();
		registerCharacterTypeMappings();
		registerNumericTypeMappings();
		registerDateTimeTypeMappings();
		registerLargeObjectTypeMappings();
		registerReverseHibernateTypeMappings();
		registerFunctions();
		registerDefaultProperties();
	}",4.0
"/**
	 * Constructs a InterbaseDialect
	 */
	public InterbaseDialect() {
		super();
		registerColumnType( Types.BIT, ""smallint"" );
		registerColumnType( Types.BIGINT, ""numeric(18,0)"" );
		registerColumnType( Types.SMALLINT, ""smallint"" );
		registerColumnType( Types.TINYINT, ""smallint"" );
		registerColumnType( Types.INTEGER, ""integer"" );
		registerColumnType( Types.CHAR, ""char(1)"" );
		registerColumnType( Types.VARCHAR, ""varchar($l)"" );
		registerColumnType( Types.FLOAT, ""float"" );
		registerColumnType( Types.DOUBLE, ""double precision"" );
		registerColumnType( Types.DATE, ""date"" );
		registerColumnType( Types.TIME, ""time"" );
		registerColumnType( Types.TIMESTAMP, ""timestamp"" );
		registerColumnType( Types.VARBINARY, ""blob"" );
		registerColumnType( Types.NUMERIC, ""numeric($p,$s)"" );
		registerColumnType( Types.BLOB, ""blob"" );
		registerColumnType( Types.CLOB, ""blob sub_type 1"" );
		registerColumnType( Types.BOOLEAN, ""smallint"" );
		
		registerFunction( ""concat"", new VarArgsSQLFunction( StandardBasicTypes.STRING, ""("",""||"","")"" ) );
		registerFunction( ""current_date"", new NoArgSQLFunction( ""current_date"", StandardBasicTypes.DATE, false ) );

		getDefaultProperties().setProperty( Environment.STATEMENT_BATCH_SIZE, NO_BATCH );
	}",3.888888888888889
"/**
	 * Constructs a SybaseASE157Dialect
	 */
	public SybaseASE157Dialect() {
		super();

		registerFunction( ""create_locator"", new SQLFunctionTemplate( StandardBasicTypes.BINARY, ""create_locator(?1, ?2)"" ) );
		registerFunction( ""locator_literal"", new SQLFunctionTemplate( StandardBasicTypes.BINARY, ""locator_literal(?1, ?2)"" ) );
		registerFunction( ""locator_valid"", new SQLFunctionTemplate( StandardBasicTypes.BOOLEAN, ""locator_valid(?1)"" ) );
		registerFunction( ""return_lob"", new SQLFunctionTemplate( StandardBasicTypes.BINARY, ""return_lob(?1, ?2)"" ) );
		registerFunction( ""setdata"", new SQLFunctionTemplate( StandardBasicTypes.BOOLEAN, ""setdata(?1, ?2, ?3)"" ) );
		registerFunction( ""charindex"", new SQLFunctionTemplate( StandardBasicTypes.INTEGER, ""charindex(?1, ?2, ?3)"" ) );
	}",4.0
"public String extractConstraintName(SQLException sqle) {
			try {
				final int sqlState = Integer.valueOf( JdbcExceptionHelper.extractSqlState( sqle ) );
				switch (sqlState) {
					// CHECK VIOLATION
					case 23514: return extractUsingTemplate( ""violates check constraint \"""",""\"""", sqle.getMessage() );
					// UNIQUE VIOLATION
					case 23505: return extractUsingTemplate( ""violates unique constraint \"""",""\"""", sqle.getMessage() );
					// FOREIGN KEY VIOLATION
					case 23503: return extractUsingTemplate( ""violates foreign key constraint \"""",""\"""", sqle.getMessage() );
					// NOT NULL VIOLATION
					case 23502: return extractUsingTemplate( ""null value in column \"""",""\"" violates not-null constraint"", sqle.getMessage() );
					// TODO: RESTRICT VIOLATION
					case 23001: return null;
					// ALL OTHER
					default: return null;
				}
			}
			catch (NumberFormatException nfe) {
				return null;
			}
		}",4.555555555555555
"@Test
	@TestForIssue(jiraKey = ""HHH-8007"")
	public void testGetLimitStringSelectingMultipleColumnsFromSeveralTables() {
		final String query = ""select t1.*, t2.* from tab1 t1, tab2 t2 where t1.ref = t2.ref order by t1.id desc"";

		assertEquals(
				""WITH query AS (SELECT inner_query.*, ROW_NUMBER() OVER (ORDER BY CURRENT_TIMESTAMP) as __hibernate_row_nr__ FROM ( "" +
						""select TOP(?) t1.*, t2.* from tab1 t1, tab2 t2 where t1.ref = t2.ref order by t1.id desc ) inner_query ) "" +
						""SELECT * FROM query WHERE __hibernate_row_nr__ >= ? AND __hibernate_row_nr__ < ?"",
				dialect.buildLimitHandler( query, toRowSelection( 1, 3 ) ).getProcessedSql()
		);
	}",3.2222222222222223
"@Test
	public void testInsertLimitWithForUpdateAndWithClauses() {
		final int limit = 50;
		final int offset = 200;
		final String input = ""select c11 as col1, c12 as col2, c13 as col13 from t1 where flight_id between 'AA1111' and 'AA1112' for update of c11,c13 with rr"";
		final String expected = ""select c11 as col1, c12 as col2, c13 as col13 from t1 where flight_id between 'AA1111' and 'AA1112' offset "" + offset
				+ "" rows fetch next "" + limit + "" rows only for update of c11,c13 with rr"";

		final String actual = new LocalDerbyDialect().getLimitString( input, offset, limit );
		assertEquals( expected, actual );
	}",3.6666666666666665
"/**
	 * Constructs a FrontBaseDialect
	 */
	public FrontBaseDialect() {
		super();

		registerColumnType( Types.BIT, ""bit"" );
		registerColumnType( Types.BIGINT, ""longint"" );
		registerColumnType( Types.SMALLINT, ""smallint"" );
		registerColumnType( Types.TINYINT, ""tinyint"" );
		registerColumnType( Types.INTEGER, ""integer"" );
		registerColumnType( Types.CHAR, ""char(1)"" );
		registerColumnType( Types.VARCHAR, ""varchar($l)"" );
		registerColumnType( Types.FLOAT, ""float"" );
		registerColumnType( Types.DOUBLE, ""double precision"" );
		registerColumnType( Types.DATE, ""date"" );
		registerColumnType( Types.TIME, ""time"" );
		registerColumnType( Types.TIMESTAMP, ""timestamp"" );
		registerColumnType( Types.VARBINARY, ""bit varying($l)"" );
		registerColumnType( Types.NUMERIC, ""numeric($p,$s)"" );
		registerColumnType( Types.BLOB, ""blob"" );
		registerColumnType( Types.CLOB, ""clob"" );
	}",4.222222222222222
"@Test
	public void testSqlTrimFunction() {
		String fragment = ""trim( col )"";
		String template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim("" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( both from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(both from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( leading from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(leading from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( TRAILING from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(TRAILING from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( 'b' from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim('b' from "" + Template.TEMPLATE + "".col)"", template );

		fragment = ""trim( both 'b' from col )"";
		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
		assertEquals( ""trim(both 'b' from "" + Template.TEMPLATE + "".col)"", template );
	}",3.2222222222222223
"private void considerExplicitFieldAndPropertyAccess() {
		for ( XProperty property : fieldAccessMap.values() ) {
			Access access = property.getAnnotation( Access.class );
			if ( access == null ) {
				continue;
			}

			// see ""2.3.2 Explicit Access Type"" of JPA 2 spec
			// the access type for this property is explicitly set to AccessType.FIELD, hence we have to
			// use field access for this property even if the default access type for the class is AccessType.PROPERTY
			AccessType accessType = AccessType.getAccessStrategy( access.value() );
            if (accessType == AccessType.FIELD) {
				propertyAccessMap.put(property.getName(), property);
			}
            else {
				LOG.debug( ""Placing @Access(AccessType.FIELD) on a field does not have any effect."" );
			}
		}

		for ( XProperty property : propertyAccessMap.values() ) {
			Access access = property.getAnnotation( Access.class );
			if ( access == null ) {
				continue;
			}

			AccessType accessType = AccessType.getAccessStrategy( access.value() );

			// see ""2.3.2 Explicit Access Type"" of JPA 2 spec
			// the access type for this property is explicitly set to AccessType.PROPERTY, hence we have to
			// return use method access even if the default class access type is AccessType.FIELD
            if (accessType == AccessType.PROPERTY) {
				fieldAccessMap.put(property.getName(), property);
			}
            else {
				LOG.debug( ""Placing @Access(AccessType.PROPERTY) on a field does not have any effect."" );
			}
		}
	}",3.7777777777777777
"private static Ejb3DiscriminatorColumn processDiscriminatorProperties(XClass clazzToProcess, Mappings mappings, InheritanceState inheritanceState, EntityBinder entityBinder) {
		Ejb3DiscriminatorColumn discriminatorColumn = null;
		javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(
				javax.persistence.DiscriminatorColumn.class
		);
		DiscriminatorType discriminatorType = discAnn != null ?
				discAnn.discriminatorType() :
				DiscriminatorType.STRING;

		org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(
				org.hibernate.annotations.DiscriminatorFormula.class
		);
		if ( !inheritanceState.hasParents() ) {
			discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(
					discriminatorType, discAnn, discFormulaAnn, mappings
			);
		}
		if ( discAnn != null && inheritanceState.hasParents() ) {
			LOG.invalidDiscriminatorAnnotation( clazzToProcess.getName() );
		}

		String discrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?
				clazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :
				null;
		entityBinder.setDiscriminatorValue( discrimValue );

		DiscriminatorOptions discriminatorOptions = clazzToProcess.getAnnotation( DiscriminatorOptions.class );
		if ( discriminatorOptions != null) {
			entityBinder.setForceDiscriminator( discriminatorOptions.force() );
			entityBinder.setInsertableDiscriminator( discriminatorOptions.insert() );
		}

		return discriminatorColumn;
	}",2.333333333333333
"private static boolean isEntityClassType(XClass clazzToProcess, AnnotatedClassType classType) {
		if ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities
				|| AnnotatedClassType.NONE.equals( classType ) //to be ignored
				|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration
				) {
			if ( AnnotatedClassType.NONE.equals( classType )
					&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {
				LOG.missingEntityAnnotation( clazzToProcess.getName() );
			}
			return false;
		}

		if ( !classType.equals( AnnotatedClassType.ENTITY ) ) {
			throw new AnnotationException(
					""Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: "" + clazzToProcess
							.getName()
			);
		}

		return true;
	}",3.6666666666666665
"public void redefineColumnName(String columnName, String propertyName, boolean applyNamingStrategy) {
		if ( applyNamingStrategy ) {
			if ( StringHelper.isEmpty( columnName ) ) {
				if ( propertyName != null ) {
					mappingColumn.setName(
							mappings.getObjectNameNormalizer().normalizeIdentifierQuoting(
									mappings.getNamingStrategy().propertyToColumnName( propertyName )
							)
					);
				}
				//Do nothing otherwise
			}
			else {
				columnName = mappings.getObjectNameNormalizer().normalizeIdentifierQuoting( columnName );
				columnName = mappings.getNamingStrategy().columnName( columnName );
				columnName = mappings.getObjectNameNormalizer().normalizeIdentifierQuoting( columnName );
				mappingColumn.setName( columnName );
			}
		}
		else {
			if ( StringHelper.isNotEmpty( columnName ) ) {
				mappingColumn.setName( mappings.getObjectNameNormalizer().normalizeIdentifierQuoting( columnName ) );
			}
		}
	}",3.4444444444444446
"private static void parseFilter(Element filterElement, Filterable filterable, Mappings model) {
		final String name = filterElement.attributeValue( ""name"" );
		String condition = filterElement.getTextTrim();
		if ( StringHelper.isEmpty(condition) ) {
			condition = filterElement.attributeValue( ""condition"" );
		}
		//TODO: bad implementation, cos it depends upon ordering of mapping doc
		//      fixing this requires that Collection/PersistentClass gain access
		//      to the Mappings reference from Configuration (or the filterDefinitions
		//      map directly) sometime during Configuration.build
		//      (after all the types/filter-defs are known and before building
		//      persisters).
		if ( StringHelper.isEmpty(condition) ) {
			condition = model.getFilterDefinition(name).getDefaultFilterCondition();
		}
		if ( condition==null) {
			throw new MappingException(""no filter condition found for filter: "" + name);
		}
		Iterator aliasesIterator = filterElement.elementIterator(""aliases"");
		java.util.Map<String, String> aliasTables = new HashMap<String, String>();
		while (aliasesIterator.hasNext()){
			Element alias = (Element) aliasesIterator.next();
			aliasTables.put(alias.attributeValue(""alias""), alias.attributeValue(""table""));
		}
		LOG.debugf( ""Applying filter [%s] as [%s]"", name, condition );
		String autoAliasInjectionText = filterElement.attributeValue(""autoAliasInjection"");
		boolean autoAliasInjection = StringHelper.isEmpty(autoAliasInjectionText) ? true : Boolean.parseBoolean(autoAliasInjectionText);
		filterable.addFilter(name, condition, autoAliasInjection, aliasTables, null);
	}",3.2222222222222223
"/**
     * Retrieves a PropertyAccessor instance based on the given property definition and
     * entity mode.
     *
     * @param property The property for which to retrieve an accessor.
     * @param mode The mode for the resulting entity.
     * @return An appropriate accessor.
     * @throws MappingException
     */
	public static PropertyAccessor getPropertyAccessor(AttributeBinding property, EntityMode mode) throws MappingException {
		//TODO: this is temporary in that the end result will probably not take a Property reference per-se.
	    if ( null == mode || EntityMode.POJO.equals( mode ) ) {
		    return getPojoPropertyAccessor( property.getPropertyAccessorName() );
	    }
	    else if ( EntityMode.MAP.equals( mode ) ) {
		    return getDynamicMapPropertyAccessor();
	    }
	    else {
		    throw new MappingException( ""Unknown entity mode ["" + mode + ""]"" );
	    }
	}",4.333333333333333
"/**
	 * Execute given <tt>PreparedStatement</tt>, advance to the first result and return SQL <tt>ResultSet</tt>.
	 */
	protected final ResultSet getResultSet(
			final PreparedStatement st,
			final RowSelection selection,
			final LimitHandler limitHandler,
			final boolean autodiscovertypes,
			final SessionImplementor session)
	throws SQLException, HibernateException {

		try {
			ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( st );
			rs = wrapResultSetIfEnabled( rs , session );

			if ( !limitHandler.supportsLimitOffset() || !LimitHelper.useLimit( limitHandler, selection ) ) {
				advance( rs, selection );
			}

			if ( autodiscovertypes ) {
				autoDiscoverTypes( rs );
			}
			return rs;
		}
		catch ( SQLException sqle ) {
			session.getTransactionCoordinator().getJdbcCoordinator().release( st );
			throw sqle;
		}
	}",4.0
"/**
	 * Generate a select list of columns containing all properties of the entity classes
	 */
	protected final String selectString(List associations)
	throws MappingException {

		if ( associations.size()==0 ) {
			return """";
		}
		else {
			StringBuilder buf = new StringBuilder( associations.size() * 100 );
			int entityAliasCount=0;
			int collectionAliasCount=0;
			for ( int i=0; i<associations.size(); i++ ) {
				OuterJoinableAssociation join = (OuterJoinableAssociation) associations.get(i);
				OuterJoinableAssociation next = (i == associations.size() - 1)
				        ? null
				        : ( OuterJoinableAssociation ) associations.get( i + 1 );
				final Joinable joinable = join.getJoinable();
				final String entitySuffix = ( suffixes == null || entityAliasCount >= suffixes.length )
				        ? null
				        : suffixes[entityAliasCount];
				final String collectionSuffix = ( collectionSuffixes == null || collectionAliasCount >= collectionSuffixes.length )
				        ? null
				        : collectionSuffixes[collectionAliasCount];
				final String selectFragment = joinable.selectFragment(
						next == null ? null : next.getJoinable(),
						next == null ? null : next.getRHSAlias(),
						join.getRHSAlias(),
						entitySuffix,
				        collectionSuffix,
						join.getJoinType()==JoinType.LEFT_OUTER_JOIN
				);
				if (selectFragment.trim().length() > 0) {
					buf.append("", "").append(selectFragment);
				}
				if ( joinable.consumesEntityAlias() ) entityAliasCount++;
				if ( joinable.consumesCollectionAlias() && join.getJoinType()==JoinType.LEFT_OUTER_JOIN ) collectionAliasCount++;
			}
			return buf.toString();
		}
	}",2.555555555555556
"@Test
	public void testProperties() throws Exception {
		final Properties props = new Properties();

		props.put(""rpt.1.hibernate.dialect"", ""org.hibernate.dialect.DerbyDialect"");
		props.put(""rpt.2.hibernate.connection.driver_class"", ""org.apache.derby.jdbc.ClientDriver"");
		props.put(""rpt.3.hibernate.connection.url"", ""jdbc:derby://localhost:1527/db/reports.db"");
		props.put(""rpt.4.hibernate.connection.username"", ""sa"");
		props.put(""rpt.5.hibernate.connection.password_enc"", ""76f271db3661fd50082e68d4b953fbee"");
		props.put(""rpt.6.hibernate.connection.password_enc"", ""76f271db3661fd50082e68d4b953fbee"");
		props.put(""hibernate.connection.create"", ""true"");

		final Properties outputProps = ConnectionProviderInitiator.getConnectionProperties( props );
		Assert.assertEquals( 1, outputProps.size() );
		Assert.assertEquals( ""true"", outputProps.get( ""create"" ) );
	}",4.222222222222222
"public boolean equals(Table table) {
		if (null == table) {
			return false;
		}
		if (this == table) {
			return true;
		}

		return isQuoted() ? name.equals(table.getName()) : name.equalsIgnoreCase(table.getName())
			&& ((schema == null && table.getSchema() != null) ? false : (schema == null) ? true : isSchemaQuoted() ? schema.equals(table.getSchema()) : schema.equalsIgnoreCase(table.getSchema()))
			&& ((catalog == null && table.getCatalog() != null) ? false : (catalog == null) ? true : isCatalogQuoted() ? catalog.equals(table.getCatalog()) : catalog.equalsIgnoreCase(table.getCatalog()));
	}",2.2222222222222223
"public int getSqlTypeCode(Mapping mapping) throws MappingException {
        org.hibernate.type.Type type = getValue().getType();
        try {
            int sqlTypeCode = type.sqlTypes( mapping )[getTypeIndex()];
            if ( getSqlTypeCode() != null && getSqlTypeCode() != sqlTypeCode ) {
                throw new MappingException( ""SQLType code's does not match. mapped as "" + sqlTypeCode + "" but is "" + getSqlTypeCode() );
            }
            return sqlTypeCode;
        }
        catch ( Exception e ) {
            throw new MappingException(
                    ""Could not determine type for column "" +
                            name +
                            "" of type "" +
                            type.getClass().getName() +
                            "": "" +
                            e.getClass().getName(),
                    e
            );
        }
    }",3.7777777777777777
"/**
     * Provides serialization support.
     *
     * @param stream  the output stream.
     *
     * @throws IOException  if there is an I/O error.
     */
    private void writeObject(ObjectOutputStream stream) throws IOException {
        stream.defaultWriteObject();

        SerialUtilities.writeShape(this.legendItemShape, stream);
        SerialUtilities.writePaint(this.seriesPaint, stream);
        SerialUtilities.writePaint(this.baseSeriesPaint, stream);
        SerialUtilities.writePaint(this.seriesOutlinePaint, stream);
        SerialUtilities.writePaint(this.baseSeriesOutlinePaint, stream);
        SerialUtilities.writeStroke(this.seriesOutlineStroke, stream);
        SerialUtilities.writeStroke(this.baseSeriesOutlineStroke, stream);
        SerialUtilities.writePaint(this.labelPaint, stream);
        SerialUtilities.writePaint(this.axisLinePaint, stream);
        SerialUtilities.writeStroke(this.axisLineStroke, stream);
    }",4.222222222222222
"/**
     * Tests another object for equality with this object.
     *
     * @param obj  the object to test (<code>null</code> permitted).
     *
     * @return A boolean.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof PinNeedle)) {
            return false;
        }
        if (!super.equals(obj)) {
            return false;
        }
        return true;
    }",4.777777777777778
"/**
     * Tests this dataset for equality with an arbitrary object.
     *
     * @param obj  the object (<code>null</code> permitted).
     *
     * @return A boolean.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof CategoryDataset)) {
            return false;
        }
        CategoryDataset that = (CategoryDataset) obj;
        if (!getRowKeys().equals(that.getRowKeys())) {
            return false;
        }
        if (!getColumnKeys().equals(that.getColumnKeys())) {
            return false;
        }
        int rowCount = getRowCount();
        int colCount = getColumnCount();
        for (int r = 0; r < rowCount; r++) {
            for (int c = 0; c < colCount; c++) {
                Number v1 = getValue(r, c);
                Number v2 = that.getValue(r, c);
                if (v1 == null) {
                    if (v2 != null) {
                        return false;
                    }
                }
                else if (!v1.equals(v2)) {
                    return false;
                }
            }
        }
        return true;
    }",4.222222222222222
"/**
     * Returns the minimum and maximum values for the dataset's range
     * (y-values), assuming that the series in one category are stacked.
     *
     * @param dataset  the dataset (<code>null</code> not permitted).
     * @param base  the base value for the bars.
     *
     * @return The range (<code>null</code> if the dataset contains no values).
     */
    public static Range findStackedRangeBounds(CategoryDataset dataset,
            double base) {
        ParamChecks.nullNotPermitted(dataset, ""dataset"");
        Range result = null;
        double minimum = Double.POSITIVE_INFINITY;
        double maximum = Double.NEGATIVE_INFINITY;
        int categoryCount = dataset.getColumnCount();
        for (int item = 0; item < categoryCount; item++) {
            double positive = base;
            double negative = base;
            int seriesCount = dataset.getRowCount();
            for (int series = 0; series < seriesCount; series++) {
                Number number = dataset.getValue(series, item);
                if (number != null) {
                    double value = number.doubleValue();
                    if (value > 0.0) {
                        positive = positive + value;
                    }
                    if (value < 0.0) {
                        negative = negative + value;
                        // '+', remember value is negative
                    }
                }
            }
            minimum = Math.min(minimum, negative);
            maximum = Math.max(maximum, positive);
        }
        if (minimum <= maximum) {
            result = new Range(minimum, maximum);
        }
        return result;

    }",4.111111111111111
"/**
     * Tests the equality of this object against an arbitrary Object.
     * <P>
     * This method will return true ONLY if the object is a Second object
     * representing the same second as this instance.
     *
     * @param obj  the object to compare (<code>null</code> permitted).
     *
     * @return <code>true</code> if second and minute of this and the object
     *         are the same.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof Second)) {
            return false;
        }
        Second that = (Second) obj;
        if (this.second != that.second) {
            return false;
        }
        if (this.minute != that.minute) {
            return false;
        }
        if (this.hour != that.hour) {
            return false;
        }
        if (!this.day.equals(that.day)) {
            return false;
        }
        return true;
    }",4.666666666666667
"private void handleFireEvent(ArgoEvent event, ArgoEventListener listener) {
        if (event.getEventType() == ArgoEventTypes.ANY_EVENT) {
            if (listener instanceof ArgoModuleEventListener) {
                handleFireModuleEvent((ArgoModuleEvent) event,
				      (ArgoModuleEventListener) listener);
            }
            if (listener instanceof ArgoNotationEventListener) {
                handleFireNotationEvent((ArgoNotationEvent) event,
					(ArgoNotationEventListener) listener);
            }
        } else {
            if (event.getEventType() >= ArgoEventTypes.ANY_MODULE_EVENT
                && event.getEventType() < ArgoEventTypes.LAST_MODULE_EVENT) {
                if (listener instanceof ArgoModuleEventListener) {
                    handleFireModuleEvent((ArgoModuleEvent) event,
					  (ArgoModuleEventListener) listener);
                }
            }
            if (event.getEventType() >= ArgoEventTypes.ANY_NOTATION_EVENT
                && event.getEventType() < ArgoEventTypes.LAST_NOTATION_EVENT) {
                if (listener instanceof ArgoNotationEventListener) {
                    handleFireNotationEvent((ArgoNotationEvent) event,
					(ArgoNotationEventListener) listener);
                }
            }
            if (event.getEventType() >= ArgoEventTypes.ANY_GENERATOR_EVENT
                && event.getEventType() < ArgoEventTypes.LAST_GENERATOR_EVENT) {
                if (listener instanceof ArgoGeneratorEventListener) {
                    handleFireGeneratorEvent((ArgoGeneratorEvent) event,
                            (ArgoGeneratorEventListener) listener);
                }
            }
        }
    }",2.888888888888889
"/**
     * Find an element in the list.
     *
     * This is a little more complex than the simple lookup since it might be
     * that we are indexing with a class and the list contains interfaces.
     *
     * Since the hashtable lookup is a lot faster than the linear search we
     * add the result of the linear search to the hashtable so that the next
     * time we need not do it.
     *
     * @return Checklist or null if noone exist.
     * @param cls the class to lookup.
     */
    private static Checklist lookupChecklist(Class cls) {
        if (lists.contains(cls)) {
            return (Checklist) lists.get(cls);
	}

        // Now lets search
        Enumeration enumeration = lists.keys();

        while (enumeration.hasMoreElements()) {
            Object clazz = enumeration.nextElement();

            Class[] intfs = cls.getInterfaces();
            for (int i = 0; i < intfs.length; i++) {
                if (intfs[i].equals(clazz)) {
                    // We found it!
                    Checklist chlist = (Checklist) lists.get(clazz);

                    // Enter the class to speed up the next search.
                    lists.put(cls, chlist);
                    return chlist;
                }
            }
        }

        return null;
    }",4.0
"/**
     * @return a list of all the types
     */
    public static Vector getTypes() {
        if (types == null) {
            types = new Vector();
            types.addElement(new KnowledgeTypeNode(Critic.KT_DESIGNERS));
            types.addElement(new KnowledgeTypeNode(Critic.KT_CORRECTNESS));
            types.addElement(new KnowledgeTypeNode(Critic.KT_COMPLETENESS));
            types.addElement(new KnowledgeTypeNode(Critic.KT_CONSISTENCY));
            types.addElement(new KnowledgeTypeNode(Critic.KT_SYNTAX));
            types.addElement(new KnowledgeTypeNode(Critic.KT_SEMANTICS));
            types.addElement(new KnowledgeTypeNode(Critic.KT_OPTIMIZATION));
            types.addElement(new KnowledgeTypeNode(Critic.KT_PRESENTATION));
            types.addElement(new KnowledgeTypeNode(Critic.KT_ORGANIZATIONAL));
            types.addElement(new KnowledgeTypeNode(Critic.KT_EXPERIENCIAL));
            types.addElement(new KnowledgeTypeNode(Critic.KT_TOOL));
        }
        return types;
    }",4.333333333333333
"public void toDoItemsRemoved(ToDoListEvent tde) {
	LOG.debug(""toDoItemRemoved"");
        Vector items = tde.getToDoItems();
        int nItems = items.size();
        
	ToDoList list = Designer.theDesigner().getToDoList(); //source?
	Object[] path = new Object[2];
	path[0] = Designer.theDesigner().getToDoList();


	Enumeration elems = list.getPosters().elements();
 	while (elems.hasMoreElements()) {
	    Poster p = (Poster) elems.nextElement();
            boolean anyInPoster = false;
            for (int i = 0; i < nItems; i++) {
                ToDoItem item = (ToDoItem) items.elementAt(i);
                Poster post = item.getPoster();
                if (post == p) { 
                    anyInPoster = true;
                    break;
                }
            }
            if (!anyInPoster) { 
                continue;
            }
	    path[1] = p;
	    fireTreeStructureChanged(path);
	}
    }",3.333333333333333
"public void updateListener(PropertyChangeListener listener, 
            Object modelElement,
            PropertyChangeEvent pce) {
        Object obj = pce.getSource();
        if ((obj == modelElement) 
                && ""stereotype"".equals(pce.getPropertyName())) {
            if (pce instanceof AddAssociationEvent 
                    && Model.getFacade().isAStereotype(pce.getNewValue())) {
                // new stereotype
                addElementListener(
                        listener, 
                        pce.getNewValue(), 
                        new String[] {""name"", ""remove""});
            }
            if (pce instanceof RemoveAssociationEvent 
                    && Model.getFacade().isAStereotype(pce.getOldValue())) {
                // removed stereotype
                removeElementListener(
                        listener, 
                        pce.getOldValue());
            }
        }
    }",3.6666666666666665
"/**
     * @param filename the filename to read from
     */
    public void read(String filename) {
        try {
            FileReader f = new FileReader(filename);
            BufferedReader fr = new BufferedReader(f);

            String line = """";
            String content = """";
            boolean inSection = false;
            while (line != null) {
                line = fr.readLine();
                if (line != null) {
                    if (inSection) {
                        String sectionId = getSectId(line);
                        if (sectionId != null) {
                            inSection = false;
                            mAry.put(sectionId, content);
                            content = """";
                        } else {
                            content += line + LINE_SEPARATOR;
                        }
                    } else {
                        String sectionId = getSectId(line);
                        if (sectionId != null) {
                            inSection = true;
                        }
                    }
                }
            }
            fr.close();
        } catch (IOException e) {
            LOG.error(""Error: "" + e.toString());
        }
    }",4.111111111111111
"private boolean saveGraphicsToFile(File theFile, CmdSaveGraphics cmd,
            boolean overwrite) throws IOException {
        if ( theFile.exists() && !overwrite ) {
            int response =
		JOptionPane.showConfirmDialog(ArgoFrame.getInstance(),
                    Translator.messageFormat(""optionpane.confirm-overwrite"",
                            new Object[] {theFile}),
                    Translator.localize(""optionpane.confirm-overwrite-title""),
                    JOptionPane.YES_NO_OPTION);
            if (response == JOptionPane.NO_OPTION) return false;
        }
        FileOutputStream fo = null;
        try {
            fo = new FileOutputStream( theFile );
            cmd.setStream(fo);
            cmd.setScale(Configuration.getInteger(
                    SaveGraphicsManager.KEY_GRAPHICS_RESOLUTION, 1));
            cmd.doIt();
        } finally {
            if (fo != null) {
                fo.close();
            }
        }
        return true;
    }",2.7777777777777777
"public void targetAdded(TargetEvent e) {
            if (!updatingSelection) {
                updatingSelection = true;
                Object[] targets = e.getAddedTargets();

                int rows = getRowCount();
                for (int i = 0; i < targets.length; i++) {
                    Object target = targets[i];
                    if (target instanceof Fig) {
                        target = ((Fig) target).getOwner();
                    }
                    for (int j = 0; j < rows; j++) {
                        Object rowItem =
                            ((DefaultMutableTreeNode)
                                    getPathForRow(j).getLastPathComponent())
                            .getUserObject();
                        if (rowItem == target) {
                            updatingSelectionViaTreeSelection = true;
                            addSelectionRow(j);
                            updatingSelectionViaTreeSelection = false;
                        }
                    }
                }

                if (getSelectionCount() > 0) {
                    scrollRowToVisible(getSelectionRows()[0]);
                }
                updatingSelection = false;
            }
            // setTargets(e.getNewTargets());
        }",3.111111111111111
"/**
     * Saves the given actions in the configuration file
     * 
     * @param newActions
     *            the actions array
     */
    public static void saveShortcuts(Action[] newActions) {
        for (int i = 0; i < newActions.length; i++) {
            Action oldAction = (Action) shortcutHash
                    .get(newActions[i].getKey());
            if (newActions[i].getCurrentShortcut() == null
                    && newActions[i].getDefaultShortcut() != null) {
                // if a default action was voided then we have to save it
                Configuration.setString(Configuration.makeKey(oldAction
                        .getKey()), """");
            } else if (newActions[i].getCurrentShortcut() != null
                    && !newActions[i].getCurrentShortcut().equals(
                            newActions[i].getDefaultShortcut())) {
                // if a not-default current shortcut was added, then we have to
                // save it
                Configuration.setString(Configuration.makeKey(oldAction
                        .getKey()), KeyEventUtils.formatKeyStroke(newActions[i]
                        .getCurrentShortcut()));
            } else {
                // if the actual is not going to be saved, then try to remove it
                // (as it could have been cancelled)
                Configuration.removeKey(Configuration.makeKey(oldAction
                        .getKey()));
            }
        }
    }",3.4444444444444446
"protected void scanAnnotatedMembers(Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations, Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations) {
        for (Class<?> eachClass : getSuperClasses(fClass)) {
            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {
                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);
            }
            // ensuring fields are sorted to make sure that entries are inserted
            // and read from fieldForAnnotations in a deterministic order
            for (Field eachField : getSortedDeclaredFields(eachClass)) {
                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);
            }
        }
    }",4.0
"/**
     * Verifies that listeners added with addFirstListener() while tests are run concurrently are
     * notified about test failures.
     */
    @Test
    public void reportConcurrentFailuresAfterAddFirstListener() throws Exception {
        new AbstractConcurrentFailuresTest() {
            @Override
            protected void addListener(ExaminedListener listener) {
                fNotifier.addFirstListener(listener);
            }
        }.test();
    }",4.222222222222222
"private static Description makeDescription(Test test) {
        if (test instanceof TestCase) {
            TestCase tc = (TestCase) test;
            return Description.createTestDescription(tc.getClass(), tc.getName(),
                    getAnnotations(tc));
        } else if (test instanceof TestSuite) {
            TestSuite ts = (TestSuite) test;
            String name = ts.getName() == null ? createSuiteDescription(ts) : ts.getName();
            Description description = Description.createSuiteDescription(name);
            int n = ts.testCount();
            for (int i = 0; i < n; i++) {
                Description made = makeDescription(ts.testAt(i));
                description.addChild(made);
            }
            return description;
        } else if (test instanceof Describable) {
            Describable adapter = (Describable) test;
            return adapter.getDescription();
        } else if (test instanceof TestDecorator) {
            TestDecorator decorator = (TestDecorator) test;
            return makeDescription(decorator.getTest());
        } else {
            // This is the best we can do in this case
            return Description.createSuiteDescription(test.getClass());
        }
    }",4.111111111111111
"private EntityManager internalCreateEntityManager(SynchronizationType synchronizationType, Map map) {
		validateNotClosed();

		//TODO support discardOnClose, persistencecontexttype?, interceptor,
		return new EntityManagerImpl(
				this,
				PersistenceContextType.EXTENDED,
				synchronizationType,
				transactionType,
				discardOnClose,
				sessionInterceptorClass,
				map
		);
	}",4.222222222222222
"@Test
	public void testBasicHiLoOptimizerUsage() {
		int increment = 10;
		Long next;

		// test historic sequence behavior, where the initial values start at 1...
		SourceMock sequence = new SourceMock( 1 );
		Optimizer optimizer = buildHiloOptimizer( -1, increment );
		for ( int i = 1; i <= increment; i++ ) {
			next = ( Long ) optimizer.generate( sequence );
			assertEquals( i, next.intValue() );
		}
		assertEquals( 1, sequence.getTimesCalled() ); // once to initialze state
		assertEquals( 1, sequence.getCurrentValue() );
		// force a ""clock over""
		next = ( Long ) optimizer.generate( sequence );
		assertEquals( 11, next.intValue() );
		assertEquals( 2, sequence.getTimesCalled() );
		assertEquals( 2, sequence.getCurrentValue() );

		// test historic table behavior, where the initial values started at 0 (we now force 1 to be the first used id value)
		sequence = new SourceMock( 0 );
		optimizer = buildHiloOptimizer( -1, increment );
		for ( int i = 1; i <= increment; i++ ) {
			next = ( Long ) optimizer.generate( sequence );
			assertEquals( i, next.intValue() );
		}
		assertEquals( 2, sequence.getTimesCalled() ); // here have have an extra call to get to 1 initially
		assertEquals( 1, sequence.getCurrentValue() );
		// force a ""clock over""
		next = ( Long ) optimizer.generate( sequence );
		assertEquals( 11, next.intValue() );
		assertEquals( 3, sequence.getTimesCalled() );
		assertEquals( 2, sequence.getCurrentValue() );
	}",3.333333333333333
"/**
	 * Test default optimizer selection for sequence backed generators
	 * based on the configured increment size; both in the case of the
	 * dialect supporting pooled sequences (pooled) and not (hilo)
	 */
	@Test
	public void testDefaultOptimizerBasedOnIncrementBackedBySequence() {
		Properties props = buildGeneratorPropertiesBase();
		props.setProperty( SequenceStyleGenerator.INCREMENT_PARAM, ""10"" );

		// for dialects which do not support pooled sequences, we default to pooled+table
		Dialect dialect = new SequenceDialect();
		SequenceStyleGenerator generator = new SequenceStyleGenerator();
		generator.configure( StandardBasicTypes.LONG, props, dialect );
		assertClassAssignability( TableStructure.class, generator.getDatabaseStructure().getClass() );
		assertClassAssignability( PooledOptimizer.class, generator.getOptimizer().getClass() );
		assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );

		// for dialects which do support pooled sequences, we default to pooled+sequence
		dialect = new PooledSequenceDialect();
		generator = new SequenceStyleGenerator();
		generator.configure( StandardBasicTypes.LONG, props, dialect );
		assertClassAssignability( SequenceStructure.class, generator.getDatabaseStructure().getClass() );
		assertClassAssignability( PooledOptimizer.class, generator.getOptimizer().getClass() );
		assertEquals( SequenceStyleGenerator.DEF_SEQUENCE_NAME, generator.getDatabaseStructure().getName() );
	}",3.555555555555556
"public static void main(String[] args) {
		CustomVersionOneStrategy strategy = new CustomVersionOneStrategy();

		for ( int i = 0; i < 1000; i++ ) {
			System.out.println( ""Generation # "" + i + "" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );
			byte[] loBits = new byte[8];

			long sysTime = System.currentTimeMillis();
			short hiTime = (short) ( System.currentTimeMillis() >>> 32 );
			int loTime = (int) sysTime;
			System.arraycopy( BytesHelper.fromShort( hiTime ), 0, loBits, 0, 2 );
			System.arraycopy( BytesHelper.fromInt( loTime ), 0, loBits, 2, 4 );
			System.arraycopy( Helper.getCountBytes(), 0, loBits, 6, 2 );

			System.out.println( ""    before bit setting ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );
			System.out.println( ""       loBits[0] : "" + BytesHelper.toBinaryString( loBits[0] ) );
			System.out.println( ""             lsb : "" + BytesHelper.toBinaryString( BytesHelper.asLong( loBits ) ) );
			System.out.println( ""    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );

			loBits[0] &= 0x3f;
			loBits[0] |= ((byte)2 << (byte)6);

			System.out.println( ""    after bit setting ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );
			System.out.println( ""       loBits[0] : "" + BytesHelper.toBinaryString( loBits[0] ) );
			long leastSignificantBits = BytesHelper.asLong( loBits );
			System.out.println( ""             lsb : "" + BytesHelper.toBinaryString( leastSignificantBits ) );
			System.out.println( ""    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );


			UUID uuid = new UUID( strategy.mostSignificantBits, leastSignificantBits );
			System.out.println( ""  uuid : "" + uuid.toString() );
			System.out.println( ""  variant : "" + uuid.variant() );
			System.out.println( ""  version : "" + uuid.version() );
			if ( uuid.variant() != 2 ) {
				throw new RuntimeException( ""bad variant"" );
			}
			System.out.println( ""~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"" );
		}
	}",3.555555555555556
"public void doTestWithTupleSubsetResultTransformerNullAliases(TupleSubsetResultTransformer transformer) throws Exception {
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { true, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { true, true, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { false, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { true, false } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] { false, true, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {true, false, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {true, true, false } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {false, false, true } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {false, true, false } ) ) );
		doTest( buildBasicKey( CacheableResultTransformer.create( transformer, null, new boolean[] {false, false, true } ) ) );
	}",3.7777777777777777
"public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;

        Person person = (Person) o;

        if (id != person.id) return false;
        if (name != null ? !name.equals(person.name) : person.name != null) return false;
        if (surname != null ? !surname.equals(person.surname) : person.surname != null) return false;

        return true;
    }",3.888888888888889
"private void readAndSetAddress(Scanner scanner, Person p) {
        Address old = p.getAddress();

        String input = scanner.nextLine();
        if (""NULL"".equals(input)) {
            p.setAddress(null);
            if (old != null) {
                old.getPersons().remove(p);
            }
        } else if ("""".equals(input)) {
        } else {
            try {
                Integer id = Integer.valueOf(input);

                Address a = entityManager.find(Address.class, id);

                if (a == null) {
                    System.err.println(""Unknown address id, setting to NULL."");
                    p.setAddress(null);
                    if (old != null) {
                        old.getPersons().remove(p);
                    }
                } else {
                    p.setAddress(a);

                    a.getPersons().add(p);

                    if (old != null) {
                        old.getPersons().remove(p);
                    }
                }
            } catch (NumberFormatException e) {
                System.err.println(""Invalid address id, setting to NULL."");
                p.setAddress(null);
                if (old != null) {
                    old.getPersons().remove(p);
                }
            }
        }
    }",3.888888888888889
"/**
	 * add statistics report of a DB query
	 *
	 * @param rows rows count returned
	 * @param time time taken
	 */
	void executed(long rows, long time) {
		// read lock is enough, concurrent updates are supported by the underlying type AtomicLong
		// this only guards executed(long, long) to be called, when another thread is executing getExecutionAvgTime()
		readLock.lock();
		try {
			// Less chances for a context switch
			for (long old = executionMinTime.get(); (time < old) && !executionMinTime.compareAndSet(old, time); old = executionMinTime.get());
			for (long old = executionMaxTime.get(); (time > old) && !executionMaxTime.compareAndSet(old, time); old = executionMaxTime.get());
			executionCount.getAndIncrement();
			executionRowCount.addAndGet(rows);
			totalExecutionTime.addAndGet(time);
		} finally {
			readLock.unlock();
		}
	}",3.333333333333333
"public String toString() {
		return new StringBuilder()
				.append(""QueryStatistics"")
				.append(""[cacheHitCount="").append(this.cacheHitCount)
				.append("",cacheMissCount="").append(this.cacheMissCount)
				.append("",cachePutCount="").append(this.cachePutCount)
				.append("",executionCount="").append(this.executionCount)
				.append("",executionRowCount="").append(this.executionRowCount)
				.append("",executionAvgTime="").append(this.getExecutionAvgTime())
				.append("",executionMaxTime="").append(this.executionMaxTime)
				.append("",executionMinTime="").append(this.executionMinTime)
				.append(']')
				.toString();
	}",4.0
"public String toString() {
		StringBuilder buf = new StringBuilder()
				.append(""SecondLevelCacheStatistics"")
				.append(""[hitCount="").append(this.hitCount)
				.append("",missCount="").append(this.missCount)
				.append("",putCount="").append(this.putCount);
		//not sure if this would ever be null but wanted to be careful
		if (region != null) {
			buf.append("",elementCountInMemory="").append(this.getElementCountInMemory())
					.append("",elementCountOnDisk="").append(this.getElementCountOnDisk())
					.append("",sizeInMemory="").append(this.getSizeInMemory());
		}
		buf.append(']');
		return buf.toString();
	}",3.888888888888889
"Object processEntity(Object value, EntityType entityType) throws HibernateException {

		if (value!=null) {
			getSession().getPersistenceContext().reassociateIfUninitializedProxy(value);
			// if it is an initialized proxy, let cascade
			// handle it later on
		}

		return null;
	}",4.555555555555555
"/**
	 * 1. Recreate the collection key -> collection map
	 * 2. rebuild the collection entries
	 * 3. call Interceptor.postFlush()
	 */
	protected void postFlush(SessionImplementor session) throws HibernateException {

		LOG.trace( ""Post flush"" );

		final PersistenceContext persistenceContext = session.getPersistenceContext();
		persistenceContext.getCollectionsByKey().clear();
		
		// the database has changed now, so the subselect results need to be invalidated
		// the batch fetching queues should also be cleared - especially the collection batch fetching one
		persistenceContext.getBatchFetchQueue().clear();

		for ( Map.Entry<PersistentCollection, CollectionEntry> me : IdentityMap.concurrentEntries( persistenceContext.getCollectionEntries() ) ) {
			CollectionEntry collectionEntry = me.getValue();
			PersistentCollection persistentCollection = me.getKey();
			collectionEntry.postFlush(persistentCollection);
			if ( collectionEntry.getLoadedPersister() == null ) {
				//if the collection is dereferenced, remove from the session cache
				//iter.remove(); //does not work, since the entrySet is not backed by the set
				persistenceContext.getCollectionEntries()
						.remove(persistentCollection);
			}
			else {
				//otherwise recreate the mapping between the collection and its key
				CollectionKey collectionKey = new CollectionKey(
						collectionEntry.getLoadedPersister(),
						collectionEntry.getLoadedKey()
				);
				persistenceContext.getCollectionsByKey().put(collectionKey, persistentCollection);
			}
		}

	}",3.4444444444444446
"/**
		 * Build a ParameterMemento from the given parameter registration
		 *
		 * @param registration The parameter registration from a ProcedureCall
		 *
		 * @return The memento
		 */
		public static ParameterMemento fromRegistration(ParameterRegistrationImplementor registration) {
			return new ParameterMemento(
					registration.getPosition(),
					registration.getName(),
					registration.getMode(),
					registration.getType(),
					registration.getHibernateType()
			);
		}",4.666666666666667
"@Test
	public void testQueryCollectionOfValues() throws Exception {
		Session s = openSession();
		s.beginTransaction();
		Baz baz = new Baz();
		baz.setDefaults();
		s.save(baz);
		Glarch g = new Glarch();
		Serializable gid = s.save(g);

		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) /*&& !(dialect instanceof MckoiDialect)*/ && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof PointbaseDialect) && !(getDialect() instanceof TimesTenDialect) ) {
			s.createFilter( baz.getFooArray(), ""where size(this.bytes) > 0"" ).list();
			s.createFilter( baz.getFooArray(), ""where 0 in elements(this.bytes)"" ).list();
		}
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.beginTransaction();
		s.createQuery( ""from Baz baz join baz.fooSet foo join foo.foo.foo foo2 where foo2.string = 'foo'"" ).list();
		s.createQuery( ""from Baz baz join baz.fooArray foo join foo.foo.foo foo2 where foo2.string = 'foo'"" ).list();
		s.createQuery( ""from Baz baz join baz.stringDateMap date where index(date) = 'foo'"" ).list();
		s.createQuery( ""from Baz baz join baz.topGlarchez g where index(g) = 'A'"" ).list();
		s.createQuery( ""select index(g) from Baz baz join baz.topGlarchez g"" ).list();

		assertTrue( s.createQuery( ""from Baz baz left join baz.stringSet"" ).list().size()==3 );
		baz = (Baz) s.createQuery( ""from Baz baz join baz.stringSet str where str='foo'"" ).list().get(0);
		assertTrue( !Hibernate.isInitialized( baz.getStringSet() ) );
		baz = (Baz) s.createQuery( ""from Baz baz left join fetch baz.stringSet"" ).list().get(0);
		assertTrue( Hibernate.isInitialized( baz.getStringSet() ) );
		assertTrue( s.createQuery( ""from Baz baz join baz.stringSet string where string='foo'"" ).list().size()==1 );
		assertTrue( s.createQuery( ""from Baz baz inner join baz.components comp where comp.name='foo'"" ).list().size()==1 );
		//List bss = s.find(""select baz, ss from Baz baz inner join baz.stringSet ss"");
		s.createQuery( ""from Glarch g inner join g.fooComponents comp where comp.fee is not null"" ).list();
		s.createQuery( ""from Glarch g inner join g.fooComponents comp join comp.fee fee where fee.count > 0"" ).list();
		s.createQuery( ""from Glarch g inner join g.fooComponents comp where comp.fee.count is not null"" ).list();

		s.delete(baz);
		s.delete( s.get(Glarch.class, gid) );
		s.getTransaction().commit();
		s.close();
	}",2.888888888888889
"@SkipForDialect(value = AbstractHANADialect.class, comment = ""HANA currently requires specifying table name by 'FOR UPDATE of t1.c1' if there are more than one tables/views/subqueries in the FROM clause"")
	@Test
	public void testRefresh() throws Exception {
		final Session s = openSession();
		s.beginTransaction();
		Foo foo = new Foo();
		s.save( foo );
		s.flush();
		s.doWork(
				new AbstractWork() {
					@Override
					public void execute(Connection connection) throws SQLException {
						final String sql = ""update "" + getDialect().openQuote() + ""foos"" + getDialect().closeQuote() + "" set long_ = -3"";
						Statement st = connection.createStatement();
						st.executeUpdate( sql );
					}
				}
		);
		s.refresh(foo);
		assertEquals( Long.valueOf( -3l ), foo.getLong() );
		assertEquals( LockMode.READ, s.getCurrentLockMode( foo ) );
		s.refresh(foo, LockMode.UPGRADE);
		if ( getDialect().supportsOuterJoinForUpdate() ) {
			assertEquals( LockMode.UPGRADE, s.getCurrentLockMode( foo ) );
		}
		s.delete(foo);
		s.getTransaction().commit();
		s.close();
	}",3.0
"public boolean equals(Object o) {
		if (this == o) return true;
		if (!(o instanceof OuterKey)) return false;

		final OuterKey cidDetailID = (OuterKey) o;

		if (detailId != null ? !detailId.equals(cidDetailID.detailId) : cidDetailID.detailId != null) return false;
		if (master != null ? !master.equals(cidDetailID.master) : cidDetailID.master != null) return false;

		return true;
	}",3.2222222222222223
"@Test
	@SkipForDialect( { HSQLDialect.class, PostgreSQL81Dialect.class, PostgreSQLDialect.class } )
	public void testEscapedJDBC() throws HibernateException, SQLException {
		Session session = openSession();
		session.beginTransaction();
		for ( Object entity : session.createQuery( ""from A"" ).list() ) {
			session.delete( entity );
		}
		A savedA = new A();
		savedA.setName(""Max"");
		session.save(savedA);

		B savedB = new B();
		session.save(savedB);
		session.flush();

		int count = session.createQuery(""from A"").list().size();
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();

		Query query;
		if( getDialect() instanceof TimesTenDialect) {
            // TimesTen does not permit general expressions (like UPPER) in the second part of a LIKE expression,
            // so we execute a similar test 
            query = session.createSQLQuery(""select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA where {fn ucase(name)} like 'MAX'"" )
					.addEntity( ""a"", A.class );
        }
		else {
            query = session.createSQLQuery( ""select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA where {fn ucase(name)} like {fn ucase('max')}"" )
					.addEntity( ""a"", A.class );
        }
		List list = query.list();

		assertNotNull(list);
		assertEquals(1, list.size());
		session.getTransaction().commit();
		session.close();
	}",3.555555555555556
"@Test
	@TestForIssue( jiraKey = ""HHH-21"" )
    public void testCompositeIdId() throws HibernateException, SQLException {
        Session s = openSession();
		s.beginTransaction();
        CompositeIdId id = new CompositeIdId();
        id.setName(""Max"");
        id.setSystem(""c64"");
        id.setId(""games"");
        s.save(id);
		s.getTransaction().commit();
        s.close();

        s = openSession();
		s.beginTransaction();
        // having a composite id with one property named id works since the map used by sqlloader to map names to properties handles it.
		String sql = ""select system as {c.system}, id as {c.id}, name as {c.name}, foo as {c.composite.foo}, bar as {c.composite.bar} from CompositeIdId where system=? and id=?"";
		SQLQuery query = s.createSQLQuery( sql ).addEntity( ""c"", CompositeIdId.class );
        query.setString(0, ""c64"");
        query.setString(1, ""games"");

        CompositeIdId id2 = (CompositeIdId) query.uniqueResult();
        check(id, id2);

		s.getTransaction().commit();
        s.close();

        s = openSession();
		s.beginTransaction();
        CompositeIdId useForGet = new CompositeIdId();
        useForGet.setSystem(""c64"");
        useForGet.setId(""games"");
        // this doesn't work since the verification does not take column span into respect!
        CompositeIdId getted = (CompositeIdId) s.get(CompositeIdId.class, useForGet);
        check(id,getted);
		s.getTransaction().commit();
        s.close();
    }",3.2222222222222223
"@Override
    public void runTest(final Test test, final TestResult result) {
        Thread t = new Thread() {
            @Override
            public void run() {
                try {
                    // inlined due to limitation in VA/Java
                    //ActiveTestSuite.super.runTest(test, result);
                    test.run(result);
                } finally {
                    ActiveTestSuite.this.runFinished();
                }
            }
        };
        t.start();
    }
",4.555555555555555
"public boolean equalsFoo(Foo other) {
		if ( _bytes!=other._bytes ) {
			if ( _bytes==null || other._bytes==null ) return false;
			if ( _bytes.length!=other._bytes.length ) return false;
			for ( int i=0; i< _bytes.length; i++) {
				if ( _bytes[i] != other._bytes[i] ) return false;
			}
		}

		return ( this._bool == other._bool )
		&& ( ( this._boolean == other._boolean ) || ( this._boolean.equals(other._boolean) ) )
		&& ( ( this._byte == other._byte ) || ( this._byte.equals(other._byte) ) )
		//&& ( ( this._date == other._date ) || ( this._date.getDate() == other._date.getDate() && this._date.getMonth() == other._date.getMonth() && this._date.getYear() == other._date.getYear() ) )
		&& ( ( this._double == other._double ) || ( this._double.equals(other._double) ) )
		&& ( ( this._float == other._float ) || ( this._float.equals(other._float) ) )
		&& ( this._int == other._int )
		&& ( ( this._integer == other._integer ) || ( this._integer.equals(other._integer) ) )
		&& ( ( this._long == other._long ) || ( this._long.equals(other._long) ) )
		&& ( this._null == other._null )
		&& ( ( this._short == other._short ) || ( this._short.equals(other._short) ) )
		&& ( ( this._string == other._string) || ( this._string.equals(other._string) ) )
		//&& ( ( this._timestamp==other._timestamp) || ( this._timestamp.getDate() == other._timestamp.getDate() && this._timestamp.getYear() == other._timestamp.getYear() && this._timestamp.getMonth() == other._timestamp.getMonth() ) )
		&& ( this._zero == other._zero )
		&& ( ( this._foo == other._foo ) || ( this._foo.getKey().equals( other._foo.getKey() ) ) )
		&& ( ( this.blob == other.blob ) || ( this.blob.equals(other.blob) ) )
		&& ( this.yesno == other.yesno )
		&& ( ( this.binary == other.binary ) || java.util.Arrays.equals(this.binary, other.binary) )
		&& ( this.key.equals(other.key) )
		&& ( this.theLocale.equals(other.theLocale) )
		&& ( ( this.custom == other.custom ) || ( this.custom[0].equals(other.custom[0]) && this.custom[1].equals(other.custom[1]) ) );

	}",1.8888888888888888
"@Test
	public void testSerializationFailsOnAfterStatementAggressiveReleaseWithOpenResources() throws Throwable {
		prepare();
		Session s = getSessionUnderTest();

		Silly silly = new Silly( ""silly"" );
		s.save( silly );

		// this should cause the CM to obtain a connection, and then release it
		s.flush();

		// both scroll() and iterate() cause batching to hold on
		// to resources, which should make aggressive-release not release
		// the connection (and thus cause serialization to fail)
		ScrollableResults sr = s.createQuery( ""from Silly"" ).scroll();

		try {
			SerializationHelper.serialize( s );
			fail( ""Serialization allowed on connected session; or aggressive release released connection with open resources"" );
		}
		catch( IllegalStateException e ) {
			// expected behavior
		}

		// getting the first row only because SybaseASE15Dialect throws NullPointerException
		// if data is not read before closing the ResultSet
		sr.next();

		// Closing the ScrollableResults does currently force batching to
		// aggressively release the connection
		sr.close();
		SerializationHelper.serialize( s );

		s.delete( silly );
		s.flush();

		release( s );
		done();
	}",3.888888888888889
"@Override
	protected void prepareTest() throws Exception {
	    Session s = openSession();
	    Transaction t = s.beginTransaction();
	    Child child_1_1 = new Child( ""achild1-1"");
	    Child child_1_2 = new Child( ""ychild1-2"");
	    Child child_1_3 = new Child( ""dchild1-3"");
	    Child child_2_1 = new Child( ""bchild2-1"");
	    Child child_2_2 = new Child( ""cchild2-2"");
	    Child child_2_3 = new Child( ""zchild2-3"");
	
	    s.save( child_1_1 );
	    s.save( child_2_1 );
	    s.save( child_1_2 );
	    s.save( child_2_2 );
	    s.save( child_1_3 );
	    s.save( child_2_3 );
	
	    s.flush();
	
	    Parent p1 = new Parent( ""parent1"" );
	    p1.addChild( child_1_1 );
	    p1.addChild( child_1_2 );
	    p1.addChild( child_1_3 );
	    s.save( p1 );
	
	    Parent p2 = new Parent( ""parent2"" );
	    p2.addChild( child_2_1 );
	    p2.addChild( child_2_2 );
	    p2.addChild( child_2_3 );
	    s.save( p2 );
	
	    t.commit();
	    s.close();
	}",4.444444444444445
"@Test
	@TestForIssue( jiraKey = ""HHH-2045"" )
	@RequiresDialect( H2Dialect.class )
	public void testEmptyInList() {
		Session session = openSession();
		session.beginTransaction();
		Human human = new Human();
		human.setName( new Name( ""Lukasz"", null, ""Antoniak"" ) );
		human.setNickName( ""NONE"" );
		session.save( human );
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();
		List results = session.createQuery( ""from Human h where h.nickName in ()"" ).list();
		assertEquals( 0, results.size() );
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();
		session.delete( human );
		session.getTransaction().commit();
		session.close();
	}",4.444444444444445
"@Test
	@TestForIssue( jiraKey = ""HHH-2257"" )
	public void testImplicitJoinsInDifferentClauses() {
		// both the classic and ast translators output the same syntactically valid sql
		// for all of these cases; the issue is that shallow (iterate) and
		// non-shallow (list/scroll) queries return different results because the
		// shallow skips the inner join which ""weeds out"" results from the non-shallow queries.
		// The results were initially different depending upon the clause(s) in which the
		// implicit join occurred
		Session s = openSession();
		s.beginTransaction();
		SimpleEntityWithAssociation owner = new SimpleEntityWithAssociation( ""owner"" );
		SimpleAssociatedEntity e1 = new SimpleAssociatedEntity( ""thing one"", owner );
		SimpleAssociatedEntity e2 = new SimpleAssociatedEntity( ""thing two"" );
		s.save( e1 );
		s.save( e2 );
		s.save( owner );
		s.getTransaction().commit();
		s.close();

		checkCounts( ""select e.owner from SimpleAssociatedEntity e"", 1, ""implicit-join in select clause"" );
		checkCounts( ""select e.id, e.owner from SimpleAssociatedEntity e"", 1, ""implicit-join in select clause"" );

		// resolved to a ""id short cut"" when part of the order by clause -> no inner join = no weeding out...
		checkCounts( ""from SimpleAssociatedEntity e order by e.owner"", 2, ""implicit-join in order-by clause"" );
		// resolved to a ""id short cut"" when part of the group by clause -> no inner join = no weeding out...
		checkCounts( ""select e.owner.id, count(*) from SimpleAssociatedEntity e group by e.owner"", 2, ""implicit-join in select and group-by clauses"" );

	 	s = openSession();
		s.beginTransaction();
		s.delete( e1 );
		s.delete( e2 );
		s.delete( owner );
		s.getTransaction().commit();
		s.close();
	}",3.7777777777777777
"@Test
	@TestForIssue( jiraKey = ""HHH-1631"" )
	public void testSubclassOrSuperclassPropertyReferenceInJoinedSubclass() {
		// this is a long standing bug in Hibernate; see HHH-1631 for details and history
		//
		// (1) pregnant is defined as a property of the class (Mammal) itself
		// (2) description is defined as a property of the superclass (Animal)
		// (3) name is defined as a property of a particular subclass (Human)

		new SyntaxChecker( ""from Zoo z join z.mammals as m where m.name.first = 'John'"" ).checkIterate();

		new SyntaxChecker( ""from Zoo z join z.mammals as m where m.pregnant = false"" ).checkAll();
		new SyntaxChecker( ""select m.pregnant from Zoo z join z.mammals as m where m.pregnant = false"" ).checkAll();

		new SyntaxChecker( ""from Zoo z join z.mammals as m where m.description = 'tabby'"" ).checkAll();
		new SyntaxChecker( ""select m.description from Zoo z join z.mammals as m where m.description = 'tabby'"" ).checkAll();

		new SyntaxChecker( ""from Zoo z join z.mammals as m where m.name.first = 'John'"" ).checkAll();
		new SyntaxChecker( ""select m.name from Zoo z join z.mammals as m where m.name.first = 'John'"" ).checkAll();

		new SyntaxChecker( ""select m.pregnant from Zoo z join z.mammals as m"" ).checkAll();
		new SyntaxChecker( ""select m.description from Zoo z join z.mammals as m"" ).checkAll();
		new SyntaxChecker( ""select m.name from Zoo z join z.mammals as m"" ).checkAll();

		new SyntaxChecker( ""from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'"" ).checkAll();
		new SyntaxChecker( ""select da.father from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'"" ).checkAll();
		new SyntaxChecker( ""select da.father from DomesticAnimal da where da.owner.nickName = 'Gavin'"" ).checkAll();
	}",4.333333333333333
"@SuppressWarnings( {""unchecked""})
	@Test
	public void testAnyMappingReference() {
		Session s = openSession();
		s.beginTransaction();

		PropertyValue redValue = new StringPropertyValue( ""red"" );
		PropertyValue loneliestNumberValue = new IntegerPropertyValue( 1 );

		Long id;
		PropertySet ps = new PropertySet( ""my properties"" );
		ps.setSomeSpecificProperty( redValue );
		ps.getGeneralProperties().put( ""the loneliest number"", loneliestNumberValue );
		ps.getGeneralProperties().put( ""i like"", new StringPropertyValue( ""pina coladas"" ) );
		ps.getGeneralProperties().put( ""i also like"", new StringPropertyValue( ""getting caught in the rain"" ) );
		s.save( ps );

		s.getTransaction().commit();
		id = ps.getId();
		s.clear();
		s.beginTransaction();

		// TODO : setEntity() currently will not work here, but that would be *very* nice
		// does not work because the corresponding EntityType is then used as the ""bind type"" rather
		// than the ""discovered"" AnyType...
		s.createQuery( ""from PropertySet p where p.someSpecificProperty = :ssp"" ).setParameter( ""ssp"", redValue ).list();

		s.createQuery( ""from PropertySet p where p.someSpecificProperty.id is not null"" ).list();

		s.createQuery( ""from PropertySet p join p.generalProperties gp where gp.id is not null"" ).list();

		s.delete( s.load( PropertySet.class, id ) );

		s.getTransaction().commit();
		s.close();
	}",3.6666666666666665
"@Test
	public void testFetchInSubqueryFails() {
		Session s = openSession();
		try {
			s.createQuery( ""from Animal a where a.mother in (select m from Animal a1 inner join a1.mother as m join fetch m.mother)"" ).list();
			fail( ""fetch join allowed in subquery"" );
		}
		catch( QueryException expected ) {
			// expected behavior
		}
		s.close();
	}",4.333333333333333
"@Test
	@TestForIssue( jiraKey = ""HHH-429"" )
	@SuppressWarnings( {""unchecked""})
	public void testSuperclassPropertyReferenceAfterCollectionIndexedAccess() {
		// note: simply performing syntax checking in the db
		Session s = openSession();
		s.beginTransaction();
		Mammal tiger = new Mammal();
		tiger.setDescription( ""Tiger"" );
		s.persist( tiger );
		Mammal mother = new Mammal();
		mother.setDescription( ""Tiger's mother"" );
		mother.setBodyWeight( 4.0f );
		mother.addOffspring( tiger );
		s.persist( mother );
		Zoo zoo = new Zoo();
		zoo.setName( ""Austin Zoo"" );
		zoo.setMammals( new HashMap() );
		zoo.getMammals().put( ""tiger"", tiger );
		s.persist( zoo );
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.beginTransaction();
		List results = s.createQuery( ""from Zoo zoo where zoo.mammals['tiger'].mother.bodyWeight > 3.0f"" ).list();
		assertEquals( 1, results.size() );
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.beginTransaction();
		s.delete( tiger );
		s.delete( mother );
		s.delete( zoo );
		s.getTransaction().commit();
		s.close();
	}",3.7777777777777777
"@Test
	@SuppressWarnings( {""UnusedAssignment"", ""UnusedDeclaration""})
	public void testSelectExpressions() {
		createTestBaseData();
		Session session = openSession();
		Transaction txn = session.beginTransaction();
		Human h = new Human();
		h.setName( new Name( ""Gavin"", 'A', ""King"" ) );
		h.setNickName(""Oney"");
		h.setBodyWeight( 1.0f );
		session.persist( h );
		List results = session.createQuery(""select 'found', lower(h.name.first) from Human h where lower(h.name.first) = 'gavin'"").list();
		results = session.createQuery(""select 'found', lower(h.name.first) from Human h where concat(h.name.first, ' ', h.name.initial, ' ', h.name.last) = 'Gavin A King'"").list();
		results = session.createQuery(""select 'found', lower(h.name.first) from Human h where h.name.first||' '||h.name.initial||' '||h.name.last = 'Gavin A King'"").list();
		results = session.createQuery(""select a.bodyWeight + m.bodyWeight from Animal a join a.mother m"").list();
		results = session.createQuery(""select 2.0 * (a.bodyWeight + m.bodyWeight) from Animal a join a.mother m"").list();
		results = session.createQuery(""select sum(a.bodyWeight + m.bodyWeight) from Animal a join a.mother m"").list();
		results = session.createQuery(""select sum(a.mother.bodyWeight * 2.0) from Animal a"").list();
		results = session.createQuery(""select concat(h.name.first, ' ', h.name.initial, ' ', h.name.last) from Human h"").list();
		results = session.createQuery(""select h.name.first||' '||h.name.initial||' '||h.name.last from Human h"").list();
		results = session.createQuery(""select nickName from Human"").list();
		results = session.createQuery(""select lower(nickName) from Human"").list();
		results = session.createQuery(""select abs(bodyWeight*-1) from Human"").list();
		results = session.createQuery(""select upper(h.name.first||' ('||h.nickName||')') from Human h"").list();
		results = session.createQuery(""select abs(a.bodyWeight-:param) from Animal a"").setParameter(""param"", new Float(2.0)).list();
		results = session.createQuery(""select abs(:param - a.bodyWeight) from Animal a"").setParameter(""param"", new Float(2.0)).list();
		results = session.createQuery(""select lower(upper('foo')) from Animal"").list();
		results = session.createQuery(""select lower(upper('foo') || upper('bar')) from Animal"").list();
		results = session.createQuery(""select sum(abs(bodyWeight - 1.0) * abs(length('ffobar')-3)) from Animal"").list();
		session.delete(h);
		txn.commit();
		session.close();
		destroyTestBaseData();
	}",3.4444444444444446
"/**
	 * Build a normal attribute.
	 *
	 * @param ownerType The descriptor of the attribute owner (aka declarer).
	 * @param property The Hibernate property descriptor for the attribute
	 * @param <X> The type of the owner
	 * @param <Y> The attribute type
	 *
	 * @return The built attribute descriptor or null if the attribute is not part of the JPA 2 model (eg backrefs)
	 */
	@SuppressWarnings({""unchecked""})
	public <X, Y> AttributeImplementor<X, Y> buildAttribute(AbstractManagedType<X> ownerType, Property property) {
		if ( property.isSynthetic() ) {
			// hide synthetic/virtual properties (fabricated by Hibernate) from the JPA metamodel.
			LOG.tracef( ""Skipping synthetic property %s(%s)"", ownerType.getTypeName(), property.getName() );
			return null;
		}
		LOG.trace( ""Building attribute ["" + ownerType.getTypeName() + ""."" + property.getName() + ""]"" );
		final AttributeContext<X> attributeContext = wrap( ownerType, property );
		final AttributeMetadata<X, Y> attributeMetadata =
				determineAttributeMetadata( attributeContext, normalMemberResolver );
		if ( attributeMetadata == null ) {
			return null;
		}
		if ( attributeMetadata.isPlural() ) {
			return buildPluralAttribute( (PluralAttributeMetadata) attributeMetadata );
		}
		final SingularAttributeMetadata<X, Y> singularAttributeMetadata = (SingularAttributeMetadata<X, Y>) attributeMetadata;
		final Type<Y> metaModelType = getMetaModelType( singularAttributeMetadata.getValueContext() );
		return new SingularAttributeImpl<X, Y>(
				attributeMetadata.getName(),
				attributeMetadata.getJavaType(),
				ownerType,
				attributeMetadata.getMember(),
				false,
				false,
				property.isOptional(),
				metaModelType,
				attributeMetadata.getPersistentAttributeType()
		);
	}
",2.888888888888889
"@Test public void testOtherSyntax() throws Exception {
		parse( ""select bar from org.hibernate.test.Bar bar order by ((bar.x - :valueX)*(bar.x - :valueX))"" );
		parse( ""from bar in class org.hibernate.test.Bar, foo in elements(bar.baz.fooSet)"" );
		parse( ""from one in class org.hibernate.test.One, many in elements(one.manies) where one.id = 1 and many.id = 1"" );
		parse( ""from org.hibernate.test.Inner _inner join _inner.middles middle"" );
		parse( ""FROM m IN CLASS org.hibernate.test.Master WHERE NOT EXISTS ( FROM d IN elements(m.details) WHERE NOT d.i=5 )"" );
		parse( ""FROM m IN CLASS org.hibernate.test.Master WHERE NOT 5 IN ( SELECT d.i FROM d IN elements(m.details) )"" );
		parse( ""SELECT m FROM m IN CLASS org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5"" );
		parse( ""SELECT m FROM m IN CLASS org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5"" );
		parse( ""SELECT m.id FROM m IN CLASS org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5"" );
		// I'm not sure about these... [jsd]
//        parse(""select bar.string, foo.string from bar in class org.hibernate.test.Bar inner join bar.baz as baz inner join elements(baz.fooSet) as foo where baz.name = 'name'"");
//        parse(""select bar.string, foo.string from bar in class org.hibernate.test.Bar, bar.baz as baz, elements(baz.fooSet) as foo where baz.name = 'name'"");
//        parse(""select count(*) where this.amount>-1 and this.name is null"");
//        parse(""from sm in class org.hibernate.test.SubMulti where exists sm.children.elements"");
	}",3.888888888888889
"@Test public void testPathologicalKeywordAsIdentifier() throws Exception {
		// Super evil badness... a legitimate keyword!
		parse( ""from Order order"" );
		//parse( ""from Order order join order.group"" );
		parse( ""from X x order by x.group.by.from"" );
		parse( ""from Order x order by x.order.group.by.from"" );
		parse( ""select order.id from Order order"" );
		parse( ""select order from Order order"" );
		parse( ""from Order order where order.group.by.from is not null"" );
		parse( ""from Order order order by order.group.by.from"" );
		// Okay, now this is getting silly.
		parse( ""from Group as group group by group.by.from"" );
	}",4.0
"@Test public void testHHH1780() throws Exception {
        // verifies the tree contains a NOT->EXISTS subtree
        class Verifier {
            public boolean verify(AST root) {
                Stack<AST> queue = new Stack<AST>();
                queue.push( root );
                while ( !queue.isEmpty() ) {
                    AST parent = queue.pop();
                    AST child = parent.getFirstChild();
                    while ( child != null ) {
                        if ( parent.getType() == HqlTokenTypes.NOT &&
                                child.getType() == HqlTokenTypes.EXISTS ) {
                            return true;
                        }
                        queue.push( child );
                        child = child.getNextSibling();
                    }
                }
                return false;
            }
        }

        // test inversion of AND
        AST ast = doParse(
                ""from Person p where not ( p.name is null and exists(select a.id from Address a where a.id=p.id))"",
                false
        );

        assertTrue( new Verifier().verify( ast ) );

        // test inversion of OR
        ast = doParse(
                ""from Person p where not ( p.name is null or exists(select a.id from Address a where a.id=p.id))"",
                false
        );

        assertTrue( new Verifier().verify( ast ) );
    }",3.2222222222222223
"@Test
	public void testDateTimeArithmeticReturnTypesAndParameterGuessing() {
		QueryTranslatorImpl translator = createNewQueryTranslator( ""select o.orderDate - o.orderDate from Order o"" );
		assertEquals( ""incorrect return type count"", 1, translator.getReturnTypes().length );
		assertEquals( ""incorrect return type"", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
		translator = createNewQueryTranslator( ""select o.orderDate + 2 from Order o"" );
		assertEquals( ""incorrect return type count"", 1, translator.getReturnTypes().length );
		assertEquals( ""incorrect return type"", CalendarDateType.INSTANCE, translator.getReturnTypes()[0] );
		translator = createNewQueryTranslator( ""select o.orderDate -2 from Order o"" );
		assertEquals( ""incorrect return type count"", 1, translator.getReturnTypes().length );
		assertEquals( ""incorrect return type"", CalendarDateType.INSTANCE, translator.getReturnTypes()[0] );

		translator = createNewQueryTranslator( ""from Order o where o.orderDate > ?"" );
		assertEquals( ""incorrect expected param type"", CalendarDateType.INSTANCE, translator.getParameterTranslations().getOrdinalParameterExpectedType( 1 ) );

		translator = createNewQueryTranslator( ""select o.orderDate + ? from Order o"" );
		assertEquals( ""incorrect return type count"", 1, translator.getReturnTypes().length );
		assertEquals( ""incorrect return type"", CalendarDateType.INSTANCE, translator.getReturnTypes()[0] );
		assertEquals( ""incorrect expected param type"", DoubleType.INSTANCE, translator.getParameterTranslations().getOrdinalParameterExpectedType( 1 ) );

	}",3.6666666666666665
"@Test
	public void testExpressionWithParamInFunction() {
		assertTranslation(""from Animal a where abs(a.bodyWeight-:param) < 2.0"");
		assertTranslation(""from Animal a where abs(:param - a.bodyWeight) < 2.0"");
		assertTranslation(""from Animal where abs(:x - :y) < 2.0"");
		assertTranslation(""from Animal where lower(upper(:foo)) like 'f%'"");
		if ( ! ( getDialect() instanceof SybaseDialect ) &&  ! ( getDialect() instanceof Sybase11Dialect ) &&  ! ( getDialect() instanceof SybaseASE15Dialect ) && ! ( getDialect() instanceof SQLServerDialect ) ) {
			// Transact-SQL dialects (except SybaseAnywhereDialect) map the length function -> len; 
			// classic translator does not consider that *when nested*;
			// SybaseAnywhereDialect supports the length function

			assertTranslation(""from Animal a where abs(abs(a.bodyWeight - 1.0 + :param) * abs(length('ffobar')-3)) = 3.0"");
		}
		if ( !( getDialect() instanceof MySQLDialect ) && ! ( getDialect() instanceof SybaseDialect ) && ! ( getDialect() instanceof Sybase11Dialect ) && !( getDialect() instanceof SybaseASE15Dialect ) && ! ( getDialect() instanceof SybaseAnywhereDialect ) && ! ( getDialect() instanceof SQLServerDialect ) ) {
			assertTranslation(""from Animal where lower(upper('foo') || upper(:bar)) like 'f%'"");
		}
		if ( getDialect() instanceof PostgreSQLDialect || getDialect() instanceof PostgreSQL81Dialect ) {
			return;
		}
		if ( getDialect() instanceof AbstractHANADialect ) {
			// HANA returns
			// ...al0_7_.mammal where [abs(cast(1 as float(19))-cast(? as float(19)))=1.0]
			return;
		}
		assertTranslation(""from Animal where abs(cast(1 as float) - cast(:param as float)) = 1.0"");
	}",2.888888888888889
"@Test
    public void testHHH6635() throws Exception {
        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
        Set<ObjectName> set = mBeanServer.queryNames( null, null );
        boolean mbeanfound = false;
        for ( ObjectName obj : set ) {
            if ( obj.getKeyPropertyListString().indexOf( ""PooledDataSource"" ) > 0 ) {
                mbeanfound = true;

                // see according c3p0 settings in META-INF/persistence.xml

                int actual_minPoolSize = (Integer) mBeanServer.getAttribute( obj, ""minPoolSize"" );
                assertEquals( 50, actual_minPoolSize );

                int actual_initialPoolSize = (Integer) mBeanServer.getAttribute( obj, ""initialPoolSize"" );
                assertEquals( 50, actual_initialPoolSize );

                int actual_maxPoolSize = (Integer) mBeanServer.getAttribute( obj, ""maxPoolSize"" );
                assertEquals( 800, actual_maxPoolSize );

                int actual_maxStatements = (Integer) mBeanServer.getAttribute( obj, ""maxStatements"" );
                assertEquals( 50, actual_maxStatements );

                int actual_maxIdleTime = (Integer) mBeanServer.getAttribute( obj, ""maxIdleTime"" );
                assertEquals( 300, actual_maxIdleTime );

                int actual_idleConnectionTestPeriod = (Integer) mBeanServer.getAttribute(
                        obj,
                        ""idleConnectionTestPeriod""
                );
                assertEquals( 3000, actual_idleConnectionTestPeriod );
                break;
            }
        }

        assertTrue( ""PooledDataSource BMean not found, please verify version of c3p0"", mbeanfound );
    }",3.6666666666666665
"@Test
	public void testFilterApplicationOnHqlQueryWithImplicitSubqueryContainingPositionalParameter() {
		TestData testData = new TestData();
		testData.prepare();

		Session session = openSession();
		session.beginTransaction();

		final String queryString = ""from Order o where ? in ( select sp.name from Salesperson sp )"";

		// first a control-group query
		List result = session.createQuery( queryString ).setParameter( 0, ""steve"" ).list();
		assertEquals( 2, result.size() );

		// now lets enable filters on Order...
		session.enableFilter( ""fulfilledOrders"" ).setParameter( ""asOfDate"", testData.lastMonth.getTime() );
		result = session.createQuery( queryString ).setParameter( 0, ""steve"" ).list();
		assertEquals( 1, result.size() );

		// now, lets additionally enable filter on Salesperson.  First a valid one...
		session.enableFilter( ""regionlist"" ).setParameterList( ""regions"", new String[] { ""APAC"" } );
		result = session.createQuery( queryString ).setParameter( 0, ""steve"" ).list();
		assertEquals( 1, result.size() );

		// ... then a silly one...
		session.enableFilter( ""regionlist"" ).setParameterList( ""regions"", new String[] { ""gamma quadrant"" } );
		result = session.createQuery( queryString ).setParameter( 0, ""steve"" ).list();
		assertEquals( 0, result.size() );

		session.getTransaction().commit();
		session.close();

		testData.release();
	}",4.222222222222222
"@SuppressWarnings( {""unchecked""})
	@Test
	public void testDistinctSelectWithJoin() {
		feedDatabase();

		Session s = openSession();

		List<Entry> entries = s.createQuery(""select distinct e from Entry e join e.tags t where t.surrogate != null order by e.name"").setFirstResult(10).setMaxResults(5).list();

		// System.out.println(entries);
		Entry firstEntry = entries.remove(0);
		assertFalse(""The list of entries should not contain dublicated Entry objects as we've done a distinct select"", entries.contains(firstEntry));

		s.close();
	}",4.555555555555555
"@Test
	@SkipForDialect(
			value = { MySQLMyISAMDialect.class, AbstractHANADialect.class },
			comment = ""MySQL (MyISAM) / Hana do not support FK violation checking""
	)
	public void testIntegrityViolation() throws Exception {
		final Session session = openSession();
		session.beginTransaction();

		session.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						// Attempt to insert some bad values into the T_MEMBERSHIP table that should
						// result in a constraint violation
						PreparedStatement ps = null;
						try {
							ps = ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( ""INSERT INTO T_MEMBERSHIP (user_id, group_id) VALUES (?, ?)"" );
							ps.setLong(1, 52134241);    // Non-existent user_id
							ps.setLong(2, 5342);        // Non-existent group_id
							((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().executeUpdate( ps );

							fail(""INSERT should have failed"");
						}
						catch (ConstraintViolationException ignore) {
							// expected outcome
						}
						finally {
							releaseStatement( session, ps );
						}
					}
				}
		);

		session.getTransaction().rollback();
		session.close();
	}",3.6666666666666665
"@Test
	public void testBadGrammar() throws Exception {
		final Session session = openSession();
		session.beginTransaction();

		session.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						// prepare/execute a query against a non-existent table
						PreparedStatement ps = null;
						try {
							ps = ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( ""SELECT user_id, user_name FROM tbl_no_there"" );
							((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );

							fail(""SQL compilation should have failed"");
						}
						catch (SQLGrammarException ignored) {
							// expected outcome
						}
						finally {
							releaseStatement( session, ps );
						}
					}
				}
		);

		session.getTransaction().rollback();
		session.close();
	}",3.2222222222222223
"private void releaseStatement(Session session, PreparedStatement ps) {
		if ( ps != null ) {
			try {
				( (SessionImplementor) session ).getTransactionCoordinator().getJdbcCoordinator().release( ps );
			}
			catch ( Throwable ignore ) {
				// ignore...
			}
		}
	}",3.888888888888889
"@Test
	public void testEntityWithLazyAssnList() throws Exception {
		CriteriaExecutor criteriaExecutor = new CriteriaExecutor() {
			protected Criteria getCriteria(Session s) {
				// should use RootEntityTransformer by default
				return s.createCriteria( Student.class )
						.addOrder( Order.asc( ""studentNumber"" ) );
			}
		};
		HqlExecutor hqlExecutor = new HqlExecutor() {
			public Query getQuery(Session s) {
				return s.createQuery( ""from Student order by studentNumber"" );
			}
		};
		ResultChecker checker = new ResultChecker() {
			public void check(Object results) {
				List resultList = ( List ) results;
				assertEquals( 2, resultList.size() );
				assertEquals( yogiExpected, resultList.get( 0 ) );
				assertEquals( shermanExpected, resultList.get( 1 ) );
				assertNotNull( ((Student) resultList.get( 0 )).getEnrolments() );
				assertNotNull( ( ( Student ) resultList.get( 0 ) ).getPreferredCourse() );
				assertNotNull( ( ( Student ) resultList.get( 1 ) ).getEnrolments() );
				assertNull( ( ( Student ) resultList.get( 1 ) ).getPreferredCourse() );
				assertFalse( Hibernate.isInitialized( ( ( Student ) resultList.get( 0 ) ).getEnrolments() ) );
				assertFalse( Hibernate.isInitialized( ( ( Student ) resultList.get( 0 ) ).getPreferredCourse() ) );
				assertFalse( Hibernate.isInitialized( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
				assertNull( ( ( Student ) resultList.get( 1 ) ).getPreferredCourse() );
			}
		};
		runTest( hqlExecutor, criteriaExecutor, checker, false );
	}",3.111111111111111
"@Test
	public void testJoinWithFetchJoinListCriteria() throws Exception {
		CriteriaExecutor criteriaExecutor = new CriteriaExecutor() {
			protected Criteria getCriteria(Session s) {
				return s.createCriteria( Student.class, ""s"" )
						.createAlias( ""s.preferredCourse"", ""pc"", Criteria.LEFT_JOIN  )
						.setFetchMode( ""enrolments"", FetchMode.JOIN )
						.addOrder( Order.asc( ""s.studentNumber"") );
			}
		};
		ResultChecker checker = new ResultChecker() {
			public void check(Object results) {
				List resultList = ( List ) results;
				assertEquals( 2, resultList.size() );
				assertEquals( yogiExpected, resultList.get( 0 ) );
				// The following fails for criteria due to HHH-3524
				//assertEquals( yogiExpected.getPreferredCourse(), ( ( Student ) resultList.get( 0 ) ).getPreferredCourse() );
				assertEquals( yogiExpected.getPreferredCourse().getCourseCode(),
						( ( Student ) resultList.get( 0 ) ).getPreferredCourse().getCourseCode() );
				assertEquals( shermanExpected, resultList.get( 1 ) );
				assertNull( ( ( Student ) resultList.get( 1 ) ).getPreferredCourse() );
				if ( areDynamicNonLazyAssociationsChecked() ) {
					assertTrue( Hibernate.isInitialized( ( ( Student ) resultList.get( 0 ) ).getEnrolments() ) );
					assertEquals( yogiExpected.getEnrolments(), ( ( Student ) resultList.get( 0 ) ).getEnrolments() );
					assertTrue( Hibernate.isInitialized( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
					assertEquals( shermanExpected.getEnrolments(), ( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
				}
			}
		};
		runTest( null, criteriaExecutor, checker, false );
	}",2.7777777777777777
"@Test
	public void testEntityWithAliasedJoinFetchedLazyOneToManySingleElementListHql() throws Exception {
		HqlExecutor hqlExecutor = new HqlExecutor() {
			public Query getQuery(Session s) {
				return s.createQuery( ""from Student s left join fetch s.enrolments e order by s.studentNumber"" );
			}
		};

		ResultChecker checker = new ResultChecker() {
			public void check(Object results) {
				List resultList = ( List ) results;
				assertEquals( 2, resultList.size() );
				assertEquals( yogiExpected, resultList.get( 0 ) );
				assertEquals(
						yogiExpected.getPreferredCourse().getCourseCode(),
						( ( Student ) resultList.get( 0 ) ).getPreferredCourse().getCourseCode()
				);
				assertEquals( shermanExpected, resultList.get( 1 ) );
				assertNull( ( ( Student ) resultList.get( 1 ) ).getPreferredCourse() );
				if ( areDynamicNonLazyAssociationsChecked() ) {
					assertTrue( Hibernate.isInitialized( ( ( Student ) resultList.get( 0 ) ).getEnrolments() ) );
					assertEquals( yogiExpected.getEnrolments(), ( ( Student ) resultList.get( 0 ) ).getEnrolments() );
					assertTrue( Hibernate.isInitialized( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
					assertEquals( shermanExpected.getEnrolments(), ( ( ( Student ) resultList.get( 1 ) ).getEnrolments() ) );
				}
			}
		};

		runTest( hqlExecutor, null, checker, false);
	}",3.0
"@Test
	public void testMultiSelectNewMapUsingAliasesWithFetchJoinList() throws Exception {
		CriteriaExecutor criteriaExecutor = new CriteriaExecutor() {
			protected Criteria getCriteria(Session s) {
				return s.createCriteria( Student.class, ""s"" )
						.createAlias( ""s.preferredCourse"", ""pc"", Criteria.LEFT_JOIN  )
						.setFetchMode( ""enrolments"", FetchMode.JOIN )
						.addOrder( Order.asc( ""s.studentNumber"" ))
						.setResultTransformer( Transformers.ALIAS_TO_ENTITY_MAP );
			}
		};
		HqlExecutor hqlSelectNewMapExecutor = new HqlExecutor() {
			public Query getQuery(Session s) {
				return s.createQuery( ""select new map(s as s, pc as pc) from Student s left join s.preferredCourse pc left join fetch s.enrolments order by s.studentNumber"" );
			}
		};
		ResultChecker checker = new ResultChecker() {
			public void check(Object results) {
				List resultList = ( List ) results;
				assertEquals( 2, resultList.size() );
				Map yogiMap = ( Map ) resultList.get( 0 );
				assertEquals( yogiExpected, yogiMap.get( ""s"" ) );
				assertEquals( yogiExpected.getPreferredCourse(), yogiMap.get( ""pc"" ) );
				Map shermanMap = ( Map ) resultList.get( 1 );
				assertEquals( shermanExpected, shermanMap.get( ""s"" ) );
				assertNull( shermanMap.get( ""pc"" ) );
				if ( areDynamicNonLazyAssociationsChecked() ) {
					assertTrue( Hibernate.isInitialized( ( ( Student ) yogiMap.get( ""s"" ) ).getEnrolments() ) );
					assertEquals( yogiExpected.getEnrolments(), ( ( Student ) yogiMap.get( ""s"" ) ).getEnrolments() );
					assertTrue( Hibernate.isInitialized( ( ( Student ) shermanMap.get( ""s"" ) ).getEnrolments() ) );
					assertEquals( shermanExpected.getEnrolments(), ( ( ( Student ) shermanMap.get( ""s"" ) ).getEnrolments() ) );
				}
			}
		};
		runTest( hqlSelectNewMapExecutor, criteriaExecutor, checker, false );
	}",3.2222222222222223
"public void afterSessionFactoryBuilt() {
		super.afterSessionFactoryBuilt();
		final Session session = sessionFactory().openSession();
		session.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						Statement st = ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().createStatement();
						try {
							((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().execute( st, ""drop table Point"");
						}
						catch (Exception ignored) {
						}
						((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().execute( st, ""create table Point (\""x\"" number(19,2) not null, \""y\"" number(19,2) not null, description varchar2(255) )"");
						((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().release( st );
					}
				}
		);
		session.close();
	}",3.6666666666666665
"@Test
	public void testNoLoss() {
		assertNoLoss( ""insert into Address (city, state, zip, \""from\"") values (?, ?, ?, 'insert value')"" );
		assertNoLoss( ""delete from Address where id = ? and version = ?"" );
		assertNoLoss( ""update Address set city = ?, state=?, zip=?, version = ? where id = ? and version = ?"" );
		assertNoLoss( ""update Address set city = ?, state=?, zip=?, version = ? where id in (select aid from Person)"" );
		assertNoLoss(
				""select p.name, a.zipCode, count(*) from Person p left outer join Employee e on e.id = p.id and p.type = 'E' and (e.effective>? or e.effective<?) join Address a on a.pid = p.id where upper(p.name) like 'G%' and p.age > 100 and (p.sex = 'M' or p.sex = 'F') and coalesce( trim(a.street), a.city, (a.zip) ) is not null order by p.name asc, a.zipCode asc""
		);
		assertNoLoss(
				""select ( (m.age - p.age) * 12 ), trim(upper(p.name)) from Person p, Person m where p.mother = m.id and ( p.age = (select max(p0.age) from Person p0 where (p0.mother=m.id)) and p.name like ? )""
		);
		assertNoLoss(
				""select * from Address a join Person p on a.pid = p.id, Person m join Address b on b.pid = m.id where p.mother = m.id and p.name like ?""
		);
		assertNoLoss(
				""select case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end from Person p where ( case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end ) like ?""
		);
		assertNoLoss(
				""/* Here we' go! */ select case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end from Person p where ( case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end ) like ?""
		);
	}",3.333333333333333
"/**
	 * Throws {@link org.hibernate.PropertyValueException} if there are any unresolved
	 * entity insert actions that depend on non-nullable associations with
	 * a transient entity. This method should be called on completion of
	 * an operation (after all cascades are completed) that saves an entity.
	 *
	 * @throws org.hibernate.PropertyValueException if there are any unresolved entity
	 * insert actions; {@link org.hibernate.PropertyValueException#getEntityName()}
	 * and {@link org.hibernate.PropertyValueException#getPropertyName()} will
	 * return the entity name and property value for the first unresolved
	 * entity insert action.
	 */
	public void checkNoUnresolvedActionsAfterOperation() throws PropertyValueException {
		if ( isEmpty() ) {
			LOG.trace( ""No entity insert actions have non-nullable, transient entity dependencies."" );
		}
		else {
			final AbstractEntityInsertAction firstDependentAction =
					dependenciesByAction.keySet().iterator().next();

			logCannotResolveNonNullableTransientDependencies( firstDependentAction.getSession() );

			final NonNullableTransientDependencies nonNullableTransientDependencies =
					dependenciesByAction.get( firstDependentAction );
			final Object firstTransientDependency =
					nonNullableTransientDependencies.getNonNullableTransientEntities().iterator().next();
			final String firstPropertyPath =
					nonNullableTransientDependencies.getNonNullableTransientPropertyPaths( firstTransientDependency ).iterator().next();

			throw new TransientPropertyValueException(
					""Not-null property references a transient value - transient instance must be saved before current operation"",
					firstDependentAction.getSession().guessEntityName( firstTransientDependency ),
					firstDependentAction.getEntityName(),
					firstPropertyPath
			);
		}
	}",3.333333333333333
"/**
	 * Handle sending notifications needed for natural-id after saving
	 *
	 * @param generatedId The generated entity identifier
	 */
	public void handleNaturalIdPostSaveNotifications(Serializable generatedId) {
		if ( isEarlyInsert() ) {
			// with early insert, we still need to add a local (transactional) natural id cross-reference
			getSession().getPersistenceContext().getNaturalIdHelper().manageLocalNaturalIdCrossReference(
					getPersister(),
					generatedId,
					state,
					null,
					CachedNaturalIdValueSource.INSERT
			);
		}
		// after save, we need to manage the shared cache entries
		getSession().getPersistenceContext().getNaturalIdHelper().manageSharedNaturalIdCrossReference(
				getPersister(),
				getId(),
				state,
				null,
				CachedNaturalIdValueSource.INSERT
		);
	}",3.888888888888889
"private boolean initializeLazyProperty(
			final String fieldName,
			final Object entity,
			final SessionImplementor session,
			final Object[] snapshot,
			final int j,
			final Object propValue) {
		setPropertyValue( entity, lazyPropertyNumbers[j], propValue );
		if ( snapshot != null ) {
			// object have been loaded with setReadOnly(true); HHH-2236
			snapshot[ lazyPropertyNumbers[j] ] = lazyPropertyTypes[j].deepCopy( propValue, factory );
		}
		return fieldName.equals( lazyPropertyNames[j] );
	}",3.888888888888889
"private void initOrdinaryPropertyPaths(Mapping mapping) throws MappingException {
		for ( int i = 0; i < getSubclassPropertyNameClosure().length; i++ ) {
			propertyMapping.initPropertyPaths( getSubclassPropertyNameClosure()[i],
					getSubclassPropertyTypeClosure()[i],
					getSubclassPropertyColumnNameClosure()[i],
					getSubclassPropertyColumnReaderClosure()[i],
					getSubclassPropertyColumnReaderTemplateClosure()[i],
					getSubclassPropertyFormulaTemplateClosure()[i],
					mapping );
		}
	}",3.888888888888889
"/**
	 * Delete an object
	 */
	public void delete(Serializable id, Object version, Object object, SessionImplementor session)
			throws HibernateException {
		final int span = getTableSpan();
		boolean isImpliedOptimisticLocking = !entityMetamodel.isVersioned() && isAllOrDirtyOptLocking();
		Object[] loadedState = null;
		if ( isImpliedOptimisticLocking ) {
			// need to treat this as if it where optimistic-lock=""all"" (dirty does *not* make sense);
			// first we need to locate the ""loaded"" state
			//
			// Note, it potentially could be a proxy, so doAfterTransactionCompletion the location the safe way...
			final EntityKey key = session.generateEntityKey( id, this );
			Object entity = session.getPersistenceContext().getEntity( key );
			if ( entity != null ) {
				EntityEntry entry = session.getPersistenceContext().getEntry( entity );
				loadedState = entry.getLoadedState();
			}
		}

		final String[] deleteStrings;
		if ( isImpliedOptimisticLocking && loadedState != null ) {
			// we need to utilize dynamic delete statements
			deleteStrings = generateSQLDeletStrings( loadedState );
		}
		else {
			// otherwise, utilize the static delete statements
			deleteStrings = getSQLDeleteStrings();
		}

		for ( int j = span - 1; j >= 0; j-- ) {
			delete( id, version, j, object, deleteStrings[j], session, loadedState );
		}

	}",3.555555555555556
"private UniqueEntityLoader getAppropriateLoader(LockOptions lockOptions, SessionImplementor session) {
		if ( queryLoader != null ) {
			// if the user specified a custom query loader we need to that
			// regardless of any other consideration
			return queryLoader;
		}
		else if ( isAffectedByEnabledFilters( session ) ) {
			// because filters affect the rows returned (because they add
			// restrictions) these need to be next in precedence
			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
		}
		else if ( session.getLoadQueryInfluencers().getInternalFetchProfile() != null && LockMode.UPGRADE.greaterThan( lockOptions.getLockMode() ) ) {
			// Next, we consider whether an 'internal' fetch profile has been set.
			// This indicates a special fetch profile Hibernate needs applied
			// (for its merge loading process e.g.).
			return ( UniqueEntityLoader ) getLoaders().get( session.getLoadQueryInfluencers().getInternalFetchProfile() );
		}
		else if ( isAffectedByEnabledFetchProfiles( session ) ) {
			// If the session has associated influencers we need to adjust the
			// SQL query used for loading based on those influencers
			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
		}
		else if ( isAffectedByEntityGraph( session ) ) {
			return createEntityLoader( lockOptions, session.getLoadQueryInfluencers() );
		}
		else if ( lockOptions.getTimeOut() != LockOptions.WAIT_FOREVER ) {
			return createEntityLoader( lockOptions, session.getLoadQueryInfluencers() );
		}
		else {
			return ( UniqueEntityLoader ) getLoaders().get( lockOptions.getLockMode() );
		}
	}",3.888888888888889
"public String[] toColumns(String alias, String propertyName) throws QueryException {
		if ( propertyName.equals(CollectionPropertyNames.COLLECTION_ELEMENTS) ) {
			return memberPersister.getElementColumnNames(alias);
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_INDICES) ) {
			if ( !memberPersister.hasIndex() ) throw new QueryException(""unindexed collection in indices()"");
			return memberPersister.getIndexColumnNames(alias);
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_SIZE) ) {
			String[] cols = memberPersister.getKeyColumnNames();
			return new String[] { ""count("" + alias + '.' + cols[0] + ')' };
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_MAX_INDEX) ) {
			if ( !memberPersister.hasIndex() ) throw new QueryException(""unindexed collection in maxIndex()"");
			String[] cols = memberPersister.getIndexColumnNames(alias);
			if ( cols.length!=1 ) throw new QueryException(""composite collection index in maxIndex()"");
			return new String[] { ""max("" + cols[0] + ')' };
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_MIN_INDEX) ) {
			if ( !memberPersister.hasIndex() ) throw new QueryException(""unindexed collection in minIndex()"");
			String[] cols = memberPersister.getIndexColumnNames(alias);
			if ( cols.length!=1 ) throw new QueryException(""composite collection index in minIndex()"");
			return new String[] { ""min("" + cols[0] + ')' };
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_MAX_ELEMENT) ) {
			String[] cols = memberPersister.getElementColumnNames(alias);
			if ( cols.length!=1 ) throw new QueryException(""composite collection element in maxElement()"");
			return new String[] { ""max("" + cols[0] + ')' };
		}
		else if ( propertyName.equals(CollectionPropertyNames.COLLECTION_MIN_ELEMENT) ) {
			String[] cols = memberPersister.getElementColumnNames(alias);
			if ( cols.length!=1 ) throw new QueryException(""composite collection element in minElement()"");
			return new String[] { ""min("" + cols[0] + ')' };
		}
		else {
			//return memberPersister.toColumns(alias, propertyName);
			throw new QueryException(""illegal syntax near collection: "" + propertyName);
		}
	}",3.333333333333333
"private void bindIndex(final Mappings mappings) {
		if ( !indexColumn.isImplicit() ) {
			PropertyHolder valueHolder = PropertyHolderBuilder.buildPropertyHolder(
					this.collection,
					StringHelper.qualify( this.collection.getRole(), ""key"" ),
					null,
					null, propertyHolder, mappings
			);
			List list = (List) this.collection;
			if ( !list.isOneToMany() ) indexColumn.forceNotNull();
			indexColumn.setPropertyHolder( valueHolder );
			SimpleValueBinder value = new SimpleValueBinder();
			value.setColumns( new Ejb3Column[] { indexColumn } );
			value.setExplicitType( ""integer"" );
			value.setMappings( mappings );
			SimpleValue indexValue = value.make();
			indexColumn.linkWithValue( indexValue );
			list.setIndex( indexValue );
			list.setBaseIndex( indexColumn.getBase() );
			if ( list.isOneToMany() && !list.getKey().isNullable() && !list.isInverse() ) {
				String entityName = ( (OneToMany) list.getElement() ).getReferencedEntityName();
				PersistentClass referenced = mappings.getClass( entityName );
				IndexBackref ib = new IndexBackref();
				ib.setName( '_' + propertyName + ""IndexBackref"" );
				ib.setUpdateable( false );
				ib.setSelectable( false );
				ib.setCollectionRole( list.getRole() );
				ib.setEntityName( list.getOwner().getEntityName() );
				ib.setValue( list.getIndex() );
				referenced.addProperty( ib );
			}
		}
		else {
			Collection coll = this.collection;
			throw new AnnotationException(
					""List/array has to be annotated with an @OrderColumn (or @IndexColumn): ""
							+ coll.getRole()
			);
		}
	}",3.0
"/**
	 * Perform {@link org.hibernate.action.spi.Executable#execute()} on each element of the list
	 * 
	 * @param list The list of Executable elements to be performed
	 *
	 * @throws HibernateException
	 */
	private <E extends Executable & Comparable<?> & Serializable> void executeActions(ExecutableList<E> list) throws HibernateException {
		// todo : consider ways to improve the double iteration of Executables here:
		//		1) we explicitly iterate list here to perform Executable#execute()
		//		2) ExecutableList#getQuerySpaces also iterates the Executables to collect query spaces.
		try {
			for ( E e : list ) {
				try {
					e.execute();
				}
				finally {
					beforeTransactionProcesses.register( e.getBeforeTransactionCompletionProcess() );
					afterTransactionProcesses.register( e.getAfterTransactionCompletionProcess() );
				}
			}
		}
		finally {
			if ( session.getFactory().getSettings().isQueryCacheEnabled() ) {
				// Strictly speaking, only a subset of the list may have been processed if a RuntimeException occurs.
				// We still invalidate all spaces. I don't see this as a big deal - after all, RuntimeExceptions are
				// unexpected.
				Set<Serializable> propertySpaces = list.getQuerySpaces();
				invalidateSpaces( propertySpaces.toArray( new Serializable[propertySpaces.size()] ) );
			}
		}

		list.clear();
		session.getTransactionCoordinator().getJdbcCoordinator().executeBatch();
	}",3.555555555555556
"@SuppressWarnings( {""SimplifiableIfStatement""})
	private boolean isUnequivocallyNonDirty(Object entity) {

		if(entity instanceof SelfDirtinessTracker)
			return ((SelfDirtinessTracker) entity).$$_hibernate_hasDirtyAttributes();

		final CustomEntityDirtinessStrategy customEntityDirtinessStrategy =
				persistenceContext.getSession().getFactory().getCustomEntityDirtinessStrategy();
		if ( customEntityDirtinessStrategy.canDirtyCheck( entity, getPersister(), (Session) persistenceContext.getSession() ) ) {
			return ! customEntityDirtinessStrategy.isDirty( entity, getPersister(), (Session) persistenceContext.getSession() );
		}

		if ( getPersister().hasMutableProperties() ) {
			return false;
		}

		if ( getPersister().getInstrumentationMetadata().isInstrumented() ) {
			// the entity must be instrumented (otherwise we cant check dirty flag) and the dirty flag is false
			return ! getPersister().getInstrumentationMetadata().extractInterceptor( entity ).isDirty();
		}

		return false;
	}",3.0
"public static String expandBatchIdPlaceholder(
			String sql,
			Serializable[] ids,
			String alias,
			String[] keyColumnNames,
			Dialect dialect) {
		if ( keyColumnNames.length == 1 ) {
			// non-composite
			return StringHelper.replace( sql, BATCH_ID_PLACEHOLDER, repeat( ""?"", ids.length, "","" ) );
		}
		else {
			// composite
			if ( dialect.supportsRowValueConstructorSyntaxInInList() ) {
				final String tuple = ""("" + StringHelper.repeat( ""?"", keyColumnNames.length, "","" );
				return StringHelper.replace( sql, BATCH_ID_PLACEHOLDER, repeat( tuple, ids.length, "","" ) );
			}
			else {
				final String keyCheck = joinWithQualifier( keyColumnNames, alias, "" and "" );
				return replace( sql, BATCH_ID_PLACEHOLDER, repeat( keyCheck, ids.length, "" or "" ) );
			}
		}
	}",3.888888888888889
"/**
	 * Interpret a long as its binary form
	 *
	 * @param longValue The long to interpret to binary
	 *
	 * @return The binary
	 */
	public static byte[] fromLong(long longValue) {
		byte[] bytes = new byte[8];
		bytes[0] = (byte) ( longValue >> 56 );
		bytes[1] = (byte) ( ( longValue << 8 ) >> 56 );
		bytes[2] = (byte) ( ( longValue << 16 ) >> 56 );
		bytes[3] = (byte) ( ( longValue << 24 ) >> 56 );
		bytes[4] = (byte) ( ( longValue << 32 ) >> 56 );
		bytes[5] = (byte) ( ( longValue << 40 ) >> 56 );
		bytes[6] = (byte) ( ( longValue << 48 ) >> 56 );
		bytes[7] = (byte) ( ( longValue << 56 ) >> 56 );
		return bytes;
	}",4.111111111111111
"/**
     * Tests this instance for equality with an arbitrary object.
     *
     * @param obj  the object (<code>null</code> permitted).
     *
     * @return A boolean.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof OHLC)) {
            return false;
        }
        OHLC that = (OHLC) obj;
        if (this.open != that.open) {
            return false;
        }
        if (this.close != that.close) {
            return false;
        }
        if (this.high != that.high) {
            return false;
        }
        if (this.low != that.low) {
            return false;
        }
        return true;
    }",4.666666666666667
"public final void caseSList() throws RecognitionException, TokenStreamException {
		
		
		{
		_loop119:
		do {
			if ((_tokenSet_6.member(LA(1)))) {
				statement();
			}
			else {
				break _loop119;
			}
			
		} while (true);
		}
	}",3.333333333333333
"public void write(BufferedReader reader,
                      BufferedWriter writer,
                      Stack parseStateStack) throws IOException {
        ParseState parseState = (ParseState) parseStateStack.peek();
        Object mInterface = /*(MInterface)*/ parseState.newClassifier(name);

	if (mInterface != null) {
	    parseStateStack.push(new ParseState(mInterface));
	    StringBuffer sbText =
		GeneratorJava.getInstance().generateClassifierStart(mInterface);
	    if (sbText != null) {
		writer.write (sbText.toString());
	    }
            // dispose code piece in reader
            ffCodePiece(reader, null);
        } else {
            // not in model, so write the original code
            ffCodePiece(reader, writer);
        }
    }",3.555555555555556
"protected final void mHEX_DIGIT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype; Token _token=null; int _begin=text.length();
		_ttype = HEX_DIGIT;
		int _saveIndex;
		
		{
		switch ( LA(1)) {
		case '0':  case '1':  case '2':  case '3':
		case '4':  case '5':  case '6':  case '7':
		case '8':  case '9':
		{
			matchRange('0','9');
			break;
		}
		case 'A':  case 'B':  case 'C':  case 'D':
		case 'E':  case 'F':
		{
			matchRange('A','F');
			break;
		}
		case 'a':  case 'b':  case 'c':  case 'd':
		case 'e':  case 'f':
		{
			matchRange('a','f');
			break;
		}
		default:
		{
			throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
		}
		}
		}
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}",3.555555555555556
"/**
     * The constructor.
     */
    public TabChecklist() {
	super(""tab.checklist"");

	tableModel = new TableModelChecklist(this);
	table.setModel(tableModel);

	Font labelFont = LookAndFeelMgr.getInstance().getStandardFont();
	table.setFont(labelFont);

	table.setIntercellSpacing(new Dimension(0, 1));
	table.setShowVerticalLines(false);
	table.getSelectionModel().addListSelectionListener(this);
	table.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);

	TableColumn checkCol = table.getColumnModel().getColumn(0);
	TableColumn descCol = table.getColumnModel().getColumn(1);
	checkCol.setMinWidth(20);
	checkCol.setMaxWidth(30);
	checkCol.setWidth(30);
	descCol.setPreferredWidth(900);
	table.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
	table.sizeColumnsToFit(-1);

	JScrollPane sp = new JScrollPane(table);

	setLayout(new BorderLayout());
	add(new JLabel(Translator.localize(""tab.checklist.warning"")),
	    BorderLayout.NORTH);
	add(sp, BorderLayout.CENTER);
	
	addComponentListener(this);
    }",3.888888888888889
"public void vetoableChange(PropertyChangeEvent pce) {
        if (""ownedElement"".equals(pce.getPropertyName())) {
            Vector oldOwned = (Vector) pce.getOldValue();
            Object eo = pce.getNewValue();
            Object me = Model.getFacade().getModelElement(eo);
            if (oldOwned.contains(eo)) {
                LOG.debug(""model removed "" + me);
                if (Model.getFacade().isANode(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isANodeInstance(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAComponent(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAComponentInstance(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAClass(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAInterface(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAObject(me)) {
                    removeNode(me);
                }
                if (Model.getFacade().isAAssociation(me)) {
                    removeEdge(me);
                }
                if (Model.getFacade().isADependency(me)) {
                    removeEdge(me);
                }
                if (Model.getFacade().isALink(me)) {
                    removeEdge(me);
                }
            } else {
                LOG.debug(""model added "" + me);
            }
        }
    }",4.111111111111111
"public List getInEdges(Object port) {
	Vector res = new Vector(); //wasteful!
	if (Model.getFacade().isAClassifierRole(port)) {
	    Object cr = port;
	    Collection ends = Model.getFacade().getAssociationEnds(cr);
	    if (ends == null) {
                return res; // empty Vector
            }
	    Iterator iter = ends.iterator();
	    while (iter.hasNext()) {
		Object aer = iter.next();
		res.addElement(Model.getFacade().getAssociation(aer));
	    }
	}
	return res;
    }
",3.888888888888889
"/**
     * Displays visual indications of pending ToDoItems.
     * Please note that the list of advices (ToDoList) is not the same
     * as the list of element known by the FigNode (_figs). Therefore,
     * it is necessary to check if the graphic item exists before drawing
     * on it. See ClAttributeCompartment for an example.
     * @param g the graphics device
     * @see org.argouml.uml.cognitive.critics.ClAttributeCompartment
     */
    public void paintClarifiers(Graphics g) {
        int iconX = getX();
        int iconY = getY() - 10;
        ToDoList list = Designer.theDesigner().getToDoList();
        Vector items = list.elementsForOffender(getOwner());
        int size = items.size();
        for (int i = 0; i < size; i++) {
            ToDoItem item = (ToDoItem) items.elementAt(i);
            Icon icon = item.getClarifier();
            if (icon instanceof Clarifier) {
                ((Clarifier) icon).setFig(this);
                ((Clarifier) icon).setToDoItem(item);
            }
            if (icon != null) {
                icon.paintIcon(null, g, iconX, iconY);
                iconX += icon.getIconWidth();
            }
        }
        items = list.elementsForOffender(this);
        size = items.size();
        for (int i = 0; i < size; i++) {
            ToDoItem item = (ToDoItem) items.elementAt(i);
            Icon icon = item.getClarifier();
            if (icon instanceof Clarifier) {
                ((Clarifier) icon).setFig(this);
                ((Clarifier) icon).setToDoItem(item);
            }
            if (icon != null) {
                icon.paintIcon(null, g, iconX, iconY);
                iconX += icon.getIconWidth();
            }
        }
    }",3.333333333333333
"public void mouseMoved(MouseEvent me) {
	//- RedrawManager.lock();
	translateMouseEvent(me);
	Globals.curEditor(this);
	setUnderMouse(me);
        Fig currentFig = getCurrentFig();
	if (currentFig != null && Globals.getShowFigTips()) {
	    String tip = currentFig.getTipString(me);
	    if (tip != null && (getJComponent() != null)) {
	        JComponent c = getJComponent();
	        if (c.getToolTipText() == null
		    || !(c.getToolTipText().equals(tip))) {
	            c.setToolTipText(tip);
	        }
            }
	} else if (getJComponent() != null
		   && getJComponent().getToolTipText() != null) {
            getJComponent().setToolTipText(null); //was """"
	}

	_selectionManager.mouseMoved(me);
	_modeManager.mouseMoved(me);
	//- RedrawManager.unlock();
	//- _redrawer.repairDamage();
    }",3.2222222222222223
"public Set getDependencies(Object parent) {
        if (Model.getFacade().isAClass(parent)) {
	    Set set = new HashSet();
	    set.add(parent);
	    set.addAll(Model.getFacade().getAttributes(parent));
	    set.addAll(Model.getFacade().getOperations(parent));
	    set.addAll(Model.getFacade().getAssociationEnds(parent));
	    set.addAll(Model.getFacade().getSupplierDependencies(parent));
	    set.addAll(Model.getFacade().getClientDependencies(parent));
	    set.addAll(Model.getFacade().getGeneralizations(parent));
	    set.addAll(Model.getFacade().getSpecializations(parent));
	    return set;
	}

	return null;
    }",4.666666666666667
"@Test
    public void listenersAreCalledCorrectlyInTheFaceOfFailures()
            throws Exception {
        JUnitCore core = new JUnitCore();
        final List<Failure> failures = new ArrayList<Failure>();
        core.addListener(new RunListener() {
            @Override
            public void testRunFinished(Result result) throws Exception {
                failures.addAll(result.getFailures());
            }
        });
        fMax.run(Request.aClass(TwoTests.class), core);
        assertEquals(1, failures.size());
    }",3.2222222222222223
"private Exception createTimeoutException(Thread thread) {
        StackTraceElement[] stackTrace = thread.getStackTrace();
        final Thread stuckThread = fLookForStuckThread ? getStuckThread(thread) : null;
        Exception currThreadException = new Exception(String.format(
                ""test timed out after %d %s"", fTimeout, fTimeUnit.name().toLowerCase()));
        if (stackTrace != null) {
            currThreadException.setStackTrace(stackTrace);
            thread.interrupt();
        }
        if (stuckThread != null) {
            Exception stuckThreadException = 
                new Exception (""Appears to be stuck in thread "" +
                               stuckThread.getName());
            stuckThreadException.setStackTrace(getStackTrace(stuckThread));
            return new MultipleFailureException    
                (Arrays.<Throwable>asList(currThreadException, stuckThreadException));
        } else {
            return currThreadException;
        }
    }",2.888888888888889
"/**
	 * Build the metamodel using the information from the collection of Hibernate
	 * {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
	 *
	 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
	 * @param mappedSuperclasses All known MappedSuperclasses
	 * @param sessionFactory The Hibernate session factory.
     * @param ignoreUnsupported ignore unsupported/unknown annotations (like @Any)
	 *
	 * @return The built metamodel
	 */
	public static MetamodelImpl buildMetamodel(
			Iterator<PersistentClass> persistentClasses,
			Set<MappedSuperclass> mappedSuperclasses,
			SessionFactoryImplementor sessionFactory,
            boolean ignoreUnsupported) {
		MetadataContext context = new MetadataContext( sessionFactory, mappedSuperclasses, ignoreUnsupported );
		while ( persistentClasses.hasNext() ) {
			PersistentClass pc = persistentClasses.next();
			locateOrBuildEntityType( pc, context );
		}
		handleUnusedMappedSuperclasses( context );
		context.wrapUp();
		return new MetamodelImpl( context.getEntityTypeMap(), context.getEmbeddableTypeMap(), context.getMappedSuperclassTypeMap(), context.getEntityTypesByEntityName() );
	}",3.111111111111111
"@Test
	public void testExplicitJoining() throws Exception {
		assertFalse( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );

		SessionImplementor session = (SessionImplementor) sessionFactory().withOptions().autoJoinTransactions( false ).openSession();
		TransactionImplementor transaction = (TransactionImplementor) ( (Session) session ).getTransaction();

		assertFalse( session.getTransactionCoordinator().isSynchronizationRegistered() );
		assertFalse( transaction.isParticipating() );

		session.getFlushMode();  // causes a call to TransactionCoordinator#pulse

		assertFalse( session.getTransactionCoordinator().isSynchronizationRegistered() );
		assertFalse( transaction.isParticipating() );

		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();

		assertTrue( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );
		assertTrue( transaction.isActive() );
		assertFalse( transaction.isParticipating() );
		assertFalse( session.getTransactionCoordinator().isSynchronizationRegistered() );

		session.getFlushMode();

		assertTrue( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );
		assertTrue( transaction.isActive() );
		assertFalse( session.getTransactionCoordinator().isSynchronizationRegistered() );
		assertFalse( transaction.isParticipating() );

		transaction.markForJoin();
		transaction.join();
		session.getFlushMode();

		assertTrue( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );
		assertTrue( transaction.isActive() );
		assertTrue( session.getTransactionCoordinator().isSynchronizationRegistered() );
		assertTrue( transaction.isParticipating() );

		( (Session) session ).close();

		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
	}",2.7777777777777777
"@Test
	public void testImplicitJoining() throws Exception {
		assertFalse( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );

		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
		assertTrue( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) );

		SessionImplementor session = (SessionImplementor) sessionFactory().withOptions().autoJoinTransactions( false ).openSession();

		session.getFlushMode();
	}",3.333333333333333
"public void testOneToOnePropertyRefGeneratedIds() {
		try {
			Session s = openSession();
			s.beginTransaction();
			Child c2 = new Child( ""c2"" );
			ChildInfo info = new ChildInfo( ""blah blah blah"" );
			c2.setInfo( info );
			info.setOwner( c2 );
			s.persist( c2 );
			try {
				s.getTransaction().commit();
				fail( ""expecting TransientObjectException on flush"" );
			}
			catch( TransientObjectException e ) {
				// expected result
				log.trace( ""handled expected exception : "" + e );
				s.getTransaction().rollback();
			}
			finally {
				s.close();
			}
		}
		finally {
			cleanupData();
		}
	}",4.111111111111111
"@Test
   public void testBuildEntityCollectionRegionOverridesOnly() {
      AdvancedCache cache;
      Properties p = new Properties();
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.strategy"", ""LIRS"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.wake_up_interval"", ""3000"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.max_entries"", ""30000"");
      p.setProperty(""hibernate.cache.infinispan.collection.eviction.strategy"", ""LRU"");
      p.setProperty(""hibernate.cache.infinispan.collection.eviction.wake_up_interval"", ""3500"");
      p.setProperty(""hibernate.cache.infinispan.collection.eviction.max_entries"", ""35000"");
      InfinispanRegionFactory factory = createRegionFactory(p);
      try {
         factory.getCacheManager();
         EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion(""com.acme.Address"", p, null);
         assertNull(factory.getTypeOverrides().get(""com.acme.Address""));
         cache = region.getCache();
         Configuration cacheCfg = cache.getCacheConfiguration();
         assertEquals(EvictionStrategy.LIRS, cacheCfg.eviction().strategy());
         assertEquals(3000, cacheCfg.expiration().wakeUpInterval());
         assertEquals(30000, cacheCfg.eviction().maxEntries());
         // Max idle value comes from base XML configuration
         assertEquals(100000, cacheCfg.expiration().maxIdle());

         CollectionRegionImpl collectionRegion = (CollectionRegionImpl)
               factory.buildCollectionRegion(""com.acme.Person.addresses"", p, null);
         assertNull(factory.getTypeOverrides().get(""com.acme.Person.addresses""));
         cache = collectionRegion.getCache();
         cacheCfg = cache.getCacheConfiguration();
         assertEquals(EvictionStrategy.LRU, cacheCfg.eviction().strategy());
         assertEquals(3500, cacheCfg.expiration().wakeUpInterval());
         assertEquals(35000, cacheCfg.eviction().maxEntries());
         assertEquals(100000, cacheCfg.expiration().maxIdle());
      } finally {
         factory.stop();
      }
   }",3.2222222222222223
"@Test
   public void testBuildEntityRegionPersonPlusEntityOverridesWithoutCfg() {
      final String person = ""com.acme.Person"";
      Properties p = new Properties();
      // Third option, no cache defined for entity and overrides for generic entity data type and entity itself.
      p.setProperty(""hibernate.cache.infinispan.com.acme.Person.eviction.strategy"", ""LRU"");
      p.setProperty(""hibernate.cache.infinispan.com.acme.Person.expiration.lifespan"", ""60000"");
      p.setProperty(""hibernate.cache.infinispan.com.acme.Person.expiration.max_idle"", ""30000"");
      p.setProperty(""hibernate.cache.infinispan.entity.cfg"", ""myentity-cache"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.strategy"", ""FIFO"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.wake_up_interval"", ""3000"");
      p.setProperty(""hibernate.cache.infinispan.entity.eviction.max_entries"", ""10000"");
      InfinispanRegionFactory factory = createRegionFactory(p);
      try {
         factory.getCacheManager();
         assertNotNull(factory.getTypeOverrides().get(person));
         assertFalse(factory.getDefinedConfigurations().contains(person));
         EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion(person, p, null);
         assertNotNull(factory.getTypeOverrides().get(person));
         assertTrue(factory.getDefinedConfigurations().contains(person));
         AdvancedCache cache = region.getCache();
         Configuration cacheCfg = cache.getCacheConfiguration();
         assertEquals(EvictionStrategy.LRU, cacheCfg.eviction().strategy());
         assertEquals(3000, cacheCfg.expiration().wakeUpInterval());
         assertEquals(10000, cacheCfg.eviction().maxEntries());
         assertEquals(60000, cacheCfg.expiration().lifespan());
         assertEquals(30000, cacheCfg.expiration().maxIdle());
      } finally {
         factory.stop();
      }
   }",3.333333333333333
"private InfinispanRegionFactory createRegionFactory(final EmbeddedCacheManager manager, Properties p) {
      final InfinispanRegionFactory factory = new SingleNodeTestCase.TestInfinispanRegionFactory() {

         @Override
         protected org.infinispan.transaction.lookup.TransactionManagerLookup createTransactionManagerLookup(Settings settings, Properties properties) {
            return new HibernateTransactionManagerLookup(null, null) {
               @Override
               public TransactionManager getTransactionManager() throws Exception {
                  AbstractJtaPlatform jta = new JBossStandAloneJtaPlatform();
                  jta.injectServices(ServiceRegistryBuilder.buildServiceRegistry());
                  return jta.getTransactionManager();
               }
            };
         }

         @Override
         protected EmbeddedCacheManager createCacheManager(Properties properties) throws CacheException {
            if (manager != null)
               return manager;
            else
               return super.createCacheManager(properties);
         }

      };

      factory.start(null, p);
      return factory;
   }",2.888888888888889
"@Test
	public void testAcceptsUnresolvedPropertyTypesIfATargetEntityIsExplicitlySet() {
		Session s = openSession();
		Transaction tx = s.beginTransaction();
		Gene item = new Gene();
		s.persist( item );
		s.flush();
		tx.rollback();
		s.close();
	}",4.555555555555555
"@Test
	@TestForIssue( jiraKey = ""HHH-4685"" )
	public void testOneToManyEmbeddableBiDirectionalDotNotationInMappedBy() throws Exception {
		// Section 11.1.26
		// The ManyToOne annotation may be used within an embeddable class to specify a relationship from the embeddable
		// class to an entity class. If the relationship is bidirectional, the non-owning OneToMany entity side must use the
		// mappedBy element of the OneToMany annotation to specify the relationship field or property of the embeddable field
		// or property on the owning side of the relationship. The dot (""."") notation syntax must be used in the mappedBy
		// element to indicate the relationship attribute within the embedded attribute. The value of each identifier used
		// with the dot notation is the name of the respective embedded field or property.
		Session s;
		s = openSession();
		s.getTransaction().begin();
		Employee e = new Employee();
		JobInfo job = new JobInfo();
		job.setJobDescription( ""Sushi Chef"" );
		ProgramManager pm = new ProgramManager();
		Collection<Employee> employees = new ArrayList<Employee>();
		employees.add(e);
		pm.setManages( employees );
		job.setPm(pm);
		e.setJobInfo( job );
		s.persist( e );
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.getTransaction().begin();
		e = (Employee) s.get( e.getClass(), e.getId() );
		assertEquals( ""same job in both directions"", 
			e.getJobInfo().getJobDescription(),
			e.getJobInfo().getPm().getManages().iterator().next().getJobInfo().getJobDescription()  );
		s.getTransaction().commit();
		s.close();
	}",3.7777777777777777
"@Test
	public void testAssociationRelatedAnnotations() throws Exception {
		XMLContext context = buildContext( ""org/hibernate/test/annotations/reflection/orm.xml"" );

		Field field = Administration.class.getDeclaredField( ""defaultBusTrip"" );
		JPAOverriddenAnnotationReader reader = new JPAOverriddenAnnotationReader( field, context );
		assertNotNull( reader.getAnnotation( OneToOne.class ) );
		assertNull( reader.getAnnotation( JoinColumns.class ) );
		assertNotNull( reader.getAnnotation( PrimaryKeyJoinColumns.class ) );
		assertEquals( ""pk"", reader.getAnnotation( PrimaryKeyJoinColumns.class ).value()[0].name() );
		assertEquals( 5, reader.getAnnotation( OneToOne.class ).cascade().length );
		assertEquals( FetchType.LAZY, reader.getAnnotation( OneToOne.class ).fetch() );
		assertEquals( ""test"", reader.getAnnotation( OneToOne.class ).mappedBy() );

		context = buildContext(
				""org/hibernate/test/annotations/reflection/metadata-complete.xml""
		);
		field = BusTrip.class.getDeclaredField( ""players"" );
		reader = new JPAOverriddenAnnotationReader( field, context );
		assertNotNull( reader.getAnnotation( OneToMany.class ) );
		assertNotNull( reader.getAnnotation( JoinColumns.class ) );
		assertEquals( 2, reader.getAnnotation( JoinColumns.class ).value().length );
		assertEquals( ""driver"", reader.getAnnotation( JoinColumns.class ).value()[0].name() );
		assertNotNull( reader.getAnnotation( MapKey.class ) );
		assertEquals( ""name"", reader.getAnnotation( MapKey.class ).name() );

		field = BusTrip.class.getDeclaredField( ""roads"" );
		reader = new JPAOverriddenAnnotationReader( field, context );
		assertNotNull( reader.getAnnotation( ManyToMany.class ) );
		assertNotNull( reader.getAnnotation( JoinTable.class ) );
		assertEquals( ""bus_road"", reader.getAnnotation( JoinTable.class ).name() );
		assertEquals( 2, reader.getAnnotation( JoinTable.class ).joinColumns().length );
		assertEquals( 1, reader.getAnnotation( JoinTable.class ).inverseJoinColumns().length );
		assertEquals( 2, reader.getAnnotation( JoinTable.class ).uniqueConstraints()[0].columnNames().length );
		assertNotNull( reader.getAnnotation( OrderBy.class ) );
		assertEquals( ""maxSpeed"", reader.getAnnotation( OrderBy.class ).value() );
	}",2.6666666666666665
"@Test
	@TestForIssue(jiraKey = ""HHH-4699"")
	@SkipForDialect(value = { Oracle8iDialect.class, AbstractHANADialect.class }, jiraKey = ""HHH-8516"",
			comment = ""HHH-4699 was specifically for using a CHAR, but Oracle/HANA do not handle the 2nd query correctly without VARCHAR. "")
	public void testTrimmedEnumChar() throws SQLException {
		// use native SQL to insert, forcing whitespace to occur
		final Session s = openSession();
        final Connection connection = ((SessionImplementor)s).connection();
        final Statement statement = connection.createStatement();
        statement.execute(""insert into EntityEnum (id, trimmed) values(1, '"" + Trimmed.A.name() + ""')"");
        statement.execute(""insert into EntityEnum (id, trimmed) values(2, '"" + Trimmed.B.name() + ""')"");

        s.getTransaction().begin();

        // ensure EnumType can do #fromName with the trimming
        List<EntityEnum> resultList = s.createQuery(""select e from EntityEnum e"").list();
        assertEquals( resultList.size(), 2 );
        assertEquals( resultList.get(0).getTrimmed(), Trimmed.A );
        assertEquals( resultList.get(1).getTrimmed(), Trimmed.B );

        // ensure querying works
        final Query query = s.createQuery(""select e from EntityEnum e where e.trimmed=?"");
        query.setParameter( 0, Trimmed.A );
        resultList = query.list();
        assertEquals( resultList.size(), 1 );
        assertEquals( resultList.get(0).getTrimmed(), Trimmed.A );

		statement.execute( ""delete from EntityEnum"" );

        s.getTransaction().commit();
        s.close();
	}",3.6666666666666665
"@Test
	public void testWithEJB3NamingStrategy() throws Exception {
		SessionFactory  sf = null;
		try {
			AnnotationConfiguration config = new AnnotationConfiguration();
			config.setNamingStrategy(EJB3NamingStrategy.INSTANCE);
			config.addAnnotatedClass(A.class);
			config.addAnnotatedClass(AddressEntry.class);
			sf = config.buildSessionFactory( serviceRegistry );
			Mappings mappings = config.createMappings();
			boolean foundIt = false;

			for ( Iterator iter = mappings.iterateTables(); iter.hasNext();  ) {
				Table table = (Table) iter.next();
                log.info(""testWithEJB3NamingStrategy table = "" + table.getName());
				if ( table.getName().equalsIgnoreCase(""A_ADDRESS"")) {
					foundIt = true;
				}
				// make sure we use A_ADDRESS instead of AEC_address
				assertFalse(""got table name mapped to: AEC_address (should be A_ADDRESS) which violates JPA-2 spec section 11.1.8 ([OWNING_ENTITY_NAME]_[COLLECTION_ATTRIBUTE_NAME])"",table.getName().equalsIgnoreCase(""AEC_address""));
			}
			assertTrue(""table not mapped to A_ADDRESS which violates JPA-2 spec section 11.1.8"",foundIt);
		}
		catch( Exception e ) {
			StringWriter writer = new StringWriter();
			e.printStackTrace(new PrintWriter(writer));
            log.debug(writer.toString());
			fail(e.getMessage());
		} finally {
			if( sf != null ){
				sf.close();
			}
		}
	}",3.0
"@Test
	@SkipForDialects( {
			@SkipForDialect( value = { HSQLDialect.class }, comment = ""The used join conditions does not work in HSQLDB. See HHH-4497."" ), 
			@SkipForDialect( value = { SQLServer2005Dialect.class } ),
			@SkipForDialect( value = { Oracle8iDialect.class }, comment = ""Oracle/DB2 do not support 'substring' function"" ),
			@SkipForDialect( value = { DB2Dialect.class }, comment = ""Oracle/DB2 do not support 'substring' function"" ) } )
	public void testManyToOneFromNonPkToNonPk() throws Exception {
		// also tests usage of the stand-alone @JoinFormula annotation (i.e. not wrapped within @JoinColumnsOrFormulas)
		Session s = openSession();
		Transaction tx = s.beginTransaction();

        Product kit = new Product();
        kit.id = 1;
        kit.productIdnf = ""KIT"";
        kit.description = ""Kit"";
        s.persist(kit);

        Product kitkat = new Product();
        kitkat.id = 2;
        kitkat.productIdnf = ""KIT_KAT"";
        kitkat.description = ""Chocolate"";
        s.persist(kitkat);

        s.flush();
        s.clear();

        kit = (Product) s.get(Product.class, 1);
        kitkat = (Product) s.get(Product.class, 2);
        System.out.println(kitkat.description);
        assertNotNull(kitkat);
        assertEquals(kit, kitkat.getProductFamily());
        assertEquals(kit.productIdnf, kitkat.getProductFamily().productIdnf);
        assertEquals(""KIT_KAT"", kitkat.productIdnf.trim());
        assertEquals(""Chocolate"", kitkat.description.trim());

        tx.rollback();
		s.close();
    }",3.7777777777777777
"public CollectionListeners( SessionFactory sf) {
		preCollectionRecreateListener = new PreCollectionRecreateListener( this );
		initializeCollectionListener = new InitializeCollectionListener( this );
		preCollectionRemoveListener = new PreCollectionRemoveListener( this );
		preCollectionUpdateListener = new PreCollectionUpdateListener( this );
		postCollectionRecreateListener = new PostCollectionRecreateListener( this );
		postCollectionRemoveListener = new PostCollectionRemoveListener( this );
		postCollectionUpdateListener = new PostCollectionUpdateListener( this );

		EventListenerRegistry registry = ( (SessionFactoryImplementor) sf ).getServiceRegistry().getService( EventListenerRegistry.class );
		registry.setListeners( EventType.INIT_COLLECTION, initializeCollectionListener );

		registry.setListeners( EventType.PRE_COLLECTION_RECREATE, preCollectionRecreateListener );
		registry.setListeners( EventType.POST_COLLECTION_RECREATE, postCollectionRecreateListener );

		registry.setListeners( EventType.PRE_COLLECTION_REMOVE, preCollectionRemoveListener );
		registry.setListeners( EventType.POST_COLLECTION_REMOVE, postCollectionRemoveListener );

		registry.setListeners( EventType.PRE_COLLECTION_UPDATE, preCollectionUpdateListener );
		registry.setListeners( EventType.POST_COLLECTION_UPDATE, postCollectionUpdateListener );
	}",4.111111111111111
"@Test
	public void testUpdateParentOneChildDiffCollectionDiffChild() {
		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
		ParentWithCollection parent = createParentWithOneChild( ""parent"", ""child"" );
		Child oldChild = ( Child ) parent.getChildren().iterator().next();
		listeners.clear();
		assertEquals( 1, parent.getChildren().size() );
		Session s = openSession();
		Transaction tx = s.beginTransaction();
		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
		if ( oldChild instanceof Entity ) {
			oldChild = ( Child ) s.get( oldChild.getClass(), ( ( Entity ) oldChild).getId() );
		}
		Collection oldCollection = parent.getChildren();
		parent.newChildren( createCollection() );
		Child newChild = parent.addChild( ""new1"" );
		tx.commit();
		s.close();
		int index = 0;
		if ( ( (PersistentCollection) oldCollection ).wasInitialized() ) {
			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, oldCollection, index++ );
		}
		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
			ChildWithBidirectionalManyToMany oldChildWithManyToMany = ( ChildWithBidirectionalManyToMany ) oldChild;
			if ( ( ( PersistentCollection ) oldChildWithManyToMany.getParents() ).wasInitialized() ) {
				checkResult( listeners, listeners.getInitializeCollectionListener(), oldChildWithManyToMany, index++ );
			}
		}
		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
			checkResult( listeners, listeners.getPreCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
			checkResult( listeners, listeners.getPostCollectionRecreateListener(), ( ChildWithBidirectionalManyToMany ) newChild, index++ );
		}
		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
		checkNumberOfResults( listeners, index );
	}",2.4444444444444446
"public int hashCode() {
        final int PRIME = 31;
        int result = 1;
        if ( name != null ) {
            result += name.hashCode();
        }
        result *= PRIME;
        if ( num != null ) {
            result += num.hashCode();
        }
        return result;
    }",4.333333333333333
"@Test
	public void testCascadeBasedBuild() {
		EntityPersister ep = (EntityPersister) sessionFactory().getClassMetadata(Message.class);
		CascadeStyleLoadPlanBuildingAssociationVisitationStrategy strategy = new CascadeStyleLoadPlanBuildingAssociationVisitationStrategy(
				CascadingActions.MERGE,
				sessionFactory(),
				LoadQueryInfluencers.NONE,
				LockMode.NONE
		);
		LoadPlan plan = MetamodelDrivenLoadPlanBuilder.buildRootEntityLoadPlan( strategy, ep );
		assertFalse( plan.hasAnyScalarReturns() );
		assertEquals( 1, plan.getReturns().size() );
		Return rtn = plan.getReturns().get( 0 );
		EntityReturn entityReturn = ExtraAssertions.assertTyping( EntityReturn.class, rtn );
		assertNotNull( entityReturn.getFetches() );
		assertEquals( 1, entityReturn.getFetches().length );
		Fetch fetch = entityReturn.getFetches()[0];
		EntityFetch entityFetch = ExtraAssertions.assertTyping( EntityFetch.class, fetch );
		assertNotNull( entityFetch.getFetches() );
		assertEquals( 0, entityFetch.getFetches().length );

		LoadPlanTreePrinter.INSTANCE.logTree( plan, new AliasResolutionContextImpl( sessionFactory() ) );
	}",3.111111111111111
"public LoadPlan buildLoadPlan(
			SessionFactoryImplementor sf,
			OuterJoinLoadable persister,
			LoadQueryInfluencers influencers,
			LockMode lockMode) {
		FetchStyleLoadPlanBuildingAssociationVisitationStrategy strategy = new FetchStyleLoadPlanBuildingAssociationVisitationStrategy(
				sf,
				influencers,
				lockMode
				);
		return MetamodelDrivenLoadPlanBuilder.buildRootEntityLoadPlan( strategy, persister );
	}",3.333333333333333
"private void compare(JoinWalker walker, LoadQueryDetails details) {
		System.out.println( ""------ SQL -----------------------------------------------------------------"" );
		System.out.println( ""WALKER    : "" + walker.getSQLString() );
		System.out.println( ""LOAD-PLAN : "" + details.getSqlStatement() );
		System.out.println( ""----------------------------------------------------------------------------"" );
		System.out.println( );
		System.out.println( ""------ SUFFIXES ------------------------------------------------------------"" );
		System.out.println( ""WALKER    : "" + StringHelper.join( "", "",  walker.getSuffixes() ) + "" : ""
									+ StringHelper.join( "", "", walker.getCollectionSuffixes() ) );
		System.out.println( ""----------------------------------------------------------------------------"" );
		System.out.println( );
	}",4.888888888888889
"@Test
	public void testExceptionHandling() {
		Session session = openSession();
		SessionImplementor sessionImpl = (SessionImplementor) session;
		boolean caught = false;
		try {
			PreparedStatement ps = sessionImpl.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer()
					.prepareStatement( ""select count(*) from NON_EXISTENT"" );
			sessionImpl.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().execute( ps );
		}
		catch ( JDBCException ok ) {
			caught = true;
		}
		finally {
			session.close();
		}

		assertTrue( ""The connection did not throw a JDBCException as expected"", caught );
	}",3.888888888888889
"private void doBasicPluralAttributeBinding(PluralAttributeSource source, AbstractPluralAttributeBinding binding) {
		binding.setFetchTiming( source.getFetchTiming() );
		binding.setFetchStyle( source.getFetchStyle() );
		binding.setCascadeStyles( source.getCascadeStyles() );

		binding.setCaching( source.getCaching() );

		binding.getHibernateTypeDescriptor().setJavaTypeName(
				source.getPluralAttributeNature().reportedJavaType().getName()
		);
		binding.getHibernateTypeDescriptor().setExplicitTypeName( source.getTypeInformation().getName() );
		binding.getHibernateTypeDescriptor().getTypeParameters().putAll( source.getTypeInformation().getParameters() );

		if ( StringHelper.isNotEmpty( source.getCustomPersisterClassName() ) ) {
			binding.setCollectionPersisterClass(
					currentBindingContext.<CollectionPersister>locateClassByName( source.getCustomPersisterClassName() )
			);
		}

		if ( source.getCustomPersisterClassName() != null ) {
			binding.setCollectionPersisterClass(
					metadata.<CollectionPersister>locateClassByName( source.getCustomPersisterClassName() )
			);
		}

		binding.setCustomLoaderName( source.getCustomLoaderName() );
		binding.setCustomSqlInsert( source.getCustomSqlInsert() );
		binding.setCustomSqlUpdate( source.getCustomSqlUpdate() );
		binding.setCustomSqlDelete( source.getCustomSqlDelete() );
		binding.setCustomSqlDeleteAll( source.getCustomSqlDeleteAll() );

		binding.setMetaAttributeContext(
				buildMetaAttributeContext(
						source.metaAttributes(),
						binding.getContainer().getMetaAttributeContext()
				)
		);

		doBasicAttributeBinding( source, binding );
	}",2.7777777777777777
"private void pushHibernateTypeInformationDownIfNeeded(
			HibernateTypeDescriptor hibernateTypeDescriptor,
			Value value,
			Type resolvedHibernateType) {
		if ( resolvedHibernateType == null ) {
			return;
		}
		if ( hibernateTypeDescriptor.getResolvedTypeMapping() == null ) {
			hibernateTypeDescriptor.setResolvedTypeMapping( resolvedHibernateType );
		}

		// java type information ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		if ( hibernateTypeDescriptor.getJavaTypeName() == null ) {
			hibernateTypeDescriptor.setJavaTypeName( resolvedHibernateType.getReturnedClass().getName() );
		}

	   // todo : this can be made a lot smarter, but for now this will suffice.  currently we only handle single value bindings

	   if ( SimpleValue.class.isInstance( value ) ) {
		   SimpleValue simpleValue = ( SimpleValue ) value;
		   if ( simpleValue.getDatatype() == null ) {
			   simpleValue.setDatatype(
					   new Datatype(
							   resolvedHibernateType.sqlTypes( metadata )[0],
							   resolvedHibernateType.getName(),
							   resolvedHibernateType.getReturnedClass()
					   )
			   );
		   }
	   }
	}",3.4444444444444446
"public static Iterable<AttributeDefinition> getCompositeCollectionIndexSubAttributes(CompositeCollectionElementDefinition compositionElementDefinition){
		final QueryableCollection collectionPersister =
				(QueryableCollection) compositionElementDefinition.getCollectionDefinition().getCollectionPersister();
		return getSingularSubAttributes(
				compositionElementDefinition.getSource(),
				(OuterJoinLoadable) collectionPersister.getOwnerEntityPersister(),
				(CompositeType) collectionPersister.getIndexType(),
				collectionPersister.getTableName(),
				collectionPersister.getIndexColumnNames()
		);
	}",3.0
"/**
	 * As per sections 12.2.3.23.9, 12.2.4.8.9 and 12.2.5.3.6 of the JPA 2.0
	 * specification, the element-collection subelement completely overrides the
	 * mapping for the specified field or property.  Thus, any methods which
	 * might in some contexts merge with annotations must not do so in this
	 * context.
	 */
	private void getElementCollection(List<Annotation> annotationList, XMLContext.Default defaults) {
		for ( Element element : elementsForProperty ) {
			if ( ""element-collection"".equals( element.getName() ) ) {
				AnnotationDescriptor ad = new AnnotationDescriptor( ElementCollection.class );
				addTargetClass( element, ad, ""target-class"", defaults );
				getFetchType( ad, element );
				getOrderBy( annotationList, element );
				getOrderColumn( annotationList, element );
				getMapKey( annotationList, element );
				getMapKeyClass( annotationList, element, defaults );
				getMapKeyTemporal( annotationList, element );
				getMapKeyEnumerated( annotationList, element );
				getMapKeyColumn( annotationList, element );
				buildMapKeyJoinColumns( annotationList, element );
				Annotation annotation = getColumn( element.element( ""column"" ), false, element );
				addIfNotNull( annotationList, annotation );
				getTemporal( annotationList, element );
				getEnumerated( annotationList, element );
				getLob( annotationList, element );
				//Both map-key-attribute-overrides and attribute-overrides
				//translate into AttributeOverride annotations, which need
				//need to be wrapped in the same AttributeOverrides annotation.
				List<AttributeOverride> attributes = new ArrayList<AttributeOverride>();
				attributes.addAll( buildAttributeOverrides( element, ""map-key-attribute-override"" ) );
				attributes.addAll( buildAttributeOverrides( element, ""attribute-override"" ) );
				annotation = mergeAttributeOverrides( defaults, attributes, false );
				addIfNotNull( annotationList, annotation );
				annotation = getAssociationOverrides( element, defaults, false );
				addIfNotNull( annotationList, annotation );
				getCollectionTable( annotationList, element, defaults );
				annotationList.add( AnnotationFactory.create( ad ) );
				getAccessType( annotationList, element );
			}
		}
	}",2.888888888888889
"@Override
	public void release() {
		if ( reader == null ) {
			return;
		}
		try {
			reader.close();
		}
		catch (IOException ignore) {
		}
	}",4.777777777777778
"@Override
	protected XMLEvent internalNextEvent() throws XMLStreamException {
		//If there is an iterator to read from reset was called, use the iterator
		//until it runs out of events.
		if (this.bufferReader != null) {
			final XMLEvent event = this.bufferReader.next();

			//If nothing left in the iterator, remove the reference and fall through to direct reading
			if (!this.bufferReader.hasNext()) {
				this.bufferReader = null;
			}

			return event;
		}

		//Get the next event from the underlying reader
		final XMLEvent event = this.getParent().nextEvent();

		//if buffering add the event
		if (this.eventLimit != 0) {
			this.eventBuffer.offer(event);

			//If limited buffer size and buffer is too big trim the buffer.
			if (this.eventLimit > 0 && this.eventBuffer.size() > this.eventLimit) {
				this.eventBuffer.poll();
			}
		}

		return event;
	}",4.555555555555555
"@Override
	public final String getElementText() throws XMLStreamException {
		XMLEvent event = this.previousEvent;
		if (event == null) {
			throw new XMLStreamException(""Must be on START_ELEMENT to read next text, element was null"");
		}
		if (!event.isStartElement()) {
			throw new XMLStreamException(""Must be on START_ELEMENT to read next text"", event.getLocation());
		}

		final StringBuilder text = new StringBuilder();
		while (!event.isEndDocument()) {
			switch (event.getEventType()) {
				case XMLStreamConstants.CHARACTERS:
				case XMLStreamConstants.SPACE:
				case XMLStreamConstants.CDATA: {
					final Characters characters = event.asCharacters();
					text.append(characters.getData());
					break;
				}
				case XMLStreamConstants.ENTITY_REFERENCE: {
					final EntityReference entityReference = (EntityReference)event;
					final EntityDeclaration declaration = entityReference.getDeclaration();
					text.append(declaration.getReplacementText());
					break;
				}
				case XMLStreamConstants.COMMENT:
				case XMLStreamConstants.PROCESSING_INSTRUCTION: {
					//Ignore
					break;
				}
				default: {
					throw new XMLStreamException(""Unexpected event type '"" + XMLStreamConstantsUtils.getEventName(event.getEventType()) + ""' encountered. Found event: "" + event, event.getLocation());
				}
			}

			event = this.nextEvent();
		}

		return text.toString();
	}",4.111111111111111
"public Point getClosestPoint(Point anotherPt) {
        Rectangle r = getBounds();
        int[] xs = {r.x + r.width / 2,
                    r.x + r.width,
                    r.x + r.width / 2,
                    r.x,
                    r.x + r.width / 2,
        };
        int[] ys = {r.y,
                    r.y + r.height / 2,
                    r.y + r.height,
                    r.y + r.height / 2,
                    r.y,
        };
        Point p =
            Geometry.ptClosestTo(
                xs,
                ys,
                5,
                anotherPt);
        return p;
    }",4.333333333333333
"protected void modelChanged(PropertyChangeEvent mee) {
        super.modelChanged(mee);
        final Object trCollection = mee.getNewValue();
        final String eName = mee.getPropertyName();
        final Object owner = getOwner();
        /*
         * A Concurrent region cannot have incoming or outgoing transitions so
         * incoming or outgoing transitions are redirected to its concurrent
         * composite state container.
         */
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                Object tr = null;
                // TODO: Is this comparison correct?
                // Where is the string created?
                if (eName == ""incoming"") {
                    if (!((Collection) trCollection).isEmpty()) {
                        tr = ((Collection) trCollection).iterator().next();
                    }
                    if (tr != null
                            && Model.getFacade().isATransition(tr)) {
                        Model.getCommonBehaviorHelper().setTarget(tr,
                                Model.getFacade().getContainer(owner));
                    }
                } else if (eName == ""outgoing"") {
                    if (!((Collection) trCollection).isEmpty()) {
                        tr = ((Collection) trCollection).iterator().next();
                    }
                    if (tr != null
                            && Model.getFacade().isATransition(tr))
                    {
                        Model.getStateMachinesHelper().setSource(tr,
                                Model.getFacade().getContainer(owner));
                    }
                }
            }
        });
    }",3.0
"public void setEnclosingFig(Fig encloser) {
        if (getOwner() != null) {
            Object nod = getOwner();
            if (encloser != null) {
                Object comp = encloser.getOwner();
                if (Model.getFacade().isAComponentInstance(comp)) {
                    if (Model.getFacade().getComponentInstance(nod) != comp) {
                        Model.getCommonBehaviorHelper()
                                .setComponentInstance(nod, comp);
                        super.setEnclosingFig(encloser);
                    }
                } else if (Model.getFacade().isANode(comp)) {
                    super.setEnclosingFig(encloser);
                }
            } else if (encloser == null) {
                if (isVisible() 
                        // If we are not visible most likely 
                        // we're being deleted.
                    // TODO: This indicates a more fundamental problem that should
                    // be investigated - tfm - 20061230
                    && Model.getFacade().getComponentInstance(nod) 
                                    != null) {
                    Model.getCommonBehaviorHelper()
                            .setComponentInstance(nod, null);
                    super.setEnclosingFig(encloser);
                }
            }
        }

        if (getLayer() != null) {
            // elementOrdering(figures);
            Collection contents = new ArrayList(getLayer().getContents());
            Iterator it = contents.iterator();
            while (it.hasNext()) {
                Object o = it.next();
                if (o instanceof FigEdgeModelElement) {
                    FigEdgeModelElement figedge = (FigEdgeModelElement) o;
                    figedge.getLayer().bringToFront(figedge);
                }
            }
        }
    }",2.888888888888889
"protected Object[] getUmlActions() {
        Object[] actions = {
            getActionPackage(),
            getActionClass(),
            null,
            getAssociationActions(),
            getAggregationActions(),
            getCompositionActions(),
            getActionAssociationEnd(),
            getActionGeneralization(),
            null,
            getActionInterface(),
            getActionRealization(),
            null,
            getDependencyActions(),
            null,
            getActionAttribute(),
            getActionOperation(),
            getActionAssociationClass(),
            null,
            getDataTypeActions(),
        };

        return actions;
    }",3.2222222222222223
"public void buildModel() {
        if (getTarget() != null) {
            Object target = getTarget();
            Object kind = Model.getFacade().getAggregation(target);
            if (kind == null
                    || kind.equals(
                            Model.getAggregationKind().getNone())) {
                setSelected(ActionSetAssociationEndAggregation.NONE_COMMAND);
            } else {
		if (kind.equals(
		        Model.getAggregationKind().getAggregate())) {
		    setSelected(ActionSetAssociationEndAggregation
		            .AGGREGATE_COMMAND);
		} else {
		    if (kind.equals(
		            Model.getAggregationKind()
		            	.getComposite())) {
			setSelected(ActionSetAssociationEndAggregation
			        .COMPOSITE_COMMAND);
		    } else {
		        setSelected(ActionSetAssociationEndAggregation

			        .NONE_COMMAND);
		    }
		}
            }
        }
    }",2.555555555555556
"/**
     * Construct a property panel for Node Instance elements.
     */
    public PropPanelNodeInstance() {
        super(""Node Instance"", lookupIcon(""NodeInstance""),
                ConfigLoader.getTabPropsOrientation());

        addField(Translator.localize(""label.name""), getNameTextField());
        addField(Translator.localize(""label.namespace""),
                getNamespaceSelector());

        addSeparator();

        addField(Translator.localize(""label.stimili-sent""),
                getStimuliSenderScroll());

        addField(Translator.localize(""label.stimili-received""),
                getStimuliReceiverScroll());

        JList resList = new UMLLinkedList(new UMLContainerResidentListModel());
        addField(Translator.localize(""label.residents""),
                new JScrollPane(resList));

        addSeparator();
        AbstractActionAddModelElement a =
            new ActionAddInstanceClassifier(Model.getMetaTypes().getNode());
        JScrollPane classifierScroll =
                new JScrollPane(new UMLMutableLinkedList(
	                new UMLInstanceClassifierListModel(),
	            a, null, null, true));
	addField(Translator.localize(""label.classifiers""),
                    classifierScroll);


        addAction(new ActionNavigateContainerElement());
        addAction(new ActionNewStereotype());
        addAction(getDeleteAction());
    }",2.6666666666666665
"@Test
    public void shouldReturnOnlyTheNamedDataPoints() throws Throwable {
        SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(TestClassWithNamedDataPoints.class));

        List<PotentialAssignment> assignments = supplier.getValueSources(signature(""methodWantingAllNamedStrings""));
        List<String> assignedStrings = getStringValuesFromAssignments(assignments);

        assertEquals(4, assignedStrings.size());
        assertThat(assignedStrings, hasItems(""named field"", ""named method"", ""named single value"", ""named single method value""));
    }",3.6666666666666665
"@Test
    public void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException()
            throws Throwable {
        thrown.expectMessage(""test timed out after 100 milliseconds"");
        try {
            evaluateWithException(new RuntimeException());
        } catch (Throwable expected) {
        }
        evaluateWithWaitDuration(TIMEOUT + 50);
    }",4.333333333333333
"@Test
    public void stackTraceContainsRealCauseOfTimeout() throws Throwable {
        StuckStatement stuck = new StuckStatement();
        FailOnTimeout stuckTimeout = new FailOnTimeout(stuck, TIMEOUT);
        try {
            stuckTimeout.evaluate();
            // We must not get here, we expect a timeout exception
            fail(""Expected timeout exception"");
        } catch (Exception timeoutException) {
            StackTraceElement[] stackTrace = timeoutException.getStackTrace();
            boolean stackTraceContainsTheRealCauseOfTheTimeout = false;
            boolean stackTraceContainsOtherThanTheRealCauseOfTheTimeout = false;
            for (StackTraceElement element : stackTrace) {
                String methodName = element.getMethodName();
                if (""theRealCauseOfTheTimeout"".equals(methodName)) {
                    stackTraceContainsTheRealCauseOfTheTimeout = true;
                }
                if (""notTheRealCauseOfTheTimeout"".equals(methodName)) {
                    stackTraceContainsOtherThanTheRealCauseOfTheTimeout = true;
                }
            }
            assertTrue(
                    ""Stack trace does not contain the real cause of the timeout"",
                    stackTraceContainsTheRealCauseOfTheTimeout);
            assertFalse(
                    ""Stack trace contains other than the real cause of the timeout, which can be very misleading"",
                    stackTraceContainsOtherThanTheRealCauseOfTheTimeout);
        }
    }",3.555555555555556
"@Test
	public void testQueryCacheModes() {
		EntityManager em = getOrCreateEntityManager();
		Query jpaQuery = em.createQuery( ""from SimpleEntity"" );
		AbstractQueryImpl hibQuery = (AbstractQueryImpl) ( (HibernateQuery) jpaQuery ).getHibernateQuery();

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.USE );
		assertEquals( CacheStoreMode.USE, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.NORMAL, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.BYPASS );
		assertEquals( CacheStoreMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.GET, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.REFRESH );
		assertEquals( CacheStoreMode.REFRESH, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.REFRESH, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE, CacheRetrieveMode.BYPASS );
		assertEquals( CacheRetrieveMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE ) );
		assertEquals( CacheStoreMode.REFRESH, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.REFRESH, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.BYPASS );
		assertEquals( CacheRetrieveMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE ) );
		assertEquals( CacheStoreMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.IGNORE, hibQuery.getCacheMode() );

		jpaQuery.setHint( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheStoreMode.USE );
		assertEquals( CacheRetrieveMode.BYPASS, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE ) );
		assertEquals( CacheStoreMode.USE, jpaQuery.getHints().get( AvailableSettings.SHARED_CACHE_STORE_MODE ) );
		assertEquals( CacheMode.PUT, hibQuery.getCacheMode() );
	}",2.6666666666666665
"@Test
	public void testRestrictedCorrelationNoExplicitSelection() {
		CriteriaBuilder builder = entityManagerFactory().getCriteriaBuilder();
		EntityManager em = getOrCreateEntityManager();
		em.getTransaction().begin();

		CriteriaQuery<Order> criteria = builder.createQuery( Order.class );
		Root<Order> orderRoot = criteria.from( Order.class );
		criteria.select( orderRoot );
		// create correlated subquery
		Subquery<Customer> customerSubquery = criteria.subquery( Customer.class );
		Root<Order> orderRootCorrelation = customerSubquery.correlate( orderRoot );
		Join<Order, Customer> orderCustomerJoin = orderRootCorrelation.join( ""customer"" );
		customerSubquery.where( builder.like( orderCustomerJoin.<String>get( ""name"" ), ""%Caruso"" ) );
		criteria.where( builder.exists( customerSubquery ) );
		em.createQuery( criteria ).getResultList();

		em.getTransaction().commit();
		em.close();
	}",2.888888888888889
"/**
	 * Get the value mapped to this key, or null if no value is mapped to this key.
	 *
	 * @param key The cache key
	 *
	 * @return The cached data
	 */
	public final Object get(Object key) {
		try {
			final Element element = getCache().get( key );
			if ( element == null ) {
				return null;
			}
			else {
				return element.getObjectValue();
			}
		}
		catch (net.sf.ehcache.CacheException e) {
			if ( e instanceof NonStopCacheException ) {
				HibernateNonstopCacheExceptionHandler.getInstance()
						.handleNonstopCacheException( (NonStopCacheException) e );
				return null;
			}
			else {
				throw new CacheException( e );
			}
		}
	}",4.222222222222222
"@Test
	public void testModFlagProperties() {
		assertEquals(
				TestTools.makeSet( ""comp1_MOD"" ),
				TestTools.extractModProperties(
						getCfg().getClassMapping(
								""org.hibernate.envers.test.entities.components.ComponentTestEntity_AUD""
						)
				)
		);
	}",4.333333333333333
"@Test
	public void testHistoryOfEdIng2() {
		SetOwnedEntity ed1 = getEntityManager().find( SetOwnedEntity.class, ed1_id );
		SetOwnedEntity ed2 = getEntityManager().find( SetOwnedEntity.class, ed2_id );

		SetOwningEntity rev1 = getAuditReader().find( SetOwningEntity.class, ing2_id, 1 );
		SetOwningEntity rev2 = getAuditReader().find( SetOwningEntity.class, ing2_id, 2 );
		SetOwningEntity rev3 = getAuditReader().find( SetOwningEntity.class, ing2_id, 3 );
		SetOwningEntity rev4 = getAuditReader().find( SetOwningEntity.class, ing2_id, 4 );
		SetOwningEntity rev5 = getAuditReader().find( SetOwningEntity.class, ing2_id, 5 );

		assert rev1.getReferences().equals( Collections.EMPTY_SET );
		assert rev2.getReferences().equals( TestTools.makeSet( ed1, ed2 ) );
		assert rev3.getReferences().equals( TestTools.makeSet( ed1, ed2 ) );
		assert rev4.getReferences().equals( TestTools.makeSet( ed1, ed2 ) );
		assert rev5.getReferences().equals( TestTools.makeSet( ed1, ed2 ) );
	}",3.6666666666666665
"@Test
	public void testTernaryMap() {
		final TernaryMapEntity ternaryMap = new TernaryMapEntity();
		ternaryMap.setId( ternaryMapId );
		ternaryMap.getMap().put( intEntity1, stringEntity1 );
		ternaryMap.getMap().put( new IntTestPrivSeqEntity( 2, intEntity2.getId() ) , new StrTestPrivSeqEntity( ""Value 2"", stringEntity2.getId() ) );

		TernaryMapEntity entity = getAuditReader().find( TernaryMapEntity.class, ternaryMapId, 15 );

		Assert.assertEquals( ternaryMap.getMap(), entity.getMap() );

		ternaryMap.getMap().clear();
		ternaryMap.getMap().put( intEntity1, stringEntity1 );
		ternaryMap.getMap().put( intEntity2, stringEntity2 );

		entity = getAuditReader().find( TernaryMapEntity.class, ternaryMapId, 16 );

		Assert.assertEquals( ternaryMap.getMap(), entity.getMap() );

		List queryResult = getAuditReader().createQuery().forRevisionsOfEntity( TernaryMapEntity.class, false, true )
				.add( AuditEntity.id().eq( ternaryMapId ) )
				.add( AuditEntity.revisionType().eq( RevisionType.DEL ) )
				.getResultList();
		Object[] objArray = (Object[]) queryResult.get( 0 );

		Assert.assertEquals( 17, getRevisionNumber( objArray[1] ) );

		entity = (TernaryMapEntity) objArray[0];
		Assert.assertEquals( ternaryMap.getMap(), entity.getMap() );
	}",2.7777777777777777
"@Test
	@Priority(10)
	public void initData() {
		EntityManager em = getEntityManager();

		// Revision 1
		em.getTransaction().begin();
		country = Country.of( 123, ""Germany"" );
		em.persist( country );
		em.getTransaction().commit();

	}",4.555555555555555
"@Override
	public boolean equals(Object obj) {
		if ( this == obj ) {
			return true;
		}
		if ( !super.equals( obj ) ) {
			return false;
		}
		if ( getClass() != obj.getClass() ) {
			return false;
		}
		VersionsJoinTableRangeTestAlternateEntity other = (VersionsJoinTableRangeTestAlternateEntity) obj;
		if ( alternateValue == null ) {
			if ( other.alternateValue != null ) {
				return false;
			}
		}
		else if ( !alternateValue.equals( other.alternateValue ) ) {
			return false;
		}
		return true;
	}",4.222222222222222
"private Element createMiddleEntityXml(String auditMiddleTableName, String auditMiddleEntityName, String where) {
		final String schema = mainGenerator.getSchema(
				propertyAuditingData.getJoinTable().schema(),
				propertyValue.getCollectionTable()
		);
		final String catalog = mainGenerator.getCatalog(
				propertyAuditingData.getJoinTable().catalog(),
				propertyValue.getCollectionTable()
		);

		final Element middleEntityXml = MetadataTools.createEntity(
				xmlMappingData.newAdditionalMapping(),
				new AuditTableData( auditMiddleEntityName, auditMiddleTableName, schema, catalog ), null, null
		);
		final Element middleEntityXmlId = middleEntityXml.addElement( ""composite-id"" );

		// If there is a where clause on the relation, adding it to the middle entity.
		if ( where != null ) {
			middleEntityXml.addAttribute( ""where"", where );
		}

		middleEntityXmlId.addAttribute( ""name"", mainGenerator.getVerEntCfg().getOriginalIdPropName() );

		// Adding the revision number as a foreign key to the revision info entity to the composite id of the
		// middle table.
		mainGenerator.addRevisionInfoRelation( middleEntityXmlId );

		// Adding the revision type property to the entity xml.
		mainGenerator.addRevisionType(
				isEmbeddableElementType() ? middleEntityXmlId : middleEntityXml,
				middleEntityXml
		);

		// All other properties should also be part of the primary key of the middle entity.
		return middleEntityXmlId;
	}",3.111111111111111
"private void addTransactionFactories(StrategySelectorImpl strategySelector) {
		strategySelector.registerStrategyImplementor( TransactionFactory.class, JdbcTransactionFactory.SHORT_NAME, JdbcTransactionFactory.class );
		strategySelector.registerStrategyImplementor( TransactionFactory.class, ""org.hibernate.transaction.JDBCTransactionFactory"", JdbcTransactionFactory.class );

		strategySelector.registerStrategyImplementor( TransactionFactory.class, JtaTransactionFactory.SHORT_NAME, JtaTransactionFactory.class );
		strategySelector.registerStrategyImplementor( TransactionFactory.class, ""org.hibernate.transaction.JTATransactionFactory"", JtaTransactionFactory.class );

		strategySelector.registerStrategyImplementor( TransactionFactory.class, CMTTransactionFactory.SHORT_NAME, CMTTransactionFactory.class );
		strategySelector.registerStrategyImplementor( TransactionFactory.class, ""org.hibernate.transaction.CMTTransactionFactory"", CMTTransactionFactory.class );
	}",3.888888888888889
"@Override
      public String call() throws Exception {
         try {
            if (isTrace)
               log.tracef(""[%s] Wait for all executions paths to be ready to perform calls"", title(warmup));
            barrier.await();

            long start = System.nanoTime();
            int runs = 0;
            if (isTrace)
               log.tracef(""[%s] Start time: %d"", title(warmup), start);

//            while (USE_TIME && PutFromLoadStressTestCase.this.run.get()) {
//               if (runs % 100000 == 0)
//                  log.infof(""[%s] Query run # %d"", title(warmup), runs);
//
////               Customer customer = query();
////               deleteCached(customer);

               queryItems();
//               deleteCachedItems();
//
//               runs++;
//            }
            long end = System.nanoTime();
            long duration = end - start;
            if (isTrace)
               log.tracef(""[%s] End time: %d, duration: %d, runs: %d"",
                     title(warmup), start, duration, runs);

            return opsPerMS(duration, runs);
         } finally {
            if (isTrace)
               log.tracef(""[%s] Wait for all execution paths to finish"", title(warmup));

            barrier.await();
         }
      }",3.6666666666666665
"private void registeredPutWithInterveningRemovalTest(
         final boolean transactional, final boolean removeRegion)
         throws Exception {
      withCacheManager(new CacheManagerCallable(
            TestCacheManagerFactory.createCacheManager(false)) {
         @Override
         public void call() {
            PutFromLoadValidator testee = new PutFromLoadValidator(cm,
                  transactional ? tm : null,
                  PutFromLoadValidator.NAKED_PUT_INVALIDATION_PERIOD);
            try {
               if (transactional) {
                  tm.begin();
               }
               testee.registerPendingPut(KEY1);
               if (removeRegion) {
                  testee.invalidateRegion();
               } else {
                  testee.invalidateKey(KEY1);
               }

               boolean lockable = testee.acquirePutFromLoadLock(KEY1);
               try {
                  assertFalse(lockable);
               }
               finally {
                  if (lockable) {
                     testee.releasePutFromLoadLock(KEY1);
                  }
               }
            } catch (Exception e) {
               throw new RuntimeException(e);
            }
         }
      });
   }",2.7777777777777777
"@Override
	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
		super.prepareBootstrapRegistryBuilder( builder );
		builder.with(
				new Integrator() {

				    @Override
					public void integrate(
							Configuration configuration,
							SessionFactoryImplementor sessionFactory,
							SessionFactoryServiceRegistry serviceRegistry) {
                        integrate(serviceRegistry);
					}

                    @Override
				    public void integrate( MetadataImplementor metadata,
				                           SessionFactoryImplementor sessionFactory,
				                           SessionFactoryServiceRegistry serviceRegistry ) {
                        integrate(serviceRegistry);
				    }

                    private void integrate( SessionFactoryServiceRegistry serviceRegistry ) {
                        serviceRegistry.getService( EventListenerRegistry.class ).prependListeners(EventType.LOAD,
                                                                                                   new CustomLoadListener());
                    }

					@Override
					public void disintegrate(
							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
					}
				}
		);
	}",3.4444444444444446
"@Test
	@TestForIssue( jiraKey = ""HHH-2277"")
	public void testLoadEntityWithEagerFetchingToKeyManyToOneReferenceBackToSelf() {
		sessionFactory().getStatistics().clear();

		// long winded method name to say that this is a test specifically for HHH-2277 ;)
		// essentially we have a bidirectional association where one side of the
		// association is actually part of a composite PK.
		//
		// The way these are mapped causes the problem because both sides
		// are defined as eager which leads to the infinite loop; if only
		// one side is marked as eager, then all is ok.  In other words the
		// problem arises when both pieces of instance data are coming from
		// the same result set.  This is because no ""entry"" can be placed
		// into the persistence context for the association with the
		// composite key because we are in the process of trying to build
		// the composite-id instance
		Session s = openSession();
		s.beginTransaction();
		Customer cust = new Customer( ""Acme, Inc."" );
		Order order = new Order( new Order.Id( cust, 1 ) );
		cust.getOrders().add( order );
		s.save( cust );
		s.getTransaction().commit();
		s.close();

		s = openSession();
		s.beginTransaction();
		try {
			cust = ( Customer ) s.get( Customer.class, cust.getId() );
		}
		catch( OverflowCondition overflow ) {
			fail( ""get()/load() caused overflow condition"" );
		}
		s.delete( cust );
		s.getTransaction().commit();
		s.close();
	}",4.0
"@Test
	public void testNoChildren() throws Exception {
		reader = getReader( Entity2.class, ""field1"", ""element-collection.orm1.xml"" );
		assertAnnotationPresent( ElementCollection.class );
		assertAnnotationNotPresent( OrderBy.class );
		assertAnnotationNotPresent( OrderColumn.class );
		assertAnnotationNotPresent( MapKey.class );
		assertAnnotationNotPresent( MapKeyClass.class );
		assertAnnotationNotPresent( MapKeyTemporal.class );
		assertAnnotationNotPresent( MapKeyEnumerated.class );
		assertAnnotationNotPresent( MapKeyColumn.class );
		assertAnnotationNotPresent( MapKeyJoinColumns.class );
		assertAnnotationNotPresent( MapKeyJoinColumn.class );
		assertAnnotationNotPresent( Column.class );
		assertAnnotationNotPresent( Temporal.class );
		assertAnnotationNotPresent( Enumerated.class );
		assertAnnotationNotPresent( Lob.class );
		assertAnnotationNotPresent( AttributeOverride.class );
		assertAnnotationNotPresent( AttributeOverrides.class );
		assertAnnotationNotPresent( AssociationOverride.class );
		assertAnnotationNotPresent( AssociationOverrides.class );
		assertAnnotationNotPresent( CollectionTable.class );
		assertAnnotationNotPresent( Access.class );
		ElementCollection relAnno = reader.getAnnotation( ElementCollection.class );
		assertEquals( FetchType.LAZY, relAnno.fetch() );
		assertEquals( void.class, relAnno.targetClass() );
	}",3.555555555555556
"@Test
	public void testMultipleMapKeyAttributeOverrides() throws Exception {
		reader = getReader( Entity3.class, ""field1"", ""element-collection.orm11.xml"" );
		assertAnnotationPresent( ElementCollection.class );
		assertAnnotationNotPresent( MapKey.class );
		assertAnnotationNotPresent( MapKeyClass.class );
		assertAnnotationNotPresent( MapKeyTemporal.class );
		assertAnnotationNotPresent( MapKeyEnumerated.class );
		assertAnnotationNotPresent( MapKeyColumn.class );
		assertAnnotationNotPresent( MapKeyJoinColumns.class );
		assertAnnotationNotPresent( MapKeyJoinColumn.class );
		assertAnnotationNotPresent( AttributeOverride.class );
		assertAnnotationPresent( AttributeOverrides.class );
		AttributeOverrides overridesAnno = reader
				.getAnnotation( AttributeOverrides.class );
		AttributeOverride[] overrides = overridesAnno.value();
		assertEquals( 2, overrides.length );
		assertEquals( ""field1"", overrides[0].name() );
		assertEquals( """", overrides[0].column().name() );
		assertFalse( overrides[0].column().unique() );
		assertTrue( overrides[0].column().nullable() );
		assertTrue( overrides[0].column().insertable() );
		assertTrue( overrides[0].column().updatable() );
		assertEquals( """", overrides[0].column().columnDefinition() );
		assertEquals( """", overrides[0].column().table() );
		assertEquals( 255, overrides[0].column().length() );
		assertEquals( 0, overrides[0].column().precision() );
		assertEquals( 0, overrides[0].column().scale() );
		assertEquals( ""field2"", overrides[1].name() );
		assertEquals( ""col1"", overrides[1].column().name() );
		assertTrue( overrides[1].column().unique() );
		assertFalse( overrides[1].column().nullable() );
		assertFalse( overrides[1].column().insertable() );
		assertFalse( overrides[1].column().updatable() );
		assertEquals( ""int"", overrides[1].column().columnDefinition() );
		assertEquals( ""table1"", overrides[1].column().table() );
		assertEquals( 50, overrides[1].column().length() );
		assertEquals( 2, overrides[1].column().precision() );
		assertEquals( 1, overrides[1].column().scale() );
	}",2.888888888888889
"@Test
    public void testExplicitPropertyAccessAnnotationsWithHibernateStyleOverride() throws Exception {
        AnnotationConfiguration cfg = new AnnotationConfiguration();
        Class<?> classUnderTest = Course3.class;
        cfg.addAnnotatedClass( classUnderTest );
        cfg.addAnnotatedClass( Student.class );
        SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
        EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                .getEntityMetamodel()
                .getTuplizer();
        assertTrue(
                ""Field access should be used."",
                tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
        );

        assertTrue(
                ""Property access should be used."",
                tuplizer.getGetter( 0 ) instanceof BasicPropertyAccessor.BasicGetter
        );
		factory.close();
    }",3.2222222222222223
"@Test
	@TestForIssue( jiraKey = ""HHH-7309"" )
	public void testInsertUpdateEntity_NaturalIdCachedAfterTransactionSuccess() {
		
		Session session = openSession();
		session.getSessionFactory().getStatistics().clear();
		session.beginTransaction();
		Another it = new Another( ""it"");
		session.save( it );    // schedules an InsertAction
		it.setSurname(""1234""); // schedules an UpdateAction, without bug-fix
		// this will re-cache natural-id with identical key and at same time invalidate it
		session.flush();
		session.getTransaction().commit();
		session.close();
		
		session = openSession();
		session.beginTransaction();
		it = (Another) session.bySimpleNaturalId(Another.class).load(""it"");
		assertNotNull(it);
		session.delete(it);
		session.getTransaction().commit();
		assertEquals(""In a strict access strategy we would excpect a hit here"", 1, session.getSessionFactory().getStatistics().getNaturalIdCacheHitCount());
	}",3.2222222222222223
"@Test
	@Resources(annotatedClasses = {
			SubclassOfSingleTableInheritance.class,
			SingleEntity.class,
			RootOfSingleTableInheritance.class,
			OtherSubclassOfSingleTableInheritance.class,
			SubclassOfSubclassOfSingleTableInheritance.class
	})
	public void testNoPolymorphism() {
		EntityBinding noInheritanceEntityBinding = getEntityBinding( SingleEntity.class );
		assertTrue( ""SingleEntity should be a root entity"", noInheritanceEntityBinding.isRoot() );
		assertNull( noInheritanceEntityBinding.getSuperEntityBinding() );
		assertSame( noInheritanceEntityBinding, getRootEntityBinding( SingleEntity.class ) );
		assertFalse( noInheritanceEntityBinding.isPolymorphic() );
		assertFalse( noInheritanceEntityBinding.hasSubEntityBindings() );
		assertEquals( 0, noInheritanceEntityBinding.getSubEntityBindingClosureSpan() );
		assertFalse( noInheritanceEntityBinding.getPostOrderSubEntityBindingClosure().iterator().hasNext() );
		assertFalse( noInheritanceEntityBinding.getPreOrderSubEntityBindingClosure().iterator().hasNext() );
		Set<AttributeBinding> directAttributeBindings = new HashSet<AttributeBinding>();
		for ( AttributeBinding attributeBinding : noInheritanceEntityBinding.attributeBindings() ) {
			assertTrue( directAttributeBindings.add( attributeBinding ) );
		}
		assertEquals( 1, directAttributeBindings.size() );
		assertSame(
				noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(),
				directAttributeBindings.iterator().next()
		);
		assertEquals( 1, noInheritanceEntityBinding.getAttributeBindingClosureSpan() );
		Iterator<AttributeBinding> iterator = noInheritanceEntityBinding.attributeBindings().iterator();
		assertTrue( iterator.hasNext() );
		assertSame( noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(), iterator.next() );
		assertFalse( iterator.hasNext() );
		iterator = noInheritanceEntityBinding.getAttributeBindingClosure().iterator();
		assertTrue( iterator.hasNext() );
		assertSame( noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(), iterator.next() );
		assertFalse( iterator.hasNext() );
		iterator =  noInheritanceEntityBinding.getSubEntityAttributeBindingClosure().iterator();
		assertTrue( iterator.hasNext() );
		assertSame( noInheritanceEntityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding(), iterator.next() );
		assertFalse( iterator.hasNext() );
	}",2.333333333333333
"@Test
	@Resources(annotatedClasses = {
			SubclassOfSingleTableInheritance.class,
			SingleEntity.class,
			RootOfSingleTableInheritance.class,
			OtherSubclassOfSingleTableInheritance.class,
			SubclassOfSubclassOfSingleTableInheritance.class
	})
	public void testPreOrderRootSubEntityClosure() {
		EntityBinding rootEntityBinding = getEntityBinding( RootOfSingleTableInheritance.class );
		EntityBinding subclassEntityBinding = getEntityBinding( SubclassOfSingleTableInheritance.class );
		EntityBinding otherSubclassEntityBinding = getEntityBinding( OtherSubclassOfSingleTableInheritance.class );
		EntityBinding subclassOfSubclassEntityBinding = getEntityBinding( SubclassOfSubclassOfSingleTableInheritance.class );
		// need to figure out the order of direct subclasses, since it's indeterminate
		Iterator<EntityBinding> directEntityBindingIterator = rootEntityBinding.getDirectSubEntityBindings().iterator();
		boolean isSubclassEntityBindingFirst = subclassEntityBinding == directEntityBindingIterator.next();
		assertEquals( 3, rootEntityBinding.getSubEntityBindingClosureSpan() );
		Iterator<EntityBinding> subEntityBindingIterator = rootEntityBinding.getPreOrderSubEntityBindingClosure().iterator();
		assertTrue( subEntityBindingIterator.hasNext() );
		if ( isSubclassEntityBindingFirst ) {
			assertSame( subclassEntityBinding, subEntityBindingIterator.next() );
			assertTrue( subEntityBindingIterator.hasNext() );
			assertSame( subclassOfSubclassEntityBinding, subEntityBindingIterator.next() );
			assertTrue( subEntityBindingIterator.hasNext() );
			assertSame( otherSubclassEntityBinding, subEntityBindingIterator.next() );
		}
		else {
			assertSame( otherSubclassEntityBinding, subEntityBindingIterator.next() );
			assertTrue( subEntityBindingIterator.hasNext() );
			assertSame( subclassEntityBinding, subEntityBindingIterator.next() );
			assertTrue( subEntityBindingIterator.hasNext() );
			assertSame( subclassOfSubclassEntityBinding, subEntityBindingIterator.next() );
		}
		assertFalse( subEntityBindingIterator.hasNext() );
	}",2.555555555555556
"@Override
	protected void applyRootReturnSelectFragments(SelectStatementBuilder selectStatementBuilder) {
		selectStatementBuilder.appendSelectClauseFragment(
			getQueryableCollection().selectFragment(
					getCollectionReferenceAliases().getCollectionTableAlias(),
					getCollectionReferenceAliases().getCollectionColumnAliases().getSuffix()
			)
		);
		if ( getQueryableCollection().isManyToMany() ) {
			final OuterJoinLoadable elementPersister = (OuterJoinLoadable) getQueryableCollection().getElementPersister();
			selectStatementBuilder.appendSelectClauseFragment(
					elementPersister.selectFragment(
							getCollectionReferenceAliases().getElementTableAlias(),
							getCollectionReferenceAliases().getEntityElementAliases().getColumnAliases().getSuffix()
					)
			);
		}
		super.applyRootReturnSelectFragments( selectStatementBuilder );
	}",3.333333333333333
"@Override
	public void startingCollectionElements(CollectionElementDefinition elementDefinition) {
		final Type elementType = elementDefinition.getType();
		log.tracef(
				""%s Starting collection element graph : %s"",
				StringHelper.repeat( "">>"", fetchSourceStack.size() ),
				elementDefinition.getCollectionDefinition().getCollectionPersister().getRole()
		);

		final CollectionReference collectionReference = currentCollection();
		final CollectionFetchableElement elementGraph = collectionReference.getElementGraph();

		if ( elementType.isAssociationType() || elementType.isComponentType() ) {
			if ( elementGraph == null ) {
				throw new IllegalStateException(
						""CollectionReference did not return an expected element graph : "" +
								elementDefinition.getCollectionDefinition().getCollectionPersister().getRole()
				);
			}
			if ( !elementType.isAnyType() ) {
				pushToStack( (ExpandingFetchSource) elementGraph );
			}
		}
		else {
			if ( elementGraph != null ) {
				throw new IllegalStateException(
						""CollectionReference returned an unexpected element graph : "" +
								elementDefinition.getCollectionDefinition().getCollectionPersister().getRole()
				);
			}
		}
	}",3.555555555555556
"@Override
	protected void beforeTransactionCommit() {
		transactionCoordinator().sendBeforeTransactionCompletionNotifications( this );

		final boolean flush = ! transactionCoordinator().getTransactionContext().isFlushModeNever() &&
				( isDriver || ! transactionCoordinator().getTransactionContext().isFlushBeforeCompletionEnabled() );

		if ( flush ) {
			// if an exception occurs during flush, user must call rollback()
			transactionCoordinator().getTransactionContext().managedFlush();
		}

		if ( isDriver && isInitiator ) {
			transactionCoordinator().getTransactionContext().beforeTransactionCompletion( this );
		}

		closeIfRequired();
	}",4.222222222222222
"@Test
	public void testRevisionsCounts() {
		assertEquals(
				Arrays.asList( 1, 2, 3, 4 ), getAuditReader().getRevisions(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing1_id
		)
		);
		assertEquals(
				Arrays.asList( 1, 2, 4 ), getAuditReader().getRevisions(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id
		)
		);

		assertEquals(
				Arrays.asList( 1, 3, 4 ), getAuditReader().getRevisions(
				ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity.class,
				ed1_id
		)
		);
		assertEquals(
				Arrays.asList( 1, 2, 4 ), getAuditReader().getRevisions(
				ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity.class,
				ed2_id
		)
		);
		assertEquals(
				Arrays.asList( 1, 2, 3, 4 ), getAuditReader().getRevisions(
				ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity.class,
				ed3_id
		)
		);
	}",3.888888888888889
"@Test
	public void testHistoryOfIng2() {
		ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity ed2 = getEntityManager().find(
				ParentOwnedIndexedListJoinColumnBidirectionalRefEdEntity.class,
				ed2_id
		);

		ChildIndexedListJoinColumnBidirectionalRefIngEntity rev1 = getAuditReader().find(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id,
				1
		);
		ChildIndexedListJoinColumnBidirectionalRefIngEntity rev2 = getAuditReader().find(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id,
				2
		);
		ChildIndexedListJoinColumnBidirectionalRefIngEntity rev3 = getAuditReader().find(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id,
				3
		);
		ChildIndexedListJoinColumnBidirectionalRefIngEntity rev4 = getAuditReader().find(
				ChildIndexedListJoinColumnBidirectionalRefIngEntity.class,
				ing2_id,
				4
		);

		assertEquals( rev1.getReferences().size(), 0 );

		assertEquals( rev2.getReferences().size(), 1 );
		assertEquals( rev2.getReferences().get( 0 ), ed2 );

		assertEquals( rev3.getReferences().size(), 1 );
		assertEquals( rev3.getReferences().get( 0 ), ed2 );

		assertEquals( rev4.getReferences().size(), 0 );
	}",3.555555555555556
"@Test
	public void testObtainEntityNameAssociationWithEntityNameAndNotAuditedModeInNewSession() {
		//force a new session and AR
		forceNewSession();

		loadDataOnSessionAndAuditReader();

		checkEntities();

		checkEntityNames();

	}",4.444444444444445
"@Test
	@Priority(10)
	public void initData() {
		EntityManager em = getEntityManager();

		EmbeddableListEntity1 ele1 = new EmbeddableListEntity1();

		// Revision 1 (ele1: initially 1 element in both collections)
		em.getTransaction().begin();
		ele1.getComponentList().add( c3_1 );
		em.persist( ele1 );
		em.getTransaction().commit();

		// Revision (still 1) (ele1: removing non-existing element)
		em.getTransaction().begin();
		ele1 = em.find( EmbeddableListEntity1.class, ele1.getId() );
		ele1.getComponentList().remove( c3_2 );
		em.getTransaction().commit();

		// Revision 2 (ele1: adding one element)
		em.getTransaction().begin();
		ele1 = em.find( EmbeddableListEntity1.class, ele1.getId() );
		ele1.getComponentList().add( c3_2 );
		em.getTransaction().commit();

		// Revision 3 (ele1: adding one existing element)
		em.getTransaction().begin();
		ele1 = em.find( EmbeddableListEntity1.class, ele1.getId() );
		ele1.getComponentList().add( c3_1 );
		em.getTransaction().commit();

		// Revision 4 (ele1: removing one existing element)
		em.getTransaction().begin();
		ele1 = em.find( EmbeddableListEntity1.class, ele1.getId() );
		ele1.getComponentList().remove( c3_2 );
		em.getTransaction().commit();

		ele1_id = ele1.getId();

		em.close();
	}",3.888888888888889
"@Test
	@Priority(10)
	public void initData() {
		EntityManager em = getEntityManager();

		// Revision 1
		em.getTransaction().begin();
		PropertyOverrideEntity propertyEntity = new PropertyOverrideEntity( ""data 1"", 1, ""data 2"" );
		em.persist( propertyEntity );
		em.getTransaction().commit();
		propertyEntityId = propertyEntity.getId();

		// Revision 2
		em.getTransaction().begin();
		TransitiveOverrideEntity transitiveEntity = new TransitiveOverrideEntity( ""data 1"", 1, ""data 2"", 2, ""data 3"" );
		em.persist( transitiveEntity );
		em.getTransaction().commit();
		transitiveEntityId = transitiveEntity.getId();

		// Revision 3
		em.getTransaction().begin();
		AuditedSpecialEntity auditedEntity = new AuditedSpecialEntity( ""data 1"", 1, ""data 2"" );
		em.persist( auditedEntity );
		em.getTransaction().commit();
		auditedEntityId = auditedEntity.getId();

		propertyTable = getCfg().getClassMapping(
				""org.hibernate.envers.test.integration.superclass.auditoverride.PropertyOverrideEntity_AUD""
		).getTable();
		transitiveTable = getCfg().getClassMapping(
				""org.hibernate.envers.test.integration.superclass.auditoverride.TransitiveOverrideEntity_AUD""
		).getTable();
		auditedTable = getCfg().getClassMapping(
				""org.hibernate.envers.test.integration.superclass.auditoverride.AuditedSpecialEntity_AUD""
		).getTable();
	}",3.555555555555556
"protected void resetRegionUsageState(CacheAccessListener localListener, CacheAccessListener remoteListener) {
		String stdName = StandardQueryCache.class.getName();
		String acctName = Account.class.getName();

		localListener.getSawRegionModification( stdName );
		localListener.getSawRegionModification( acctName );

		localListener.getSawRegionAccess( stdName );
		localListener.getSawRegionAccess( acctName );

		remoteListener.getSawRegionModification( stdName );
		remoteListener.getSawRegionModification( acctName );

		remoteListener.getSawRegionAccess( stdName );
		remoteListener.getSawRegionAccess( acctName );

		log.info( ""Region usage state cleared"" );
	}",3.7777777777777777
"@Override
	public void configure(Configuration cfg) {
		super.configure( cfg );
		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, ""true"" );
		cfg.setProperty( Environment.GENERATE_STATISTICS, ""true"" );
		cfg.setProperty( Environment.USE_QUERY_CACHE, ""false"" );
		cfg.setProperty( Environment.CACHE_REGION_FACTORY, getCacheRegionFactory().getName() );
		cfg.setProperty( Environment.TRANSACTION_STRATEGY, getTransactionFactoryClass().getName() );
		cfg.getProperties().put( AvailableSettings.JTA_PLATFORM, getJtaPlatform() );
		cfg.setProperty( Environment.CONNECTION_PROVIDER, getConnectionProviderClass().getName() );
	}",4.444444444444445
"@Test
	public void testOrphanDelete() {
		Session session = openSession();
		Transaction t = session.beginTransaction();
		Product prod = new Product( ""Widget"" );
		Part part = new Part( ""Widge"", ""part if a Widget"" );
		MapKey mapKey = new MapKey( ""Top"" );
		prod.getParts().put( mapKey, part );
		Part part2 = new Part( ""Get"", ""another part if a Widget"" );
		prod.getParts().put( new MapKey( ""Bottom"" ), part2 );
		session.persist( prod );
		t.commit();
		session.close();

		sessionFactory().getCache().evictEntityRegion(Product.class);
		sessionFactory().getCache().evictEntityRegion(Part.class);

		session = openSession();
		t = session.beginTransaction();
		prod = (Product) session.get(Product.class, ""Widget"");
		assertTrue( Hibernate.isInitialized( prod.getParts() ) );
		part = (Part) session.get(Part.class, ""Widge"");
		prod.getParts().remove(mapKey);
		t.commit();
		session.close();

		sessionFactory().getCache().evictEntityRegion( Product.class );
		sessionFactory().getCache().evictEntityRegion(Part.class);

		session = openSession();
		t = session.beginTransaction();
		prod = (Product) session.get(Product.class, ""Widget"");
		assertTrue( Hibernate.isInitialized( prod.getParts() ) );
		assertNull( prod.getParts().get(new MapKey(""Top"")));
		assertNotNull( session.get(Part.class, ""Get"") );
		session.delete( session.get(Product.class, ""Widget"") );
		t.commit();
		session.close();
	}",3.111111111111111
"protected AnnotationInstance parserPrimaryKeyJoinColumnList(List<JaxbPrimaryKeyJoinColumn> primaryKeyJoinColumnList, AnnotationTarget target) {
		if ( MockHelper.isNotEmpty( primaryKeyJoinColumnList ) ) {
			if ( primaryKeyJoinColumnList.size() == 1 ) {
				return parserPrimaryKeyJoinColumn( primaryKeyJoinColumnList.get( 0 ), target );
			}
			else {
				return create(
						PRIMARY_KEY_JOIN_COLUMNS,
						target,
						nestedPrimaryKeyJoinColumnList( ""value"", primaryKeyJoinColumnList, null )
				);
			}
		}

		return null;

	}",3.7777777777777777
"public static <T> JaxbRoot<T> unmarshallXml(String fileName, String schemaName, Class<T> clazz, ClassLoaderService classLoaderService)
            throws JAXBException {
        Schema schema = getMappingSchema( schemaName, classLoaderService );
        InputStream in = classLoaderService.locateResourceStream( fileName );
        JAXBContext jc = JAXBContext.newInstance( clazz );
        Unmarshaller unmarshaller = jc.createUnmarshaller();
        unmarshaller.setSchema( schema );
        StreamSource stream = new StreamSource( in );
        JAXBElement<T> elem = unmarshaller.unmarshal( stream, clazz );
        Origin origin = new Origin( null, fileName );
        return new JaxbRoot<T>( elem.getValue(), origin );
    }",3.111111111111111
"private AnnotationInstance overrideSchemaCatalogByDefault(AnnotationInstance annotationInstance, EntityMappingsMocker.Default defaults) {
		List<AnnotationValue> newAnnotationValueList = new ArrayList<AnnotationValue>();
		newAnnotationValueList.addAll( annotationInstance.values() );
		boolean schemaDefined = false;
		boolean catalogDefined = false;
		if ( annotationInstance.value( ""schema"" ) != null ) {
			schemaDefined = true;
		}
		if ( annotationInstance.value( ""catalog"" ) != null ) {
			catalogDefined = true;
		}
		if ( schemaDefined && catalogDefined ) {
			return annotationInstance;
		}
		if ( !catalogDefined && StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
			newAnnotationValueList.add(
					AnnotationValue.createStringValue(
							""catalog"", defaults.getCatalog()
					)
			);
		}
		if ( !schemaDefined && StringHelper.isNotEmpty( defaults.getSchema() ) ) {
			newAnnotationValueList.add(
					AnnotationValue.createStringValue(
							""schema"", defaults.getSchema()
					)
			);
		}
		return MockHelper.create(
				annotationInstance.name(),
				annotationInstance.target(),
				MockHelper.toArray( newAnnotationValueList )
		);
	}",3.333333333333333
"public AbstractRowReader(ReaderCollector readerCollector) {
		this.entityReferenceInitializers = readerCollector.getEntityReferenceInitializers() != null
				? new ArrayList<EntityReferenceInitializer>( readerCollector.getEntityReferenceInitializers() )
				: Collections.<EntityReferenceInitializer>emptyList();
		this.arrayReferenceInitializers = readerCollector.getArrayReferenceInitializers() != null
				? new ArrayList<CollectionReferenceInitializer>( readerCollector.getArrayReferenceInitializers() )
				: Collections.<CollectionReferenceInitializer>emptyList();
		this.collectionReferenceInitializers = readerCollector.getNonArrayCollectionReferenceInitializers() != null
				? new ArrayList<CollectionReferenceInitializer>( readerCollector.getNonArrayCollectionReferenceInitializers() )
				: Collections.<CollectionReferenceInitializer>emptyList();
	}",2.555555555555556
"private void resolveEntityKey(
			ResultSet resultSet,
			ResultSetProcessingContextImpl context,
			FetchSource fetchSource,
			Map<EntityReference,EntityReferenceInitializer> initializerByEntityReference) throws SQLException {
		// Resolve any bidirectional entity references first.
		for ( BidirectionalEntityReference bidirectionalEntityReference : fetchSource.getBidirectionalEntityReferences() ) {
			final EntityReferenceInitializer targetEntityReferenceInitializer = initializerByEntityReference.get(
					bidirectionalEntityReference.getTargetEntityReference()
			);
			resolveEntityKey(
					resultSet,
					context,
					targetEntityReferenceInitializer,
					initializerByEntityReference
			);
			targetEntityReferenceInitializer.hydrateEntityState( resultSet, context );
		}
		for ( Fetch fetch : fetchSource.getFetches() ) {
			if ( EntityFetch.class.isInstance( fetch ) ) {
				final EntityFetch entityFetch = (EntityFetch) fetch;
				final EntityReferenceInitializer  entityReferenceInitializer = initializerByEntityReference.get( entityFetch );
				if ( entityReferenceInitializer != null ) {
					resolveEntityKey(
							resultSet,
							context,
							entityReferenceInitializer,
							initializerByEntityReference
					);
					entityReferenceInitializer.hydrateEntityState( resultSet, context );
				}
			}
			else if ( CompositeFetch.class.isInstance( fetch ) ) {
				resolveEntityKey(
						resultSet,
						context,
						(CompositeFetch) fetch,
						initializerByEntityReference );
			}
		}
	}",3.0
"public EntityKey interpretEntityKey(
			SessionImplementor session,
			String optionalEntityName,
			Serializable optionalId,
			Object optionalObject) {
		if ( optionalEntityName != null ) {
			final EntityPersister entityPersister;
			if ( optionalObject != null ) {
				entityPersister = session.getEntityPersister( optionalEntityName, optionalObject );
			}
			else {
				entityPersister = session.getFactory().getEntityPersister( optionalEntityName );
			}
			if ( entityPersister.isInstance( optionalId ) &&
					!entityPersister.getEntityMetamodel().getIdentifierProperty().isVirtual() &&
					entityPersister.getEntityMetamodel().getIdentifierProperty().isEmbedded() ) {
				// non-encapsulated composite identifier
				final Serializable identifierState = ((CompositeType) entityPersister.getIdentifierType()).getPropertyValues(
						optionalId,
						session
				);
				return session.generateEntityKey( identifierState, entityPersister );
			}
			else {
				return session.generateEntityKey( optionalId, entityPersister );
			}
		}
		else {
			return null;
		}
	}",3.0
"@Test
	public void testChildIdColumnName() {
		Assert.assertEquals(
				""other_id"",
				((Column) getCfg()
						.getClassMapping(
								""org.hibernate.envers.test.integration.inheritance.joined.primarykeyjoin.ChildPrimaryKeyJoinEntity_AUD""
						)
						.getKey().getColumnIterator().next()).getName()
		);
	}",3.6666666666666665
"@After
	public void cleanup() {
		b.setC( null );
		b.setD( null );
		b.getGCollection().remove( g );

		c.getBCollection().remove( b );
		c.getDCollection().remove( d );

		d.getBCollection().remove( b );
		d.setC( null );
		d.setE( null );
		d.getFCollection().remove( f );

		e.getDCollection().remove( d );
		e.setF( null );

		f.setD( null );
		f.getECollection().remove( e );
		f.setG( null );

		g.setB( null );
		g.getFCollection().remove( f );

		Session s = openSession();
		s.getTransaction().begin();
		b = ( B ) s.merge( b );
		c = ( C ) s.merge( c );
		d = ( D ) s.merge( d );
		e = ( E ) s.merge( e );
		f = ( F ) s.merge( f );
		g = ( G ) s.merge( g );
		s.delete( f );
		s.delete( g );
		s.delete( b );
		s.delete( d );
		s.delete( e );
		s.delete( c );
		s.getTransaction().commit();
		s.close();
	}",3.2222222222222223
