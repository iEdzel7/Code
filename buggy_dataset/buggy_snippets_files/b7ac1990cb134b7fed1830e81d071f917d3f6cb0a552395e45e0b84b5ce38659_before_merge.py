def fix_all_git_symlinked(topdir):
    """inplace conversion of git symlinks to real content

    Most (all?) of git implementations in windows store a symlink pointing
    into the repo as a text file, the text being the relative path to the
    file with the real content.

    So, in a clone of nikola in windows the symlinked files will have the
    wrong content; a .zip download from Github has the same problem.

    This function will rewrite each symlinked file with the correct contents, but
    keep in mind that the working copy will be seen as dirty by git after operation.

    Expects to find a list of symlinked files at nikola/data/symlinked.txt

    The list can be generated by scripts/generate_symlinked_list.sh , which is
    basically a redirect of
         cd nikola_checkout
         git ls-files -s | awk '/120000/{print $4}'

    Weakness: if interrupted of fail amidst a directory copy, next run will not
    see the missing files.
    """
    with open(topdir + r'\nikola\data\symlinked.txt', 'rb') as f:
        all_bytes = f.read()
        text = all_bytes.decode('utf8')
    # expect each line a relpath from git or zip root,
    # smoke test relpaths are relative to git root
    if text.startswith('.'):
        raise Exception(r'Bad data in \nikola\data\symlinked.txt')
    relnames = text.split('\n')
    relnames = [name.strip().replace('/', '\\') for name in relnames]
    relnames = [name for name in relnames if name]

    failures = 0
    for name in relnames:
        # build dst path and do some basic validation
        dst = os.path.join(topdir, name)
        # don't access files outside topdir
        if not is_file_into_dir(dst, topdir):
            continue
        if os.path.isdir(dst):
            # assume the file was de-symlinked
            continue

        # build src path and do some basic validation
        with open(os.path.join(topdir, dst), 'r') as f:
            text = f.read()
        dst_dir = os.path.dirname(dst)
        try:
            src = os.path.normpath(os.path.join(dst_dir, text))
            if not os.path.exists(src):
                # assume the file was de-symlinked before
                continue
            # don't access files outside topdir
            if not is_file_into_dir(src, topdir):
                continue
        except Exception:
            # assume the file was de-symlinked before
            continue

        # copy src to dst
        try:
            if os.path.isdir(src):
                os.unlink(dst)
                shutil.copytree(src, dst)
            else:
                shutil.copy2(src, dst)
        except Exception:
            failures += 1
            print("*** copy failed for")
            print("\t src:", src)
            print("\t dst:", dst)

    return failures