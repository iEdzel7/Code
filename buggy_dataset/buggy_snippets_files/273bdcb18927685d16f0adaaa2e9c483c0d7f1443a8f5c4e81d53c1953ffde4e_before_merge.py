def _mask_event_data(object_to_be_masked, query_name, column, blacklisted_object, mask_with, globbing_enabled):
    '''
    This method is responsible for masking potential secrets in event data generated by
    osquery daemon. This will handle logs format of both differential and snapshot types

    Logs generated by 'osqueryi' would not reach here due checks in parent method

    object_to_be_masked
        data structure to mask recursively

    query_name
        Perform masking only if query name in 'object_to_be_masked' matches the 'query_name'

    column
        column in which masking is to be performed

    blacklisted_object
        the blacklisted_objects entry from the mask.yaml

    mask_with
        masked values are replaced with this string

    globbing_enabled
        enable globbing in specified blacklisted patterns of mask file
    '''
    if not query_name:
        query_name = object_to_be_masked['name']

    if object_to_be_masked['action'] == 'snapshot' and query_name == object_to_be_masked['name']:
        # This means we have event data of type 'snapshot'
        for snap_object in object_to_be_masked['snapshot']:
            if column not in snap_object or \
                    (isinstance(snap_object[column], basestring) and
                     snap_object[column].strip() != ''):
                log.error('masking data references a missing column {0} in query {1}'
                          .format(column, query_name))
                break
            if isinstance(snap_object[column], basestring):
                value = snap_object[column]
                for pattern in blacklisted_object['blacklisted_patterns']:
                    value = re.sub(pattern + '()', r'\1' + mask_with + r'\3', value)
                snap_object[column] = value
            else:
                _recursively_mask_objects(snap_object[column], blacklisted_object, mask_with, globbing_enabled)
    elif query_name == object_to_be_masked['name']:
        q_result = object_to_be_masked['columns']
        if column not in q_result or \
                (isinstance(q_result[column], basestring) and
                 q_result[column].strip() != ''):
            log.error('masking data references a missing column {0} in query {1}'
                      .format(column, query_name))
        if isinstance(q_result[column], basestring):
            value = q_result[column]
            for pattern in blacklisted_object['blacklisted_patterns']:
                value = re.sub(pattern + '()', r'\1' + mask_with + r'\3', value)
            q_result[column] = value
        else:
            _recursively_mask_objects(q_result[column], blacklisted_object, mask_with, globbing_enabled)
    else:
        # Unable to match query_name
        log.debug('Skipping masking, as event data is not for query: {0}'.format(query_name))