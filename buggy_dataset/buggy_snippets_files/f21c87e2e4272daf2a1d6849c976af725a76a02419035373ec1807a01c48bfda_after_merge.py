def main(args: Optional[Sequence[str]] = None) -> Exit:
    """Main function."""

    # add cli completion support
    argcomplete.autocomplete(arg_parser)

    if args is None:
        args = sys.argv[1:]

    namespace: Namespace = arg_parser.parse_args(args)

    if namespace.version:  # pragma: no cover
        from datamodel_code_generator.version import version

        print(version)
        exit(0)

    if namespace.debug:  # pragma: no cover
        enable_debug_message()

    extra_template_data: Optional[DefaultDict[str, Dict]]
    if namespace.extra_template_data is not None:
        with namespace.extra_template_data as data:
            extra_template_data = json.load(
                data, object_hook=lambda d: defaultdict(dict, **d)
            )
    else:
        extra_template_data = None

    text: str = namespace.input.read()

    input_file_type: str = namespace.input_file_type

    if input_file_type == 'auto':
        try:
            input_file_type = 'openapi' if is_openapi(text) else 'jsonschema'
        except:
            print('Invalid file format')
            return Exit.ERROR

    if input_file_type == 'openapi':
        from datamodel_code_generator.parser.openapi import OpenAPIParser

        parser_class: Type[Parser] = OpenAPIParser
    else:
        from datamodel_code_generator.parser.jsonschema import JsonSchemaParser

        parser_class = JsonSchemaParser

    parser = parser_class(
        BaseModel,
        CustomRootType,
        DataModelField,
        base_class=namespace.base_class,
        custom_template_dir=namespace.custom_template_dir,
        extra_template_data=extra_template_data,
        target_python_version=PythonVersion(namespace.target_python_version),
        text=text,
        dump_resolve_reference_action=dump_resolve_reference_action,
        validation=namespace.validation,
    )

    output = Path(namespace.output) if namespace.output is not None else None

    with chdir(output):
        result = parser.parse()

    if isinstance(result, str):
        modules = {output: result}
    else:
        if output is None:
            print('Modular references require an output directory')
            return Exit.ERROR
        if output.suffix:
            print('Modular references require an output directory, not a file')
            return Exit.ERROR
        modules = {
            output.joinpath(*name): body for name, body in sorted(result.items())
        }

    timestamp = datetime.now(timezone.utc).replace(microsecond=0).isoformat()
    header = f'''\
# generated by datamodel-codegen:
#   filename:  {Path(namespace.input.name).name}
#   timestamp: {timestamp}'''

    file: Optional[IO[Any]]
    for path, body in modules.items():
        if path is not None:
            if not path.parent.exists():
                path.parent.mkdir(parents=True)
            file = path.open('wt')
        else:
            file = None

        print(header, file=file)
        if body:
            print('', file=file)
            print(body.rstrip(), file=file)

        if file is not None:
            file.close()

    return Exit.OK