    async def _playlist_download(
        self,
        ctx: commands.Context,
        playlist_matches: PlaylistConverter,
        v2: Optional[bool] = False,
        *,
        scope_data: ScopeParser = None,
    ):
        """Download a copy of a playlist.

        These files can be used with the [p]playlist upload command.
        Red v2-compatible playlists can be generated by passing True
        for the v2 variable.

        **Usage**:
        ​ ​ ​ ​ [p]playlist download playlist_name_OR_id [v2=True_OR_False] args

        **Args**:
        ​ ​ ​ ​ The following are all optional:
        ​ ​ ​ ​ ​ ​ ​ ​ --scope <scope>
        ​ ​ ​ ​ ​ ​ ​ ​ --author [user]
        ​ ​ ​ ​ ​ ​ ​ ​ --guild [guild] **Only the bot owner can use this**

        Scope is one of the following:
        ​ ​ ​ ​ Global
        ​ ​ ​ ​ Guild
        ​ ​ ​ ​ User

        Author can be one of the following:
        ​ ​ ​ ​ User ID
        ​ ​ ​ ​ User Mention
        ​ ​ ​ ​ User Name#123

        Guild can be one of the following:
        ​ ​ ​ ​ Guild ID
        ​ ​ ​ ​ Exact guild name

        Example use:
        ​ ​ ​ ​ [p]playlist download MyGuildPlaylist True
        ​ ​ ​ ​ [p]playlist download MyGlobalPlaylist False --scope Global
        ​ ​ ​ ​ [p]playlist download MyPersonalPlaylist --scope User
        """
        if scope_data is None:
            scope_data = [PlaylistScope.GUILD.value, ctx.author, ctx.guild, False]
        scope, author, guild, specified_user = scope_data

        try:
            playlist_id, playlist_arg = await self._get_correct_playlist_id(
                ctx, playlist_matches, scope, author, guild, specified_user
            )
        except TooManyMatches as e:
            return await self._embed_msg(ctx, str(e))
        if playlist_id is None:
            return await self._embed_msg(
                ctx, _("Could not match '{arg}' to a playlist.").format(arg=playlist_arg)
            )

        try:
            playlist = await get_playlist(playlist_id, scope, self.bot, guild, author)
        except RuntimeError:
            return await self._embed_msg(
                ctx,
                _("Playlist {id} does not exist in {scope} scope.").format(
                    id=playlist_id, scope=humanize_scope(scope, the=True)
                ),
            )
        except MissingGuild:
            return await self._embed_msg(
                ctx, _("You need to specify the Guild ID for the guild to lookup.")
            )

        schema = 2
        version = "v3" if v2 is False else "v2"

        if not playlist.tracks:
            return await self._embed_msg(ctx, _("That playlist has no tracks."))
        if version == "v2":
            v2_valid_urls = ["https://www.youtube.com/watch?v=", "https://soundcloud.com/"]
            song_list = []
            for track in playlist.tracks:
                if track["info"]["uri"].startswith(tuple(v2_valid_urls)):
                    song_list.append(track["info"]["uri"])
            playlist_data = {
                "author": playlist.author,
                "link": playlist.url,
                "playlist": song_list,
                "name": playlist.name,
            }
            file_name = playlist.name
        else:
            playlist_data = playlist.to_json()
            playlist_songs_backwards_compatible = [
                track["info"]["uri"] for track in playlist.tracks
            ]
            playlist_data[
                "playlist"
            ] = (
                playlist_songs_backwards_compatible
            )  # TODO: Keep new playlists backwards compatible, Remove me in a few releases
            playlist_data[
                "link"
            ] = (
                playlist.url
            )  # TODO: Keep new playlists backwards compatible, Remove me in a few releases
            file_name = playlist.id
        playlist_data.update({"schema": schema, "version": version})
        playlist_data = json.dumps(playlist_data)
        to_write = StringIO()
        to_write.write(playlist_data)
        to_write.seek(0)
        await ctx.send(file=discord.File(to_write, filename=f"{file_name}.txt"))
        to_write.close()